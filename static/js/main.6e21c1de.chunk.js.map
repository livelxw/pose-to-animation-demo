{"version":3,"sources":["../../webgl/src/WebGL.ts","config/skeleton.ts","../../core/src/Animation.ts","../../core/src/AnimationState.ts","../../core/src/AnimationStateData.ts","../../core/src/AssetManager.ts","../../core/src/AtlasAttachmentLoader.ts","../../core/src/BlendMode.ts","../../core/src/Bone.ts","../../core/src/BoneData.ts","../../core/src/ConstraintData.ts","../../core/src/Event.ts","../../core/src/EventData.ts","../../core/src/IkConstraint.ts","../../core/src/IkConstraintData.ts","../../core/src/PathConstraint.ts","../../core/src/PathConstraintData.ts","../../core/src/SharedAssetManager.ts","../../core/src/Skeleton.ts","../../core/src/SkeletonBinary.ts","../../core/src/SkeletonBounds.ts","../../core/src/SkeletonClipping.ts","../../core/src/SkeletonData.ts","../../core/src/SkeletonJson.ts","../../core/src/Skin.ts","../../core/src/Slot.ts","../../core/src/SlotData.ts","../../core/src/Texture.ts","../../core/src/TextureAtlas.ts","../../core/src/TransformConstraint.ts","../../core/src/TransformConstraintData.ts","../../core/src/Triangulator.ts","../../core/src/Utils.ts","../../core/src/polyfills.ts","../../core/src/attachments/Attachment.ts","../../core/src/attachments/AttachmentType.ts","../../core/src/attachments/BoundingBoxAttachment.ts","../../core/src/attachments/ClippingAttachment.ts","../../core/src/attachments/MeshAttachment.ts","../../core/src/attachments/PathAttachment.ts","../../core/src/attachments/PointAttachment.ts","../../core/src/attachments/RegionAttachment.ts","../../core/src/vertexeffects/JitterEffect.ts","../../core/src/vertexeffects/SwirlEffect.ts","../../webgl/src/AssetManager.ts","../../webgl/src/Camera.ts","../../webgl/src/GLTexture.ts","../../webgl/src/Input.ts","../../webgl/src/LoadingScreen.ts","../../webgl/src/Matrix4.ts","../../webgl/src/Mesh.ts","../../webgl/src/PolygonBatcher.ts","../../webgl/src/SceneRenderer.ts","../../webgl/src/Shader.ts","../../webgl/src/ShapeRenderer.ts","../../webgl/src/SkeletonDebugRenderer.ts","../../webgl/src/SkeletonRenderer.ts","../../webgl/src/Vector3.ts","components/animation/CanvasCard.tsx","components/animation/useCanvas.ts","components/animation/useWebcam.ts","components/animation/PoseAnimation.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["coco_skeleton_indices","i","CurveTimeline","bone","frame","r","ColorTimeline","PREV_R","PREV_G","PREV_B","PREV_A","this","PREV_TRANSLATE","time","useStyles","makeStyles","theme","createStyles","root","flexGrow","media","height","paddingTop","expand","transform","marginLeft","transition","transitions","create","duration","shortest","expandOpen","avatar","backgroundColor","red","CanvasCard","props","classes","React","useState","Card","className","CardHeader","title","CardContent","ref","canvasRef","useCanvas","draw","options","useRef","useEffect","canvas","current","width","context","getContext","animationFrameId","render","window","requestAnimationFrame","cancelAnimationFrame","useWebcam","stream","setStream","videoRef","a","navigator","mediaDevices","getUserMedia","facingMode","initStream","video","srcObject","play","drawPoint","ctx","x","y","color","beginPath","arc","Math","PI","fillStyle","fill","toTuple","data","drawSegment","scale","ax","ay","bx","by","moveTo","lineTo","lineWidth","strokeStyle","stroke","PoseAnimation","net","setNet","assetManager","setAssetManager","initialized","setInitialized","managerLoaded","setManagerLoaded","videoLoadedData","setVideoLoadedData","model2D","setModel2D","bonesToInvisible","setBonesToInvisible","skeletonRender","setSkeletonRender","poseSkeleton","setPoseSkeleton","atlas","json","skinName","initialAnimation","poseSkeletonKeypointName","hip","rightUpLeg","rightLeg","leftUpLeg","leftLeg","neck","head","rightArm","rightForeArm","leftArm","leftForeArm","model2DInfo","humanPose","setHumanPose","animationPose","setAnimationPose","animationPoseRendered","setAnimationPoseRendered","webcamRef","minConfidence","faceMaskImageRef","image","src","onloadeddata","event","estimateSinglePose","flipHorizontal","pose","getPose","loadModel2D","premultipliedAlpha","get","atlasLoader","spine","AtlasAttachmentLoader","skeletonJson","SkeletonJson","skeletonData","readSkeletonData","skeleton","Skeleton","setSkinByName","bounds","setToSetupPose","updateWorldTransform","offset","Vector2","size","getBounds","calculateSetupPoseBounds","animationStateData","AnimationStateData","animationState","AnimationState","setAnimation","state","loadManager","isLoadingComplete","setTimeout","animationContextType","animationCanvasRef","animateDetectedBone","chaBone","initKeyPt","termKeyPt","name","animationWidth","animationHeight","score","rotation","worldToLocalRotation","initPt","termPt","co","sqrt","acos","getAngle","position","includes","WebGLRenderingContext","clearColor","clear","COLOR_BUFFER_BIT","begin","keypoints","drawSkeleton","drawSkeletonDebug","end","humanCanvasRef","CanvasRenderingContext2D","save","drawImage","restore","length","keypoint","drawKeypoints","getAdjacentKeyPoints","forEach","tfjs","loadPoseNet","architecture","outputStride","inputResolution","multiplier","quantBytes","loadModel","aManager","webgl","AssetManager","SceneRenderer","loadTextureAtlas","loadText","initManager","canvasWidth","canvasHeight","curPoseSkeleton","findBone","update","apply","camera","set","skeletonDebugRenderer","drawBones","drawRegionAttachments","drawBoundingBoxes","drawMeshHull","drawMeshTriangles","drawPaths","drawSkeletonXY","drawClipping","invisibleBones","validBones","Object","values","n","bones","_bone","push","initSkeleton","style","display","playsInline","Grid","container","spacing","direction","justify","alignItems","item","xs","App","Container","maxWidth","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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AAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,SAC1E,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,O,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAA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,EAGD,+B,MACC,U,EACA,Y,EACA,S,WACA,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,KACpE,SAAO,O,EAGR,mC,MACC,U,EACA,Y,EACA,S,WACA,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,IACpE,KAAE,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,KAAM,IAAG,K,KACpE,SAAO,O,EAGR,4BAAQ,EAAmB,G,EAC1B,Y,MACA,EAAI,MAAQ,EAAQ,EAAO,MAAQ,EAAQ,EAAO,M,EAClD,WAAa,Y,EACb,WAAa,Y,QACb,e,EACA,WAAM,MAAQ,GAAO,Y,KACrB,W,MACA,Y,WACA,KAAI,I,IACJ,KAAI,I,IACJ,KAAI,I,IACJ,KAAI,I,IACJ,KAAI,I,IACJ,KAAI,I,IACJ,MAAI,I,IACJ,MAAI,I,IACJ,MAAI,I,EAEJ,qB,EACA,iBAAQ,EAAU,MAAO,EAAI,E,EAC7B,iBAAQ,EAAU,MAAO,EAAI,E,EAC7B,iBAAQ,EAAU,MAAO,EAAI,E,KAC7B,WAAK,WAEL,M,EAGM,UAAP,WACK,O,EAAJ,Q,EAA4B,YAAQ,SAChC,O,EAAJ,Q,EAA4B,YAAQ,SAChC,O,EAAJ,Q,EAA4B,YAAQ,U,EA7RtB,W,EACA,W,EACA,W,EACA,gBA4RhB,EAnSA,G,EAAa,U,CAlBD,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,a,SAuCC,IAAa,EAAuE,EAA+B,G,KAA/B,a,KAnC5E,iB,KACA,iB,KAGA,gB,KACA,gB,KACA,oB,KA8BP,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,KAC9E,kBAAK,E,UACL,IAAK,EAAY,OAAG,I,KACnB,mBAAK,EAAiB,e,KAEvB,SAAI,IAAC,aAAe,EAAa,wB,KACjC,YAAK,YAAc,G,KACnB,sBAAa,M,SAnCd,+CAAsC,Y,EAEtC,6CAAyB,SAAY,OAAS,wB,EAC9C,6CAAyB,eAAY,wB,EACrC,wC,KACC,eAAK,E,KACL,eAAK,G,EAEN,6CAA+B,U,EAE/B,4CAAwB,QAAW,Q,EACnC,4CAAwB,e,EACxB,uC,KACC,cAAK,E,KACL,cAAK,G,EAEN,4CAA6B,S,EAE7B,2C,UACC,E,EACA,IAAK,KAAQ,WAAW,OAAC,IAAW,C,GACnC,KAAI,WAAY,GAChB,Y,OAED,G,EAcD,kC,QACC,eAAK,E,EACL,OAAI,KAAS,SAAS,O,YAAsB,8BAAY,mBAAqC,a,KAC7F,aAAK,EAAS,G,KACd,eAAK,EAAc,Q,EAGpB,iC,QACC,cAAK,E,EACL,OAAI,KAAQ,QAAS,O,YAAqB,8BAAY,kBAAqC,Y,KAC3F,YAAK,EAAQ,G,KACb,cAAK,U,EAGN,6B,KACC,eAAK,IAAuB,qBAAuB,OAAa,cAAW,oBAAoB,yB,EAGhG,sCAAgC,EAAqB,G,MACpD,aAAS,I,KACT,eAAS,oB,KAAoC,S,UAC7C,G,KACA,cAAS,E,EACR,eAAgB,mBAAyB,K,aAEzC,EAAc,K,YAEf,I,EAGD,2B,MACC,aAAS,G,EACT,WAAE,EAAC,aAAc,qB,UACjB,E,EACA,IAAK,KAAQ,WAAW,OAAC,IAAW,C,MACnC,gBAAa,G,EACb,EAAI,qBAAkB,Q,EACtB,wBAAG,G,EACH,oBAAG,IAAoB,YAAU,EAAO,SAAmC,EAApB,KAAC,kBAAoC,EAAjB,G,GAC3E,c,KAED,cAAS,G,aAAmB,EAAE,qBAAe,qB,EAG9C,6B,UACC,aAAS,G,EACT,IAAK,KAAQ,WAAW,OAAC,IAAW,C,MACnC,gBAAa,G,EACb,EAAI,qBAAkB,Q,EACtB,yBAAG,G,EAEJ,WAAE,EAAC,aAAc,M,KACjB,cAAS,G,aAAmB,EAAE,qBAAe,O,EAGtC,iBAAR,W,MACC,aAAS,G,KACT,gB,KACC,iB,KACC,eAAI,EAAC,gB,aAEN,EAAE,aAAc,KAAC,gB,aACjB,EAAE,aAAc,KAAC,SAAY,SAAO,OAAS,gBAAiB,gB,KAC9D,eAAK,G,KAGN,e,KACC,gB,KACC,gBAAK,gB,aAEN,EAAE,qBAAe,oB,aACjB,EAAE,qBAAe,aAAoB,SAAO,OAAQ,eAAiB,gB,KACrE,cAAK,I,EAIP,6B,KACC,eAAK,K,KACL,cAAK,K,KACL,U,EAGD,6B,KACC,yBAAa,M,MACb,aAAS,G,EACT,aAAG,qB,EACH,aAAG,qBAEL,EA1IA,G,EAAa,O,IA4Ib,E,SACC,IAAoB,G,UAAA,E,UAAqB,E,KAAkC,e,EAD/D,kB,IAIb,c,SACC,I,cACC,cAAM,WAAiB,UAAoB,K,SAFL,KAIxC,EAJA,I,EAAa,qB,IAMb,c,SACC,I,cACC,cAAM,WAAiB,UAAoB,K,SAFL,KAIxC,EAJA,I,EAAa,qB,IAMb,c,SACC,K,YAAa,I,IAAA,K,OACZ,cAAM,WAAgB,GAAT,EAAa,GAAI,GAAO,EAAW,UAAoB,K,SAF/B,KAIvC,EAJA,I,EAAa,oB,IAMb,c,SACC,I,cACC,cAAM,QAAc,UAAoB,K,SAFN,KAIpC,EAJA,I,EAAa,iB,IAYb,EANA,c,SACC,I,cACC,cAAM,SAAe,UAAoB,K,SAFN,KAIrC,EAJA,I,EAAa,kB,SAMb,GACC,qB,CADW,qD,CA/KA,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,a,SAYC,IAAa,EAA+D,G,QAAA,mBAA8B,iB,KATlG,a,KAEA,Y,KACA,iB,KACA,iB,KACA,gBAKP,EAAI,M,UAAqB,yDAAgB,G,KACzC,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,IAC9E,EAAI,E,OACF,mBAAK,qBAA0B,wBAAsB,uB,OACrD,mBAAK,qBAA0B,yB,UACjC,IAAI,EAAK,KAAG,EAAI,EAAc,EAAyB,EAAb,G,KAC1C,SAAI,KAAC,QAAW,GAAI,U,KACpB,SAAI,KAAC,QAAW,GAAI,oB,OAGrB,8B,MACC,aAAS,G,QACT,U,UAAoB,sG,KACpB,UAAK,E,KACL,S,KACA,YAAK,K,KACL,WAAK,E,WAEL,O,EACA,eAAG,SAAU,KAAK,WAGnB,oCAAc,G,MACb,aAAS,G,KACT,SAAI,E,KACJ,SAAI,E,KACJ,Y,KACC,Q,YACA,KAAG,SAAU,KAAK,YAIpB,4BAAM,EAAoB,G,GACzB,KAAI,a,KACH,Q,KACA,YAAI,I,KACE,eAAS,EAAc,OAAG,KAAS,KAAM,cAAa,Q,KAC3D,cAAK,SAAgB,KAAO,KAAC,aAAc,S,KAC5C,Q,IAGD,EAAI,UAAU,c,UACd,cAAU,MAAc,KAAI,gB,KAC5B,gBAAK,EAAc,O,UACnB,kBAAU,qB,QAEV,EAAI,UAAY,a,EAChB,KAAK,cAAa,MAAa,EAAS,OAAI,IAAQ,I,EACnD,QAAe,E,KAChB,eAAK,EAAa,O,UAClB,iBAAU,qBAGH,kBAAR,W,MACC,aAAS,GACA,G,KAAT,iB,KAEA,YAAK,O,UACL,UAAK,OAAU,EAAI,W,KAEnB,eAAK,E,KACL,cAAK,E,UACL,kBAAU,G,UACV,iBAAU,G,KACV,cAGD,2B,MACC,aAAS,G,SACT,U,UAAqB,mG,KACrB,eAAS,QAAc,cAAa,I,KAAmB,Q,KACvD,Y,KACA,YAAK,K,KACL,WAAK,E,UAEL,EAAE,QAGH,gDAAkB,WAElB,+B,UACC,WAEF,EAhGA,G,EAAa,iB,CADD,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IA2dZ,EA1dA,a,SAqBC,MAAwC,QAA+D,c,KAhB/F,gB,KAIA,oB,UAGA,C,UACP,EAAG,EAAG,E,UACN,EAAG,EAAG,E,UACN,EAAG,EAAG,E,UACN,EAAG,EAAG,G,KAEC,sBAAc,EAAI,EAAG,G,KACrB,YAAK,MAAO,S,KAGnB,S,KACA,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,KAC9E,aAAK,E,KACL,WAAK,EAAM,YAAO,QAAY,EAAO,Q,KACrC,cAAK,EAAgB,SAAe,sBAAO,cAA0B,EAAC,OAAW,mBAAO,c,KACxF,YAAK,EAAO,eAAO,aAAe,G,KAClC,aAAK,SAAe,WAAM,KAAC,S,KAC3B,WAAK,EAAM,cAAO,c,KAClB,iBAAK,MAAgB,iBAAO,aAAiB,G,KAC7C,sBAAK,MAAqB,sBAAO,c,OAGlC,6B,YACC,S,KACA,eAAK,eAGN,oCAAc,EAAoB,EAA4B,QAA5B,mBAA4B,mBAAqB,c,KAClF,eAAK,c,KACL,iBAAK,mBAAiB,E,KACtB,iBAAK,kBAAsB,EAAY,EAAY,IAGpD,yCAAkB,EAAoB,2BAA4B,gB,KACjE,eAAK,a,KACL,sBAAK,mBAAsB,E,KAC3B,sBAAK,iBAA2B,EAAW,IAG5C,mCAAa,MAAwC,EAAe,QAAkB,I,IAAA,Q,KACrF,eAAK,cACL,O,WAAoB,O,MACpB,KAAI,K,EACJ,E,OACA,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,KAED,aAAK,EAAQ,EAAK,KAAO,iBAG1B,qCAAe,MAAwC,EAAe,EAAE,IAAyB,EAAW,QAA0B,I,IAAA,Q,KACrI,eAAK,cACL,O,WAAoB,O,MACpB,KAAI,K,EACJ,E,OACA,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,KAED,aAAK,EAAQ,EAAK,KAAO,iBAG1B,0CAAoB,MAAwC,EAAe,EAAgB,EAAgB,EAAgB,EAAe,QAAE,I,IAAA,aAAqB,c,KAChK,eAAK,cACL,O,WAAoB,O,MACpB,KAAI,KAGJ,EAAI,IACJ,EAAI,I,GACJ,E,GACA,E,EACA,EAAI,E,EACJ,EAAO,E,EAGP,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,EAEA,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,EACA,E,GAGA,G,EAAI,C,QACH,UAAU,U,IACV,UAAU,U,OAQV,EAAE,EAAM,K,IANR,EAAE,EAAM,I,IAGR,EAAE,EAAM,I,OAIR,EAAE,EAAM,K,IANR,EAAE,EAAM,I,IAGR,EAAE,EAAM,S,EAQR,E,EACA,E,EAEA,E,EACA,E,EAEA,E,EACA,E,EAEA,E,EACA,E,GAGD,E,GACA,E,GACA,E,GACA,E,GACA,E,GACA,E,GACA,E,GACA,E,MAEA,E,OACA,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,E,OACA,E,KACA,e,OACC,E,OACA,E,OACA,E,OACA,G,KAED,aAAK,EAAQ,EAAK,KAAO,iBAG1B,oCAAY,IAAgD,EAAe,EAAgB,QAAE,I,IAAA,aAAqB,c,KACjH,eAAK,cACL,O,WAAoB,O,MACpB,KAAI,K,EACJ,E,OACA,E,OACA,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,G,KACN,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,E,OACA,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,G,OACN,EAAM,G,KACN,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,EAAI,E,OACJ,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,G,OACN,EAAM,E,KACN,e,OACC,E,OACA,E,OACA,E,OACA,G,OAED,E,OACA,EAAI,E,OACJ,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,OACN,EAAM,E,KACN,e,OACC,E,OACA,E,OACA,E,OACA,G,KAED,aAAK,EAAQ,QAAgB,EAAO,KAAO,iBAG5C,gCAAe,EAAW,EAAwB,QAAE,I,IAAA,aAAqB,I,IAAA,Q,KACxE,eAAK,a,YACL,KAAK,IAAM,EAAC,EAAM,IAGnB,kCAAU,IAA0B,EAAW,EAAY,EAAY,EAAwB,EAAqB,QAAnB,I,IAAA,aAAqB,I,IAAA,aAAsB,I,IAAA,Q,KAC3I,eAAK,a,YACL,SAAK,EAAO,EAAQ,EAAC,EAAM,EAAG,EAAK,EAAI,EAAM,EAAM,IAGpD,8BAAM,IAA0B,EAAW,EAAY,EAAY,EAAY,EAAY,EAAwB,EAAqB,EAAsB,QAAzC,I,IAAA,aAAqB,I,IAAA,aAAsB,I,IAAA,aAAsB,I,IAAA,Q,KACrL,eAAK,a,YACL,KAAK,EAAO,EAAI,EAAC,EAAM,EAAG,EAAK,EAAI,EAAI,EAAI,EAAM,EAAM,EAAO,IAG/D,8BAAM,IAAqC,EAAe,QAAkB,I,IAAA,Q,KAC3E,eAAK,a,YACL,KAAK,EAAO,EAAI,EAAC,EAAS,EAAK,IAGhC,kCAAU,EAAe,EAAY,EAAY,EAAwB,QAAiB,I,IAAA,Q,KACzF,eAAK,a,YACL,SAAK,EAAO,EAAS,IAAQ,EAAI,EAAM,IAGxC,+BAAS,EAAkC,EAAgB,QAAiB,I,IAAA,Q,KAC3E,eAAK,a,YACL,QAAK,EAAe,IAAiB,IAGtC,gCAAQ,IAAqC,EAAgB,QAAE,I,IAAA,aAAqB,I,IAAA,K,KACnF,eAAK,a,YACL,OAAK,EAAO,EAAM,EAAC,EAAS,EAAK,IAGlC,iCAAmB,EAAY,EAAa,EAAa,EAAa,EAAW,EAA0B,QAAkB,I,IAAA,Q,KAC5H,eAAK,a,YACL,MAAK,IAAO,EAAM,EAAM,EAAK,EAAK,EAAE,EAAK,EAAW,IAGrD,2B,KACC,iBAAS,a,aAAiC,M,KACrC,iBAAS,a,YAAgC,M,KAC9C,eAAK,MAGN,+B,MACC,KAAI,O,EACJ,c,EACA,e,KACA,OAAI,GAAO,EAAS,QAAK,I,QACxB,E,EACA,U,KAED,WAAI,SAAS,EAAG,IAAU,MAAK,EAAO,QAEtC,IAAI,EAAU,c,GAEP,IAAI,EAAU,O,YACpB,YAAK,EAAO,Q,GACN,IAAI,EAAU,IAAK,C,MACzB,EAAI,MAAW,EAAiB,S,EAChC,KAAI,OAAW,cAAe,EAAe,YAAY,e,EACzD,EAAkB,EAClB,EAAkB,EACK,EAAgB,EAAY,EAAiB,E,YACpE,cAAY,EAAa,E,YACzB,eAAY,EAAiB,E,YAE9B,UAGO,2BAAR,Y,KACC,iBAAS,I,KACT,M,aACY,kB,KACX,cAAI,O,KACJ,cAAI,eAAe,oBAAe,KAAO,sBAAwB,Q,KACjE,cAAI,YAAC,YAAc,G,aACnB,MAAI,KAAC,e,KACL,eAAK,c,aACa,iB,KAClB,oB,KACA,4BAAkB,oBAAe,KAAO,sBAAwB,Q,YAChE,WAAK,c,KACL,eAAK,a,KAEL,eAAK,6BAIP,+B,KACC,kB,KACA,cAAK,U,YACL,U,KACA,aAAK,U,KACL,sBAAK,WAEP,EAxdA,G,EAAa,gB,SA0db,GACC,yBACA,uBACA,iB,CAHW,mC,CA3dA,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,a,SAwBC,IAAa,EAAuE,G,KAAA,e,KAA8B,iB,QAf1G,K,QAEA,K,KAEA,a,KACA,wBAA2B,G,KAC3B,wBAA2B,G,KAC3B,wBAA2B,I,KASlC,SAAI,E,KACJ,SAAI,E,KACJ,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,KAC9E,sBAAa,M,KACb,U,SAXM,qBAAP,uBAAuB,S,EAChB,0BAAP,uBAA4B,c,EACrB,4BAAP,uBAA8B,gB,EACvB,gCAAP,uBAAkC,U,EAC3B,4BAAP,uBAA8B,U,EAUtB,kBAAR,W,MACC,aAAS,G,iBAER,cAAc,EAAC,cAAiB,mB,aAChC,cAAc,EAAC,gBAAiB,qB,aAChC,KAAK,eAAe,aAAc,I,oBAElC,UACA,I,EAIM,wBAAR,c,MACC,aAAS,G,EACT,EAAI,aAAY,G,KAChB,aAAG,K,EACH,cAAG,I,EACH,mBAAQ,IAAkB,gBAAY,C,MACrC,4BAAY,mBAAiC,G,KAC7C,iB,EACA,gB,gBAAyB,G,OAE1B,G,EAGO,yBAAR,c,MACC,aAAS,G,EACT,EAAI,gB,KACJ,aAAG,K,EACH,aAAG,K,EACH,YAAG,I,EAEH,oBAAQ,IAAoB,aAAY,C,MACvC,oCAAY,oBAAyC,G,KACrD,cAAE,I,EACF,gB,gBAAyB,G,OAE1B,G,EAGD,6B,KACC,W,EAGM,eAAP,W,KACC,WAAI,WAAW,KAAC,U,EAGV,iBAAP,W,KACC,WAAI,WAAW,O,EAGT,sBAAP,WAAoB,G,KACnB,WAAI,UAAS,KAAG,mBAAe,O,EAGzB,sBAAP,WAAoB,G,KACnB,WAAI,UAAS,KAAG,mBAAe,O,EAGzB,uBAAP,WAAqB,EAAe,G,KACnC,WAAI,UAAS,KAAG,mBAAe,KAAmB,I,EAG5C,uBAAP,WAAqB,EAAe,EAAe,G,KAClD,WAAI,UAAS,KAAG,mBAAe,KAAmB,EAAU,I,EAGtD,uBAAP,WAAqB,EAAe,EAAe,EAAgB,G,KAClE,WAAI,UAAS,KAAG,mBAAe,KAAmB,EAAU,EAAO,I,EAG7D,yBAAP,WAAuB,G,MACtB,aAAS,G,YACT,IAAI,G,EACJ,iBAAG,wBAAsB,MAAmB,KAAU,S,EAGhD,yBAAP,WAAuB,G,MACtB,aAAS,G,YACT,IAAI,G,EACJ,iBAAG,wBAAsB,MAAmB,KAAU,S,EAGhD,yBAAP,WAAuB,G,MACtB,aAAS,G,YACT,IAAI,G,EACJ,iBAAG,wBAAsB,MAAmB,KAAU,S,EAGhD,6BAAP,Y,MACC,aAAS,G,EACT,EAAI,mBAAc,aAAmB,G,IACrC,IAAK,kB,UAAiC,4CAAgB,G,OACtD,G,EAGM,+BAAP,Y,MACC,aAAS,G,EACT,EAAI,kBAAc,aAAkB,G,IAChC,G,IAAA,EAAQ,gB,UAA+B,8CAAgB,G,OAC3D,G,EAGM,kBAAP,W,KACC,yBAAa,M,MAEb,aAAS,G,KACT,K,EACC,kBAAG,I,QACH,M,KAGD,K,EACC,kBAAG,I,QACH,M,KAGD,U,EACC,cAAE,KAAC,S,aACH,O,EAIY,mBAAd,Y,WAgCC,IA/BA,4BAAS,WACe,6BAAS,QACf,6BAAY,YACL,2BAAS,aACX,sHAAU,QAKnB,8BAAY,YACD,8BAAS,aACT,QAAU,SAAY,uBAI/C,oX,EAmBa,sBAAd,Y,WAsCC,IArCA,4BAAS,WACe,6BAAS,QACf,6BAAY,SACZ,6BAAa,YACN,2BAAS,aACX,oJAAU,QAMnB,yBAAY,SACb,8BAAa,YACD,8BAAS,aACT,QAAU,SAAY,uBAI/C,gkB,EAsBa,WAAd,Y,WA2BC,IA1BA,4BAAS,WACe,6BAAS,QACf,2BAAY,aACP,mFAAU,QAInB,8BAAY,aACD,QAAU,SAAY,uBAI/C,uQ,EApPa,yB,EACA,sB,EACA,gB,EACA,kB,EACA,wB,EACA,oBA+Pf,EArQA,G,EAAa,S,CADD,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IAqTZ,EApTA,a,SAYC,IAAa,G,QAA+D,iB,KAVpE,a,KAEA,YAAS,O,KACT,YAAK,MAAO,S,KAEZ,c,SACA,MAAG,QAKV,EAAI,M,UAAqB,yDAAgB,G,KACzC,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,UAC9E,IAAI,EAAK,KAAG,EAAI,KAAK,EAAO,mBAAO,MAAoB,gBAAM,EAAmB,G,KAChF,SAAI,KAAC,QAAW,GAAI,U,KACpB,SAAI,KAAC,QAAW,GAAI,oB,OAGrB,8B,QACC,U,UAAoB,uD,KACpB,S,KACA,YAAK,E,KACL,WAAK,E,MAEL,aAAS,G,WACT,O,EACA,eAAG,SAAU,KAAK,WAGnB,oCAAc,G,MACb,aAAS,G,KACT,SAAI,E,KACJ,SAAI,E,KACJ,Y,KACC,Q,YACA,KAAG,SAAU,KAAK,YAIpB,iC,WACC,aAAW,IAGZ,wCAAc,G,WACb,MAAK,IAAM,IAGZ,uCAA6B,I,IAAA,Q,WAC5B,EAAK,MAAM,GACX,O,WAAoB,O,YACpB,IAAK,IAGN,gCAAe,EAAW,QAA0B,I,IAAA,Q,WACnD,EAAK,KAAM,GACX,KAAI,KAAQ,cACZ,iBACA,O,WAAoB,O,YACpB,IAAK,G,YACL,EAAI,EAAC,IAGN,kCAAU,IAA0B,EAAW,EAAY,EAAY,EAAwB,EAAqB,QAAnB,I,IAAA,aAAqB,I,IAAA,aAAsB,I,IAAA,Q,WAC3I,EAAK,EAAa,OAAE,EAAiB,KAAE,GACvC,KAAI,KAAQ,cACZ,iBACA,O,WAAoB,OACpB,O,WAAqB,OACrB,O,WAAqB,O,iBAEpB,K,YACA,IAAK,G,YACL,IAAK,K,cAEL,K,YACA,IAAK,G,YAEL,IAAK,G,YACL,IAAK,G,YAEL,IAAK,G,cACL,OAIF,8BAAM,IAA0B,EAAW,EAAY,EAAY,EAAY,EAAY,EAAwB,EAAqB,EAAsB,QAAzC,I,IAAA,aAAqB,I,IAAA,aAAsB,I,IAAA,aAAsB,I,IAAA,Q,WACrL,EAAK,EAAa,OAAE,EAAiB,KAAE,GACvC,KAAI,KAAQ,cACZ,iBACA,O,WAAoB,OACpB,O,WAAqB,OACrB,O,WAAqB,OACrB,O,WAAqB,O,iBAEpB,K,YAA0B,IAAK,G,YAAwB,IAAK,G,YAC5D,IAAK,G,YAAwB,IAAK,G,cAAwB,O,cAE1D,K,YAA0B,IAAK,G,YAC/B,IAAK,G,YAAwB,IAAK,G,YAClC,IAAK,G,YAAwB,IAAK,G,YAClC,IAAK,G,cAAwB,OAI/B,8BAAM,IAAqC,EAAe,QAAkB,I,IAAA,Q,UAC3E,EAAK,EAAI,EAAC,EAAM,EAAM,EAAG,EAAG,EAAQ,EAAG,EAAU,EAAC,EAAG,EAAW,EAAI,EAAQ,EAAO,IAGpF,kCAAU,EAAe,EAAY,EAAY,EAAwB,QAAiB,I,IAAA,Q,WACzF,EAAK,EAAa,OAAE,EAAiB,KAAE,GACvC,O,WAAoB,O,MACpB,SAAK,IAAG,EAAK,EAAI,EAAM,G,EACvB,Y,GACA,G,QACA,I,IACA,IACA,G,cAYC,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cAEd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,K,cAjBd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cAEd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,G,cAEd,EAAK,EAAM,EAAG,G,cACd,EAAK,EAAM,EAAG,KAYhB,8B,YACC,EAAK,EAAM,EAAO,EAAG,EAAO,EAAG,G,YAC/B,EAAK,EAAM,EAAO,EAAG,EAAO,EAAG,IAGhC,+BAAS,EAAkC,EAAgB,G,QAAiB,I,IAAA,Q,EAC3E,E,UAAe,kD,WACf,EAAK,KAAgB,EAAV,GACX,O,WAAoB,OACpB,KAAI,KAAQ,cACZ,iB,IAGA,E,UAEA,E,IAHA,G,EAIA,EAAa,K,EACb,EAAQ,E,EAER,EAAS,EAAI,EAAS,EAAG,EAAM,EAAG,EAAK,GAAM,EAAC,C,MAC7C,EAAS,G,EACT,EAAS,K,EAET,E,EACA,E,KAEA,G,EACC,E,EACA,I,EAEA,EAAE,EAAG,G,EACL,EAAE,EAAG,I,YAGN,IAAK,G,YACL,IAAK,KAIP,gCAAQ,IAAqC,EAAgB,G,QAAE,I,IAAA,aAAqB,I,IAAA,KAC/E,I,WAAgB,MAAQ,EAAG,EAAQ,UAAS,QAAU,I,GACtD,E,UAAe,+BACnB,O,WAAoB,O,MACpB,EAAI,EAAK,UAAO,K,EAChB,SAAO,G,EACP,SAAO,G,EACP,EAAI,EAAK,E,GACT,EAWO,C,WACN,EAAK,OAAgB,EAAV,EAAkB,G,UAE7B,IAAK,EAAS,IAAM,C,gBACnB,G,cACA,IAAK,K,MACL,E,MACA,EAAE,E,IACF,EAAE,EAAM,E,cACR,IAAK,K,cAGN,K,cACA,EAAK,IAAQ,OAxBd,C,WACC,EAAK,KAAgB,EAAV,EAAgB,G,UAC3B,IAAK,EAAS,IAAM,C,cACnB,IAAK,K,MACL,E,MACA,EAAE,E,IACF,EAAE,EAAM,E,cACR,IAAK,K,cAGN,EAAK,IAAQ,G,EAkBd,E,EACA,E,YACA,EAAI,EAAC,EAAO,EAAI,IAGjB,iCAAmB,EAAY,EAAa,EAAa,EAAa,EAAW,EAA0B,QAAkB,I,IAAA,Q,WAC5H,EAAK,KAAoB,EAAd,EAAgB,GAC3B,O,WAAoB,O,QAGpB,EAAI,IACJ,EAAI,EAAe,EACnB,EAAI,EAAe,EAAc,E,EAEjC,I,EACA,I,EACA,I,EACA,I,EAEA,EAAS,EAAL,EAAU,E,EACd,EAAS,EAAL,EAAU,E,EAED,GAAb,EAAI,GAAY,EAAO,E,EACV,GAAb,EAAI,GAAY,EAAO,E,EAEvB,E,EACA,E,GAEA,EAAI,GAAO,EAAM,EAAM,EAAO,EAAQ,E,GACtC,EAAI,GAAO,EAAM,EAAM,EAAO,EAAQ,E,EAEtC,EAAI,EAAO,EAAQ,E,EACnB,EAAI,EAAO,EAAQ,E,EAEnB,EAAI,E,EACJ,EAAI,EAEJ,KAAO,G,YACN,IAAK,G,GACL,E,GACA,E,GACA,E,GACA,E,GACA,E,GACA,E,YACA,IAAK,G,YAEN,EAAI,EAAC,G,YACL,EAAI,EAAC,IAGE,mBAAR,gB,MACC,iB,EACA,KAAI,KAAQ,c,OACZ,E,OACA,E,OACA,EAAY,E,OACZ,EAAY,E,OACZ,EAAY,E,OACZ,EAAY,E,KACZ,YAAK,GAGN,2B,SACC,U,UAAqB,mD,KACrB,Q,KACA,WAAI,QAAQ,KAAI,QAAQ,GAAI,O,KAC5B,WAAK,GAGE,kBAAR,WACU,G,KAAT,c,UACA,kBAAU,kB,UACV,UAAK,OAAU,KAAK,W,KACpB,YAAK,IAGE,kBAAR,WAAc,G,SACb,U,UAAqB,mD,QACrB,WAAS,EAAS,C,eACjB,cAAc,UAAW,cAAe,GACnC,O,KADgE,a,KAGrE,Q,KACA,aAIF,+B,UACC,WAEF,EAlTA,G,EAAa,gB,SAoTb,G,EACC,mB,EACA,iB,EACA,qB,CAHW,iC,CArTA,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,a,SA2BC,K,KA1BA,oBAAa,MAAO,S,KACpB,sBAAe,MAAO,S,KACtB,0BAAmB,MAAO,U,KAC1B,wBAAiB,MAAO,QAAM,I,KAC9B,iBAAS,OAAO,cAAQ,U,KACxB,gBAAS,MAAO,OAAK,G,KACrB,gBAAS,MAAO,U,KAChB,a,KACA,yB,KACA,qB,KACA,gB,KACA,qB,KACA,a,KACA,kB,KACA,gB,KACA,sB,KACA,Q,KACA,Y,KAGQ,aAAM,e,UACN,U,KACA,iBAAW,cAAM,M,KAKxB,qBAAsB,+BAAY,EAA4B,IAAE,EAAQ,6BAAM,G,OAG/E,8BAA6B,QAAoB,gB,IAChD,EAAI,EAAS,EACb,EAAI,EAAS,E,EACb,aAAS,G,EACT,KAAI,mBAAe,MAAkB,EAAG,U,EACxC,aAAO,IAAa,qB,MAEpB,EAAS,M,QACT,UAAQ,C,EACP,cAAM,e,UACN,IAAK,EAAK,OAAO,EAAG,EAAM,K,QACzB,G,QACA,EAAI,QAAgB,OAAa,OAAQ,IACzC,M,EAAA,O,SACA,EAAK,KAAG,OAAY,EAAK,EAAK,S,IAC9B,EAAK,KAAG,OAAY,EAAK,EAAK,S,YAC9B,IAAgB,EAAI,OAAE,EAAiB,EAAM,OAAE,EAAS,EAAG,KAAK,UAAY,KAAM,Q,KAEnF,gB,IAAyB,IAAS,OAAW,O,QAG9C,sBAAS,C,EACR,cAAM,qB,MAEN,K,EADA,EAAI,OACM,OAAO,EAAG,EAAM,K,WACzB,IACI,2BACA,EAAU,iBAAY,C,MACzB,E,OACA,S,EACA,qBAAiB,SAAqB,K,SACtC,KAAY,KAAa,KAAa,I,SACtC,KAAY,KAAa,KAAa,I,SACtC,KAAY,KAAa,KAAa,I,SACtC,KAAY,KAAa,KAAa,M,QAKzC,cAAS,uB,MAER,K,EADA,EAAI,OACM,OAAO,EAAG,EAAM,K,QACzB,I,KACA,O,MACA,EAAI,2BACE,EAAU,e,OAChB,E,EACA,c,EACA,qBAAK,0BAAmC,O,MACxC,Y,EACA,EAAI,W,QACJ,kBAAS,C,gBACR,mB,cACA,EAAW,OAAQ,EAAG,KAAU,G,MAC/B,E,EAAA,GAAI,EAAwB,EAAnB,EAAU,EAAG,GAAQ,EAA0B,EAAvB,EAAY,EAAK,G,cAClD,EAAO,KAAc,EAAE,GAAQ,EAAM,GAAQ,EAAQ,EACpD,GAAQ,EAAM,GAAQ,EAAQ,EAC9B,K,QAIH,cAAI,EAAK,EAAY,C,gBACpB,qB,WACU,GAAV,OACY,KAAS,EAAa,EAAY,G,UAC9C,EAAW,EAAM,EAAK,M,SACrB,EAAQ,EAAQ,G,WAChB,K,EACA,E,EACA,K,QAMJ,kBAAS,C,MACR,Y,SACA,GAAO,G,EACP,cAAM,W,QACN,IAAW,KAAM,EAAE,KAAW,EAAE,WAAa,EAAO,a,MACpD,EAAI,S,EACJ,EAAI,c,MACJ,IAAK,EAAS,OAAM,IAAS,K,MAC5B,EAAI,G,WACJ,KAAO,O,UACP,EAAM,EAAC,EAAQ,S,QAIjB,U,MAEC,K,EADA,EAAI,OACM,OAAO,EAAG,EAAM,K,QACzB,I,KACA,O,MACA,EAAI,2BACE,EAAU,e,OAChB,E,OACA,oB,KACA,KAAI,EAAQ,MAAK,aAAO,KAAM,W,EAC9B,qBAAK,QAAqB,EAAI,G,WAC9B,U,IACA,KAAM,EAAG,GAAO,EAAK,EAAG,EAAK,E,YAC7B,C,WACC,G,WACA,EAAI,EAAM,GAAK,EAAK,EAAM,EAAM,GAAI,EAAM,EAAM,EAAK,G,MACrD,G,MACA,G,YACA,IAAO,EAAQ,EAAI,EAAK,EAAE,I,WAC1B,EAAgB,Y,WAChB,K,WACA,K,GAED,E,QACA,IAAK,GAAS,EAAG,C,OAChB,EAAI,EAAM,EAAM,GAAK,EAAM,EAAM,EAAK,GAAI,EAAM,EAAM,EAAK,G,MAC3D,G,MACA,G,WACA,G,YACA,IAAO,EAAQ,EAAI,EAAK,EAAE,I,WAC1B,EAAgB,Y,WAChB,K,WACA,K,EACA,E,EACA,I,QAKH,UAAQ,C,EACP,cAAM,iB,MACN,IAAK,EAAK,OAAO,EAAG,EAAM,K,IACzB,G,GACA,EAAI,QAAgB,OAAa,OAAQ,G,UACzC,IAAc,EAAI,OAAE,EAAiB,EAAM,OAAE,EAAS,KAAO,MAAO,EAAkB,U,QAIxF,aAAS,C,MACR,EAAI,M,EACJ,cAAM,W,MACN,IAAK,EAAK,OAAO,EAAG,EAAM,K,gBACzB,I,KACA,O,MACA,EAAI,2BACE,EAAU,mB,OAChB,E,IACA,oB,OACA,KAAI,EAAQ,MAAK,aAAO,KAAM,U,EAC9B,qBAAK,QAAqB,EAAI,G,UAC9B,IAAK,EAAK,OAAM,EAAI,EAAM,GAAQ,EAAC,C,IAClC,G,MACA,G,OACA,GAAM,EAAG,Q,OACT,GAAM,EAAG,Q,WACT,UAMJ,iCAvKe,mBAAa,MAAI,QAAM,IAAM,IAAK,IAAM,IAAK,GAC7C,cAAQ,MAAI,MAAM,GAwKlC,EAjMA,G,EAAa,wB,CADD,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,E,SACC,EAAmB,EAAoC,G,KAApC,W,KAAoC,c,KAA4B,aAGpF,a,SAiBC,IAAa,QAAuC,c,KAdpD,sB,KACA,kB,KACQ,gBAAS,M,KACT,iBAAU,M,KAEV,a,KACA,gB,KACA,iBAAyB,KAAI,K,KAC7B,cAAO,iB,UACP,MAAI,Q,KACJ,YAAK,Q,KACL,YAAK,M,KACL,YAAK,M,KAGZ,aAAK,EACL,I,KACC,YAAI,G,KACL,SAAI,EAAC,MAAW,cAAyB,KAAnB,iB,OAGvB,4BAAM,EAAyB,EAAoB,2BAA6B,c,MAC/E,KAAI,QACJ,EAAI,wBACJ,EAAI,kBACJ,EAAI,K,EAEJ,KAAI,K,EACJ,KAAI,MACJ,EAAI,W,EACJ,KAAI,MAEJ,EAAI,gB,EACJ,KACA,EAAI,KACJ,EAAI,EAAS,UACb,EAAI,KACJ,EAAI,EAAa,MACjB,EAAI,EAAa,K,GACjB,GACI,GAAJ,I,GAA0B,G,UAC1B,IAAK,EAAY,OAAG,EAAU,MAAQ,C,IACrC,EAAI,eAA4B,I,EAChC,EAAI,G,UACJ,O,GAKA,GAAI,MAAuB,e,GAC1B,G,GAQD,GAAI,MAAqB,e,GACxB,G,MAGD,EAAI,gB,EACJ,K,gBACI,EAAU,iBAAY,C,MACzB,E,EACA,uB,EACA,c,EACA,aAAuB,E,EACvB,qBAAO,SAAyB,SAAO,K,EACvC,EAAS,e,IACT,I,IACA,oBAAiD,Q,EACjD,Y,mBACU,EAAU,gB,iBAaV,EAAU,mBAAY,C,MAChC,E,YACA,KACA,S,EAEA,mBACA,S,MAlBA,E,EACA,uB,EACA,cAAW,qBAAoB,E,EAC/B,YAAW,YAAY,E,EACvB,UAAI,EAAW,SAAY,S,EAC1B,uBAAW,EAAW,MAAK,cAAgB,EAAO,Y,EAEnD,qBAAK,0BAAmC,WAAqB,K,IAC7D,U,IACA,oBAA+C,Q,IAC/C,I,EACA,Q,GAUD,M,EAAI,C,MACH,Q,EACA,KAAI,U,IACJ,EAAW,EAAI,IAAc,EAAe,E,IAC5C,EAAW,EAAI,IAAc,EAAe,E,IAC5C,EAAW,EAAI,IAAc,EAAe,E,IAC5C,EAAW,EAAI,IAAc,EAAe,EAC5C,I,KACC,I,KACA,I,KACA,K,MAED,gBACI,M,EAAJ,U,UACC,MAEA,G,MACC,YAAS,EAAU,E,MACnB,YAAS,EAAU,E,MACnB,YAAS,EAAU,G,eAEnB,a,IAED,EAAc,K,MAGf,EAAI,e,MACJ,I,EACC,E,eACA,0BAAqB,qBAAwB,KAAgC,0BAAqB,wB,EAGnG,aAAI,C,EACH,gBAAQ,SAAc,EAAW,UAAU,EAAW,EAAW,SAAW,EAAU,EAAa,G,MACnG,IAAI,eAAsB,iB,EAC1B,EAAI,iB,GACA,M,KAAJ,aAAS,C,WACR,a,EACA,E,oBAoBC,EAAU,OAAO,EAAG,O,MACnB,G,QACA,G,aACA,OAAU,EAAI,EAAO,GAAK,EAAE,EAAO,I,QACnC,G,QACA,G,aACA,OAAS,EAAI,EAAO,IAAK,EAAO,EAAE,K,YAClC,MAAa,G,OACb,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,UACA,E,UACA,O,cArCD,EAAU,OAAO,EAAG,O,MACnB,G,QACA,G,aACA,OAAU,EAAI,EAAO,GAAK,EAAE,EAAO,I,QACnC,G,QACA,G,YACA,G,YACA,MAAa,G,OACb,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,OA0BH,IAAa,OACP,C,EACN,W,GACI,M,KAAJ,aAAS,C,OACR,a,wBAoBC,EAAa,UAAU,EAAC,EAAG,KAAoB,GAAM,E,MACpD,G,QACA,G,MACA,G,QACA,G,eACA,G,eACA,G,YACA,MAAa,G,OACb,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,UACA,E,UACA,O,kBArCD,EAAa,UAAU,EAAC,EAAG,KAAoB,GAAM,E,MACpD,G,QACA,G,MACA,G,QACA,G,eACA,G,YACA,G,YACA,MAAa,G,OACb,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,E,SACA,O,wBAoCD,EAAa,UAAU,EAAC,EAAG,KAAoB,GAAM,E,OACpD,E,SACA,E,SACA,E,SACA,E,SACA,G,WACA,G,SACA,E,SACA,E,SACA,E,SACA,M,mBAnBD,EAAa,UAAU,EAAC,EAAG,KAAoB,GAAM,E,OACpD,E,SACA,E,SACA,E,SACA,E,SACA,G,WACA,G,QAiBH,SAAQ,SAAI,EAAW,EAA0B,W,OACjD,IAAO,I,EAIT,gBAAQ,Q,EAvMP,wB,EATA,mB,EAkNF,WAjQM,sBAAc,EAAI,EAAG,EAAG,GAmQhC,EApQA,G,EAAa,mB,CALD,kBAAK,KAAlB,CAAO,MAAK,KCAZ,SAAO,I,SAAM,G,IACZ,a,SAKC,cAAa,I,IAAA,UAAe,I,IAAA,UAAe,I,IAAA,K,OAJ3C,E,OACA,E,OACA,E,OAGC,E,OACA,E,OACA,E,SAGD,8B,gBACC,E,SACA,E,SACA,EACA,M,EAGD,8B,cACC,E,OACA,E,OACA,EACA,M,EAGD,0B,iBACC,E,UACA,E,UACA,EACA,M,EAGD,0B,iBACC,E,UACA,E,UACA,EACA,M,EAGD,4B,eACC,E,QACA,E,QACA,EACA,M,EAGD,+B,MACC,c,OACA,G,QACA,E,QACA,E,QACA,E,QACA,GAJc,M,EAQf,4B,YACC,SAAO,EAAK,EAAG,EAAC,KAAM,EAAM,IAAG,KAAM,EAAK,EAAC,EAAE,KAAM,EAAM,IAAG,KAAM,EAAK,EAAC,EAAE,KAAM,EAAM,M,EAGvF,+B,MACC,EAAI,O,YACJ,SAAO,EAAK,EAAI,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,KAAM,OAAG,EAC1F,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,KAAM,OAAG,EAC3E,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,O,EAGpE,8B,MACC,EAAI,O,EACJ,QAAO,EAAI,EAAI,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,M,YACjF,UAAO,EAAK,EAAK,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,MAAM,QAAK,EAAM,EAClG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,MAAM,QAAK,EAAM,EACnF,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,OAAI,EAAG,EAAS,KAAM,IAAO,MAAM,I,EAG3E,0B,YACC,MAAO,KAAM,EAAM,IAAG,KAAM,EAAM,K,EAGnC,4B,YACC,UAAO,EAAK,KAAK,EAAM,KAAG,EAAM,KAAG,EAAM,KAAG,EAAM,KAAG,I,EAGtD,+B,QACC,OAAK,E,IACL,OAAK,E,IACL,OAAK,E,YACL,OAAO,EAAK,EAAK,EAAI,EAAI,IAE3B,EAzFA,G,EAAa,U,CADD,kBAAK,KAAlB,CAAO,MAAK,KzDAZ,SAAO,I,SAAM,G,IACZ,a,SAKC,IAAY,QAAmG,0B,KAFvG,sBAGP,aAAmB,mBAAY,aAAoC,Y,KAClE,cAAiB,I,QAEjB,E,YACA,KAAI,GAAC,Q,OAIC,wBAAR,c,MAAA,K,QACC,EAAK,WAAoC,SAAC,IAAqB,EAAa,WAAW,QAAC,G,KACxF,S,EACA,iBAAO,oBAAiB,SAAkB,G,KAGxC,oB,EAIF,iBAAO,wBAAiB,SAAsB,G,UAC7C,IAAK,EAAK,YAAU,OAAK,IAAY,I,cACpC,iBAKH,sC,KACC,YAAK,SAGN,yC,MACC,KAAI,YAAa,W,GACjB,G,KAAgB,mBAAK,EAAW,IAElC,EAvCA,G,EAAa,+B,IAyCb,a,SAAA,K,OAWQ,qBAAP,Y,OACC,G,OACC,UAAK,cAAU,EAAe,oB,OAC9B,UAAK,gBAAU,EAAiB,I,OAChC,UAAK,S,OACL,UAAK,cAAU,EAAe,oB,cAC9B,UAAS,uBAAgB,KAIpB,uBAAP,WAA6B,G,YAAsB,cAClD,G,OACC,UAAK,O,OACL,UAAK,gBAAU,EAAiB,EAAoB,MAA8B,U,OAClF,UAAK,gBAAU,EAAiB,U,OAChC,UAAK,cAAU,EAAe,I,cAC9B,UAAS,uBAAgB,KA1BpB,SACA,QACA,gBACA,0BACA,gBACA,0BACA,gBACA,0BACA,gBAqBR,EA9BA,G,EAAa,0B,CA1CD,kBAAK,KAAlB,CAAO,MAAK,K,wC0DtBNC,EAAYC,aAAW,SAACC,GAAD,OACzBC,YAAa,CACTC,KAAM,CACFC,SAAU,GAEdC,MAAO,CACHC,OAAQ,EACRC,WAAY,UAEhBC,OAAQ,CACJC,UAAW,eACXC,WAAY,OACZC,WAAYV,EAAMW,YAAYC,OAAO,YAAa,CAC9CC,SAAUb,EAAMW,YAAYE,SAASC,YAG7CC,WAAY,CACRP,UAAW,kBAEfQ,OAAQ,CACJC,gBAAiBC,IAAI,WAUlB,SAASC,EAAWC,GAC/B,IAAMC,EAAUvB,IAD6B,EAEbwB,IAAMC,UAAS,GAFF,6BAQ7C,OACI,eAACC,EAAA,EAAD,CAAMC,UAAWJ,EAAQnB,KAAzB,UACI,cAACwB,EAAA,EAAD,CACIC,MAAOP,EAAMO,QAEjB,cAACC,EAAA,EAAD,UACI,wBAAQC,IAAKT,EAAMU,iBC3BnC,IA6BeC,EA7BG,SACdC,EACAC,GAEA,IAAMH,EAAYI,iBAA0B,MAuB5C,OArBAC,qBAAU,WACN,IAAMC,EAASN,EAAUO,QAEzB,GAAID,EAAQ,CACRA,EAAO/B,OAAS4B,EAAQ5B,OACxB+B,EAAOE,MAAQL,EAAQK,MAEvB,IAAMC,EAAUH,EAAOI,WAAWP,EAAQM,SAAW,MACrD,GAAIA,EAAS,CACT,IAAIE,EAAmB,EAMvB,OALe,SAATC,IACFV,EAAKO,GACLE,EAAmBE,OAAOC,uBAAsB,kBAAMF,KAE1DA,GACO,WACHC,OAAOE,qBAAqBJ,QAIzC,CAACT,IACGF,GCjBIgB,EAhCG,SACdR,EACAjC,GACE,IAAD,EAC2BkB,mBAA6B,MADxD,mBACMwB,EADN,KACcC,EADd,KAEKC,EAAWf,iBAAyB,MAyB1C,OAxBAC,qBAAU,YACU,uCAAG,4BAAAe,EAAA,sEACMC,UAAUC,aAAaC,aAAa,CACrD,OAAS,EACT,MAAS,CACLC,WAAY,OACZhB,MAAOA,EACPjC,OAAQA,KAND,OACT0C,EADS,OASfC,EAAUD,GATK,2CAAH,qDAWhBQ,KACD,IAEHpB,qBAAU,WACN,IAAMqB,EAAQP,EAASZ,QACnBU,GAAUS,IACVA,EAAMC,UAAYV,EAClBS,EAAMlB,MAAQA,EACdkB,EAAMnD,OAASA,EACfmD,EAAME,UAEX,CAACX,IACGE,GCwDX,SAASU,EAAUC,EAAKC,EAAGC,EAAGzE,EAAG0E,GAC7BH,EAAII,YACJJ,EAAIK,IAAIJ,EAAGC,EAAGzE,EAAG,EAAG,EAAI6E,KAAKC,IAC7BP,EAAIQ,UAAYL,EAChBH,EAAIS,OAkBR,SAASC,EAAQC,GACb,MAAO,CAACA,EAAKV,EAAGU,EAAKT,GAqBzB,SAASU,EAAT,IAA6ET,EAAOU,EAAOb,GAAM,IAAD,mBAA1Ec,EAA0E,KAAtEC,EAAsE,wBAA9CC,EAA8C,KAA1CC,EAA0C,KAC5FjB,EAAII,YACJJ,EAAIkB,OAAOJ,EAAKD,EAAOE,EAAKF,GAC5Bb,EAAImB,OAAOH,EAAKH,EAAOI,EAAKJ,GAC5Bb,EAAIoB,UAAY,EAChBpB,EAAIqB,YAAclB,EAClBH,EAAIsB,SAGR,IAAMpF,EAAYC,aAAW,SAACC,GAAD,OACzBC,YAAa,CACTC,KAAM,CACFC,SAAU,QAMf,SAASgF,IAAiB,IAAD,EACN5D,mBAAkB,MADZ,mBACrB6D,EADqB,KAChBC,EADgB,OAEY9D,mBAAmC,MAF/C,mBAErB+D,EAFqB,KAEPC,EAFO,OAGUhE,oBAAkB,GAH5B,mBAGrBiE,EAHqB,KAGRC,EAHQ,OAIclE,oBAAkB,GAJhC,mBAIrBmE,EAJqB,KAINC,EAJM,OAKkBpE,oBAAkB,GALpC,mBAKrBqE,EALqB,KAKJC,EALI,OAMEtE,mBAAkB,MANpB,mBAMrBuE,EANqB,KAMZC,GANY,QAOoBxE,mBAAwB,IAP5C,qBAOrByE,GAPqB,MAOHC,GAPG,SAQgB1E,mBAAoC,MARpD,qBAQrB2E,GARqB,MAQLC,GARK,SASY5E,qBATZ,qBASrB6E,GATqB,MASPC,GATO,SAiBU9E,mBAClC,CACI+E,MAAO,wBACPC,KAAM,2BACNC,SAAU,UACVC,iBAAkB,OAClBC,yBAZqB,CACzBC,IAAK,MAAOC,WAAY,cAAeC,SAAU,aACjDC,UAAW,aAAcC,QAAS,YAAaC,KAAM,OACrDC,KAAM,OAAQC,SAAU,kBAAmBC,aAAc,eACzDC,QAAS,iBAAkBC,YAAa,cAAenH,KAAM,QASzDuE,MAAO,KAxBa,qBAiBrB6C,GAjBqB,gBA4BM/F,mBAAe,OA5BrB,qBA4BrBgG,GA5BqB,MA4BVC,GA5BU,SA6BcjG,mBAAe,MA7B7B,qBA6BrBkG,GA7BqB,MA6BNC,GA7BM,SA8B8BnG,oBAAkB,GA9BhD,qBA8BrBoG,GA9BqB,MA8BEC,GA9BF,MAoCtBC,GAAY/E,EAJC,IACC,KAIdgF,GAAgB,GAChBC,GAAmB7F,iBAAyB,MAElDC,qBAAU,WACN,IAAM6F,EAAQD,GAAiB1F,QAC3B0F,GAAiB1F,UACjB2F,EAAMC,IAAM,iBAEjB,CAACF,GAAiB1F,UAErBF,qBAAU,WACF0F,GAAUxF,UACVwF,GAAUxF,QAAQ6F,aAAe,SAACC,GAC9BtC,GAAmB,OAG5B,CAACgC,GAAUxF,UAEdF,qBAAU,WAWNqD,GAAemC,IAVF,uCAAG,4BAAAzE,EAAA,sEACOkC,EAAIgD,mBAAmBP,GAAUxF,QAAS,CACzDgG,gBAAgB,IAFR,OACNC,EADM,OAMZZ,GAAiBY,GACjBd,GAAac,GACbV,IAAyB,GARb,2CAAH,oDAU2BW,KACzC,CAAC/C,EAAamC,KAEjB,IAAMa,GAAc,SAChBC,GAIA,IAAMnC,EAAQhB,EAAaoD,IAAIpB,GAAYhB,OAGrCqC,EAAc,IAAIC,EAAMC,sBAAsBvC,GAG9CwC,EAAe,IAAIF,EAAMG,aAAaJ,GAG5CG,EAAarE,MAAQ6C,GAAY7C,MACjC,IAAMuE,EAAeF,EAAaG,iBAAiB3D,EAAaoD,IAAIpB,GAAYf,OAC1E2C,EAAW,IAAIN,EAAMO,SAASH,GACpCE,EAASE,cAAc9B,GAAYd,UACnC,IAAM6C,EA/Kd,SAAkCH,GAC9BA,EAASI,iBACTJ,EAASK,uBACT,IAAMC,EAAS,IAAIZ,EAAMa,QACnBC,EAAO,IAAId,EAAMa,QAEvB,OADAP,EAASS,UAAUH,EAAQE,EAAM,IAC1B,CAAEF,OAAQA,EAAQE,KAAMA,GAyKZE,CAAyBV,GAGlCW,EAAqB,IAAIjB,EAAMkB,mBAAmBZ,EAAS3E,MAC3DwF,EAAiB,IAAInB,EAAMoB,eAAeH,GAIhD,OAHAE,EAAeE,aAAa,EAAG3C,GAAYb,kBAAkB,GAGtD,CAAEyC,SAAUA,EAAUgB,MAAOH,EAAgBV,OAAQA,EAAQZ,mBAAoBA,IAmGtF0B,GAAc,SAAdA,IACE7E,EAAa8E,oBACbzE,GAAiB,GAEjB0E,WAAWF,EAAa,MAyD1BG,GAAuB,QAEvBC,GAAqBxI,GAjJL,SAACQ,GAGnB,IAAMiI,EAAsB,SAACC,EAASC,EAAWC,EAAW7C,EAAeoB,GAEnE5B,GAAYZ,yBAAyBC,KAAO8D,EAAQlG,KAAKqG,OACzDH,EAAQ5G,EAAIgH,IACZJ,EAAQ3G,EAAIgH,KAEZJ,EAAUK,MAAQjD,GAAiB6C,EAAUI,MAAQjD,IACrD2C,EAAQO,SAAWP,EAAQQ,qBAvM3C,SAAkBC,EAAmCC,GACjD,IAAMtH,EAAIsH,EAAOtH,EAAIqH,EAAOrH,EACtBC,EAAIqH,EAAOrH,EAAIoH,EAAOpH,EAEtBsH,EAAKvH,EADDK,KAAKmH,KAAK,SAAAxH,EAAK,GAAL,SAASC,EAAK,IASlC,OAFQ,KAHJA,EAAI,EAAaI,KAAKoH,KAAKF,IAAO,IAAMlH,KAAKC,IAAqB,IAAMD,KAAKoH,KAAKF,IAAO,IAAMlH,KAAKC,KAgM5CoH,CAASb,EAAUc,SAAUb,EAAUa,WAEnF,CACAlE,GAAYZ,yBAAyBO,KAErCK,GAAYZ,yBAAyBM,MACvCyE,SAAShB,EAAQlG,KAAKqG,QAChBF,EAAUc,SAAS3H,EAAI8G,EAAUa,SAAS3H,EAC1C4G,EAAQO,UAAY,GAGpBP,EAAQO,UAAY,IAI5B9B,EAASK,yBAKjB,GAAI/D,GAAejD,aAAmBmJ,wBAA0B/D,IAAyBF,GAAe,CACpG,IAAMa,EAAOb,GAEblF,EAAQoJ,WAAW,GAAK,GAAK,GAAK,GAClCpJ,EAAQqJ,MAAMrJ,EAAQsJ,kBAGtB,IAAM3C,EAAWpD,EAAQoD,SAEzBhD,GAAe4F,QAGftB,EAAoBpE,GAAaa,KAAMqB,EAAKyD,UAAU/M,GAAiCsJ,EAAKyD,UAAU/M,GAAgC8I,GAAeoB,GACrJsB,EAAoBpE,GAAaU,UAAWwB,EAAKyD,UAAU/M,GAAgCsJ,EAAKyD,UAAU/M,GAAiC8I,GAAeoB,GAC1JsB,EAAoBpE,GAAaW,QAASuB,EAAKyD,UAAU/M,GAAiCsJ,EAAKyD,UAAU/M,GAAkC8I,GAAeoB,GAC1JsB,EAAoBpE,GAAaQ,WAAY0B,EAAKyD,UAAU/M,GAAiCsJ,EAAKyD,UAAU/M,GAAkC8I,GAAeoB,GAC7JsB,EAAoBpE,GAAaS,SAAUyB,EAAKyD,UAAU/M,GAAkCsJ,EAAKyD,UAAU/M,GAAmC8I,GAAeoB,GAC7JsB,EAAoBpE,GAAagB,QAASkB,EAAKyD,UAAU/M,GAAqCsJ,EAAKyD,UAAU/M,GAAkC8I,GAAeoB,GAC9JsB,EAAoBpE,GAAaiB,YAAaiB,EAAKyD,UAAU/M,GAAkCsJ,EAAKyD,UAAU/M,GAAkC8I,GAAeoB,GAC/JsB,EAAoBpE,GAAac,SAAUoB,EAAKyD,UAAU/M,GAAsCsJ,EAAKyD,UAAU/M,GAAmC8I,GAAeoB,GACjKsB,EAAoBpE,GAAae,aAAcmB,EAAKyD,UAAU/M,GAAmCsJ,EAAKyD,UAAU/M,GAAmC8I,GAAeoB,GAClKsB,EAAoBpE,GAAaO,IAAK2B,EAAKyD,UAAU/M,GAAiCsJ,EAAKyD,UAAU/M,GAAgC8I,GAAeoB,GACpJsB,EAAoBpE,GAAaY,KAAMsB,EAAKyD,UAAU/M,GAAsCsJ,EAAKyD,UAAU/M,GAAqC8I,GAAeoB,GAE/JA,EAASK,uBAKTrD,GAAe8F,aAAa9C,GAAU,GAEtChD,GAAe+F,kBAAkB/C,GAAU,EAAOlD,IAGlDE,GAAegG,MACftE,IAAyB,MAgFmB,CAAErF,QAAS+H,GAAsBhI,MA/N9D,IA+NqFjC,OA9NpF,MA+NlB8L,GAAiBpK,GAhKL,SAACQ,GACXiD,GAAejD,aAAmB6J,0BAA4B7E,KAE9DhF,EAAQ8J,OACR9J,EAAQ+J,UAAUzE,GAAUxF,QAAS,EAAG,EAtE7B,IACC,KAuEZE,EAAQ+J,UAAUvE,GAAiB1F,QAASkF,GAAUwE,UAAU/M,GAA4BwM,SAAS3H,EAAI,GAAI0D,GAAUwE,UAAU/M,GAA4BwM,SAAS1H,EAAI,GAAI,IAAK,KACnLvB,EAAQgK,UA7JpB,SAAuBR,EAAWjE,EAAelE,GAC7C,IADqE,IAAnBa,EAAkB,uDAAV,EAAGV,EAAO,uCAC3D9E,EAAI,EAAGA,EAAI8M,EAAUS,OAAQvN,IAAK,CACvC,IAAMwN,EAAWV,EAAU9M,GAE3B,KAAIwN,EAAS1B,MAAQjD,GAArB,CAHuC,MAOtB2E,EAASjB,SAC1B7H,EAAUC,EAR6B,EAO/BC,EACWY,EARoB,EAO5BX,EACmBW,EAAO,EAAGV,KAqJpC2I,CAAcnF,GAAUwE,UAAWjE,GAAevF,EAAS,EAAG,WA5I1E,SAAsBwJ,EAAWjE,EAAelE,GAAwB,IAAnBa,EAAkB,uDAAV,EAAGV,EAAO,uCAE/D4I,YAAqBZ,EAAWjE,GAElB8E,SAAQ,SAACb,GACvBvH,EACIF,EAAQyH,EAAU,GAAGP,UACrBlH,EAAQyH,EAAU,GAAGP,UACrBzH,EACAU,EAAOb,MAoIPoI,CAAazE,GAAUwE,UAAWjE,GAAevF,EAAS,EAAG,cAuJzB,CAAEA,QAFrB,KAEgDD,MAlOtD,IAkOyEjC,OAjOxE,MAmOpB8B,qBAAU,YACS,uCAAG,sBAAAe,EAAA,6DACd2J,IAAgB,SADF,KAEdxH,EAFc,SAGJyH,YAAY,CACdC,aAAc,cACdC,aAAc,GACdC,gBAAiB,IACjBC,WAAY,IACZC,WAAY,IARN,6EAAH,qDAYfC,KACD,IACHjL,qBAAU,WACNoI,GAAmBlI,SA/FH,SAACE,GAEjB,IAAM8K,EAAW,IAAIzE,EAAM0E,MAAMC,aAAahL,GAI9C4D,GAAkB,IAAIyC,EAAM0E,MAAME,cAAcjL,EAAQH,OAAQG,IAEhE8K,EAASI,iBAAiBnG,GAAYhB,OACtC+G,EAASK,SAASpG,GAAYf,MAC9BhB,EAAgB8H,GAqFcM,CAAYpD,GAAmBlI,QAAQG,WAAW8H,OACjF,CAACC,GAAmBlI,UACvBF,qBAAU,WACNmD,GAAgB6E,OACjB,CAAC7E,IACJnD,qBAAU,WACNuD,GAhFiB,SAACkI,EAAqBC,GAEvC,IAAM/H,EAAU0C,IAAY,GAGtBsF,EAAkB,CACpB5N,KAAM4F,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBxG,MACrEyG,IAAKb,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBC,KACpEK,KAAMlB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBM,MACrEC,KAAMnB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBO,MACrEH,UAAWhB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBI,WAC1EC,QAASjB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBK,SACxEH,WAAYd,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBE,YAC3EC,SAAUf,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBG,UACzEO,QAAStB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBU,SACxEC,YAAavB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBW,aAC5EH,SAAUpB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBQ,UACzEC,aAAcrB,EAAQoD,SAAS6E,SAASzG,GAAYZ,yBAAyBS,eAEjFd,GAAgByH,GAGhBhI,EAAQoE,MAAM8D,OAAO,OACrBlI,EAAQoE,MAAM+D,MAAMnI,EAAQoD,UAG5BhD,GAAegI,OAAO1C,SAAS2C,IAAIP,EAAc,EAAGC,EAAe,EAAG,GAGtE3H,GAAekI,sBAAsBC,WAAY,EACjDnI,GAAekI,sBAAsBE,uBAAwB,EAC7DpI,GAAekI,sBAAsBG,mBAAoB,EACzDrI,GAAekI,sBAAsBI,cAAe,EACpDtI,GAAekI,sBAAsBK,mBAAoB,EACzDvI,GAAekI,sBAAsBM,WAAY,EACjDxI,GAAekI,sBAAsBO,gBAAiB,EACtDzI,GAAekI,sBAAsBQ,cAAe,EACpD1I,GAAekI,sBAAsB3F,oBAAqB,EAK1D,IAHA,IAAMoG,EAAiB,GAEjBC,EAAaC,OAAOC,OAAO1H,GAAYZ,0BACpCzH,EAAI,EAAGgQ,EAAInJ,EAAQoD,SAASgG,MAAM1C,OAAQvN,EAAIgQ,EAAGhQ,IAAK,CAC3D,IAAMkQ,EAAQrJ,EAAQoD,SAASgG,MAAMjQ,GAChC6P,EAAWrD,SAAS0D,EAAM5K,KAAKqG,OAChCiE,EAAeO,KAAKD,EAAM5K,KAAKqG,MAGvC3E,GAAoB4I,GACpB9I,GAAWD,GA+BMuJ,CAxPE,IACC,OAwPrB,CAAC3J,IACJvD,qBAAU,WACNuD,GAAiBN,GAAOQ,GAAmBH,GAAe,KAC3D,CAACC,GAAiBN,GAAOQ,IAG5B,IAAMvE,GAAUvB,IAEhB,OACI,sBAAK2B,UAAWJ,GAAQnB,KAAxB,UACKwF,EAAgB,8EAAqB,qEACrCN,EAAM,oGAAuB,2FAC7BQ,EAAkB,kFAAoB,yEACvC,qBAAK/D,IAAKkG,GAAkBuH,MAAO,CAAEC,QAAS,UAC9C,uBAAO1N,IAAKgG,GAAW2H,aAAa,EAAMF,MAAO,CAAEC,QAAS,UAE5D,eAACE,EAAA,EAAD,CACIC,WAAS,EACTC,QAAS,EACTC,UAAU,SACVC,QAAQ,SACRC,WAAW,UALf,UAOI,cAACL,EAAA,EAAD,CAAMM,MAAI,EAACC,GAAI,GAAf,SACI,cAAC7O,EAAD,CAAYW,UAAWqK,GAAgBxK,MAAO,qCAElD,cAAC8N,EAAA,EAAD,CAAMM,MAAI,EAACC,GAAI,GAAf,SACI,cAAC7O,EAAD,CAAYW,UAAWyI,GAAoB5I,MAAO,yBC7bvDsO,MAVf,WACE,OACE,qBAAKxO,UAAU,MAAf,SACE,cAACyO,EAAA,EAAD,CAAWC,SAAS,KAApB,SACE,cAAChL,EAAD,SCKOiL,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASnO,OACP,cAAC,IAAMoO,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.6e21c1de.chunk.js","sourcesContent":[null,"/*\nlist of our fluffy's bones UWU :\ntorso1\n leg1_R\n  leg2_R\n leg1_L\n  leg2_L\n torso2\n  head\n  arm1_R\n   arm2_R\n  arm1_L\n   arm2_L\n*/\n\n//To avoid searching through whole elements of list, we give specific index number instead of string.\n// coco format\nconst coco_skeleton_indices = {\n    nose: 0,\n    leftEye: 1,\n    rightEye: 2,\n    leftEar: 3,\n    rightEar: 4,\n    leftShoulder: 5,\n    rightShoulder: 6,\n    leftElbow: 7,\n    rightElbow: 8,\n    leftWrist: 9,\n    rightWrist: 10,\n    leftHip: 11,\n    rightHip: 12,\n    leftKnee: 13,\n    rightKnee: 14,\n    leftAnkle: 15,\n    rightAnkle: 16\n}\n\nexport { coco_skeleton_indices }","var __extends = (this && this.__extends) || (function () {\n\tvar extendStatics = function (d, b) {\n\t\textendStatics = Object.setPrototypeOf ||\n\t\t\t({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t\t\tfunction (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t\treturn extendStatics(d, b);\n\t};\n\treturn function (d, b) {\n\t\textendStatics(d, b);\n\t\tfunction __() { this.constructor = d; }\n\t\td.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n})();\nvar spine;\n(function (spine) {\n\tvar Animation = (function () {\n\t\tfunction Animation(name, timelines, duration) {\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"name cannot be null.\");\n\t\t\tif (timelines == null)\n\t\t\t\tthrow new Error(\"timelines cannot be null.\");\n\t\t\tthis.name = name;\n\t\t\tthis.timelines = timelines;\n\t\t\tthis.timelineIds = [];\n\t\t\tfor (var i = 0; i < timelines.length; i++)\n\t\t\t\tthis.timelineIds[timelines[i].getPropertyId()] = true;\n\t\t\tthis.duration = duration;\n\t\t}\n\t\tAnimation.prototype.hasTimeline = function (id) {\n\t\t\treturn this.timelineIds[id] == true;\n\t\t};\n\t\tAnimation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tif (loop && this.duration != 0) {\n\t\t\t\ttime %= this.duration;\n\t\t\t\tif (lastTime > 0)\n\t\t\t\t\tlastTime %= this.duration;\n\t\t\t}\n\t\t\tvar timelines = this.timelines;\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\n\t\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n\t\t};\n\t\tAnimation.binarySearch = function (values, target, step) {\n\t\t\tif (step === void 0) { step = 1; }\n\t\t\tvar low = 0;\n\t\t\tvar high = values.length / step - 2;\n\t\t\tif (high == 0)\n\t\t\t\treturn step;\n\t\t\tvar current = high >>> 1;\n\t\t\twhile (true) {\n\t\t\t\tif (values[(current + 1) * step] <= target)\n\t\t\t\t\tlow = current + 1;\n\t\t\t\telse\n\t\t\t\t\thigh = current;\n\t\t\t\tif (low == high)\n\t\t\t\t\treturn (low + 1) * step;\n\t\t\t\tcurrent = (low + high) >>> 1;\n\t\t\t}\n\t\t};\n\t\tAnimation.linearSearch = function (values, target, step) {\n\t\t\tfor (var i = 0, last = values.length - step; i <= last; i += step)\n\t\t\t\tif (values[i] > target)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\treturn Animation;\n\t}());\n\tspine.Animation = Animation;\n\tvar MixBlend;\n\t(function (MixBlend) {\n\t\tMixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\n\t\tMixBlend[MixBlend[\"first\"] = 1] = \"first\";\n\t\tMixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\n\t\tMixBlend[MixBlend[\"add\"] = 3] = \"add\";\n\t})(MixBlend = spine.MixBlend || (spine.MixBlend = {}));\n\tvar MixDirection;\n\t(function (MixDirection) {\n\t\tMixDirection[MixDirection[\"mixIn\"] = 0] = \"mixIn\";\n\t\tMixDirection[MixDirection[\"mixOut\"] = 1] = \"mixOut\";\n\t})(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\n\tvar TimelineType;\n\t(function (TimelineType) {\n\t\tTimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\n\t\tTimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\n\t\tTimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\n\t\tTimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\n\t\tTimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\n\t\tTimelineType[TimelineType[\"color\"] = 5] = \"color\";\n\t\tTimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\n\t\tTimelineType[TimelineType[\"event\"] = 7] = \"event\";\n\t\tTimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\n\t\tTimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\n\t\tTimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\n\t\tTimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n\t\tTimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n\t\tTimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n\t\tTimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\n\t})(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\n\tvar CurveTimeline = (function () {\n\t\tfunction CurveTimeline(frameCount) {\n\t\t\tif (frameCount <= 0)\n\t\t\t\tthrow new Error(\"frameCount must be > 0: \" + frameCount);\n\t\t\tthis.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n\t\t}\n\t\tCurveTimeline.prototype.getFrameCount = function () {\n\t\t\treturn this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n\t\t};\n\t\tCurveTimeline.prototype.setLinear = function (frameIndex) {\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n\t\t};\n\t\tCurveTimeline.prototype.setStepped = function (frameIndex) {\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n\t\t};\n\t\tCurveTimeline.prototype.getCurveType = function (frameIndex) {\n\t\t\tvar index = frameIndex * CurveTimeline.BEZIER_SIZE;\n\t\t\tif (index == this.curves.length)\n\t\t\t\treturn CurveTimeline.LINEAR;\n\t\t\tvar type = this.curves[index];\n\t\t\tif (type == CurveTimeline.LINEAR)\n\t\t\t\treturn CurveTimeline.LINEAR;\n\t\t\tif (type == CurveTimeline.STEPPED)\n\t\t\t\treturn CurveTimeline.STEPPED;\n\t\t\treturn CurveTimeline.BEZIER;\n\t\t};\n\t\tCurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\n\t\t\tvar tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n\t\t\tvar dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n\t\t\tvar ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n\t\t\tvar dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\n\t\t\tvar curves = this.curves;\n\t\t\tcurves[i++] = CurveTimeline.BEZIER;\n\t\t\tvar x = dfx, y = dfy;\n\t\t\tfor (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n\t\t\t\tcurves[i] = x;\n\t\t\t\tcurves[i + 1] = y;\n\t\t\t\tdfx += ddfx;\n\t\t\t\tdfy += ddfy;\n\t\t\t\tddfx += dddfx;\n\t\t\t\tddfy += dddfy;\n\t\t\t\tx += dfx;\n\t\t\t\ty += dfy;\n\t\t\t}\n\t\t};\n\t\tCurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\n\t\t\tpercent = spine.MathUtils.clamp(percent, 0, 1);\n\t\t\tvar curves = this.curves;\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\n\t\t\tvar type = curves[i];\n\t\t\tif (type == CurveTimeline.LINEAR)\n\t\t\t\treturn percent;\n\t\t\tif (type == CurveTimeline.STEPPED)\n\t\t\t\treturn 0;\n\t\t\ti++;\n\t\t\tvar x = 0;\n\t\t\tfor (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n\t\t\t\tx = curves[i];\n\t\t\t\tif (x >= percent) {\n\t\t\t\t\tvar prevX = void 0, prevY = void 0;\n\t\t\t\t\tif (i == start) {\n\t\t\t\t\t\tprevX = 0;\n\t\t\t\t\t\tprevY = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprevX = curves[i - 2];\n\t\t\t\t\t\tprevY = curves[i - 1];\n\t\t\t\t\t}\n\t\t\t\t\treturn prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar y = curves[i - 1];\n\t\t\treturn y + (1 - y) * (percent - x) / (1 - x);\n\t\t};\n\t\tCurveTimeline.LINEAR = 0;\n\t\tCurveTimeline.STEPPED = 1;\n\t\tCurveTimeline.BEZIER = 2;\n\t\tCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\n\t\treturn CurveTimeline;\n\t}());\n\tspine.CurveTimeline = CurveTimeline;\n\tvar RotateTimeline = (function (_super) {\n\t\t__extends(RotateTimeline, _super);\n\t\tfunction RotateTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount << 1);\n\t\t\treturn _this;\n\t\t}\n\t\tRotateTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.rotate << 24) + this.boneIndex;\n\t\t};\n\t\tRotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\n\t\t\tframeIndex <<= 1;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n\t\t};\n\t\tRotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\n\t\t\tif (!bone.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tvar r_1 = bone.data.rotation - bone.rotation;\n\t\t\t\t\t\tbone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n\t\t\t\tvar r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbone.rotation = bone.data.rotation + r_2 * alpha;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\tr_2 += bone.data.rotation - bone.rotation;\n\t\t\t\t\t\tr_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\n\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\tbone.rotation += r_2 * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n\t\t\tvar prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n\t\t\tvar frameTime = frames[frame];\n\t\t\tvar percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\t\t\tvar r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n\t\t\tr = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\tr += bone.data.rotation - bone.rotation;\n\t\t\t\tcase MixBlend.add:\n\t\t\t\t\tbone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n\t\t\t}\n\t\t};\n\t\tRotateTimeline.ENTRIES = 2;\n\t\tRotateTimeline.PREV_TIME = -2;\n\t\tRotateTimeline.PREV_ROTATION = -1;\n\t\tRotateTimeline.ROTATION = 1;\n\t\treturn RotateTimeline;\n\t}(CurveTimeline));\n\tspine.RotateTimeline = RotateTimeline;\n\tvar TranslateTimeline = (function (_super) {\n\t\t__extends(TranslateTimeline, _super);\n\t\tfunction TranslateTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tTranslateTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.translate << 24) + this.boneIndex;\n\t\t};\n\t\tTranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\n\t\t\tframeIndex *= TranslateTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + TranslateTimeline.X] = x;\n\t\t\tthis.frames[frameIndex + TranslateTimeline.Y] = y;\n\t\t};\n\t\tTranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\n\t\t\tif (!bone.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbone.x = bone.data.x;\n\t\t\t\t\t\tbone.y = bone.data.y;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\n\t\t\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar x = 0, y = 0;\n\t\t\tif (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n\t\t\t\tx = frames[frames.length + TranslateTimeline.PREV_X];\n\t\t\t\ty = frames[frames.length + TranslateTimeline.PREV_Y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n\t\t\t\tx = frames[frame + TranslateTimeline.PREV_X];\n\t\t\t\ty = frames[frame + TranslateTimeline.PREV_Y];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\t\t\t\tx += (frames[frame + TranslateTimeline.X] - x) * percent;\n\t\t\t\ty += (frames[frame + TranslateTimeline.Y] - y) * percent;\n\t\t\t}\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.x = bone.data.x + x * alpha;\n\t\t\t\t\tbone.y = bone.data.y + y * alpha;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\n\t\t\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.add:\n\t\t\t\t\tbone.x += x * alpha;\n\t\t\t\t\tbone.y += y * alpha;\n\t\t\t}\n\t\t};\n\t\tTranslateTimeline.ENTRIES = 3;\n\t\tTranslateTimeline.PREV_TIME = -3;\n\t\tTranslateTimeline.PREV_X = -2;\n\t\tTranslateTimeline.PREV_Y = -1;\n\t\tTranslateTimeline.X = 1;\n\t\tTranslateTimeline.Y = 2;\n\t\treturn TranslateTimeline;\n\t}(CurveTimeline));\n\tspine.TranslateTimeline = TranslateTimeline;\n\tvar ScaleTimeline = (function (_super) {\n\t\t__extends(ScaleTimeline, _super);\n\t\tfunction ScaleTimeline(frameCount) {\n\t\t\treturn _super.call(this, frameCount) || this;\n\t\t}\n\t\tScaleTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.scale << 24) + this.boneIndex;\n\t\t};\n\t\tScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\n\t\t\tif (!bone.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbone.scaleX = bone.data.scaleX;\n\t\t\t\t\t\tbone.scaleY = bone.data.scaleY;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n\t\t\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar x = 0, y = 0;\n\t\t\tif (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n\t\t\t\tx = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n\t\t\t\ty = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n\t\t\t\tx = frames[frame + ScaleTimeline.PREV_X];\n\t\t\t\ty = frames[frame + ScaleTimeline.PREV_Y];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\t\t\t\tx = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n\t\t\t\ty = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n\t\t\t}\n\t\t\tif (alpha == 1) {\n\t\t\t\tif (blend == MixBlend.add) {\n\t\t\t\t\tbone.scaleX += x - bone.data.scaleX;\n\t\t\t\t\tbone.scaleY += y - bone.data.scaleY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbone.scaleX = x;\n\t\t\t\t\tbone.scaleY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar bx = 0, by = 0;\n\t\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\t\tswitch (blend) {\n\t\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\t\tbx = bone.data.scaleX;\n\t\t\t\t\t\t\tby = bone.data.scaleY;\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\t\tbx = bone.scaleX;\n\t\t\t\t\t\t\tby = bone.scaleY;\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\t\tbx = bone.scaleX;\n\t\t\t\t\t\t\tby = bone.scaleY;\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch (blend) {\n\t\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\t\tbx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);\n\t\t\t\t\t\t\tby = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);\n\t\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\t\tbx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);\n\t\t\t\t\t\t\tby = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);\n\t\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\t\tbx = spine.MathUtils.signum(x);\n\t\t\t\t\t\t\tby = spine.MathUtils.signum(y);\n\t\t\t\t\t\t\tbone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n\t\t\t\t\t\t\tbone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn ScaleTimeline;\n\t}(TranslateTimeline));\n\tspine.ScaleTimeline = ScaleTimeline;\n\tvar ShearTimeline = (function (_super) {\n\t\t__extends(ShearTimeline, _super);\n\t\tfunction ShearTimeline(frameCount) {\n\t\t\treturn _super.call(this, frameCount) || this;\n\t\t}\n\t\tShearTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.shear << 24) + this.boneIndex;\n\t\t};\n\t\tShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\n\t\t\tif (!bone.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tbone.shearX = bone.data.shearX;\n\t\t\t\t\t\tbone.shearY = bone.data.shearY;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n\t\t\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar x = 0, y = 0;\n\t\t\tif (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n\t\t\t\tx = frames[frames.length + ShearTimeline.PREV_X];\n\t\t\t\ty = frames[frames.length + ShearTimeline.PREV_Y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n\t\t\t\tx = frames[frame + ShearTimeline.PREV_X];\n\t\t\t\ty = frames[frame + ShearTimeline.PREV_Y];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\t\t\t\tx = x + (frames[frame + ShearTimeline.X] - x) * percent;\n\t\t\t\ty = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n\t\t\t}\n\t\t\tswitch (blend) {\n\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\tbone.shearX = bone.data.shearX + x * alpha;\n\t\t\t\t\tbone.shearY = bone.data.shearY + y * alpha;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.first:\n\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n\t\t\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MixBlend.add:\n\t\t\t\t\tbone.shearX += x * alpha;\n\t\t\t\t\tbone.shearY += y * alpha;\n\t\t\t}\n\t\t};\n\t\treturn ShearTimeline;\n\t}(TranslateTimeline));\n\tspine.ShearTimeline = ShearTimeline;\n\tvar ColorTimeline = (function (_super) {\n\t\t__extends(ColorTimeline, _super);\n\t\tfunction ColorTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tColorTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.color << 24) + this.slotIndex;\n\t\t};\n\t\tColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\n\t\t\tframeIndex *= ColorTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + ColorTimeline.R] = r;\n\t\t\tthis.frames[frameIndex + ColorTimeline.G] = g;\n\t\t\tthis.frames[frameIndex + ColorTimeline.B] = b;\n\t\t\tthis.frames[frameIndex + ColorTimeline.A] = a;\n\t\t};\n\t\tColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\n\t\t\tif (!slot.bone.active)\n\t\t\t\treturn;\n\t\t\tvar frames = this.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tvar color = slot.color, setup = slot.data.color;\n\t\t\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar r = 0, g = 0, b = 0, a = 0;\n\t\t\tif (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n\t\t\t\tvar i = frames.length;\n\t\t\t\tr = frames[i + ColorTimeline.PREV_R];\n\t\t\t\tg = frames[i + ColorTimeline.PREV_G];\n\t\t\t\tb = frames[i + ColorTimeline.PREV_B];\n\t\t\t\ta = frames[i + ColorTimeline.PREV_A];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n\t\t\t\tr = frames[frame + ColorTimeline.PREV_R];\n\t\t\t\tg = frames[frame + ColorTimeline.PREV_G];\n\t\t\t\tb = frames[frame + ColorTimeline.PREV_B];\n\t\t\t\ta = frames[frame + ColorTimeline.PREV_A];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\t\t\t\tr += (frames[frame + ColorTimeline.R] - r) * percent;\n\t\t\t\tg += (frames[frame + ColorTimeline.G] - g) * percent;\n\t\t\t\tb += (frames[frame + ColorTimeline.B] - b) * percent;\n\t\t\t\ta += (frames[frame + ColorTimeline.A] - a) * percent;\n\t\t\t}\n\t\t\tif (alpha == 1)\n\t\t\t\tslot.color.set(r, g, b, a);\n\t\t\telse {\n\t\t\t\tvar color = slot.color;\n\t\t\t\tif (blend == MixBlend.setup)\n\t\t\t\t\tcolor.setFromColor(slot.data.color);\n\t\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n\t\t\t}\n\t\t};\n\t\tColorTimeline.ENTRIES = 5;\n\t\tColorTimeline.PREV_TIME = -5;\n\t\tColorTimeline.PREV_R = -4;\n\t\tColorTimeline.PREV_G = -3;\n\t\tColorTimeline.PREV_B = -2;\n\t\tColorTimeline.PREV_A = -1;\n\t\tColorTimeline.R = 1;\n\t\tColorTimeline.G = 2;\n\t\tColorTimeline.B = 3;\n\t\tColorTimeline.A = 4;\n\t\treturn ColorTimeline;\n\t}(CurveTimeline));\n\tspine.ColorTimeline = ColorTimeline;\n\tvar TwoColorTimeline = (function (_super) {\n\t\t__extends(TwoColorTimeline, _super);\n\t\tfunction TwoColorTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tTwoColorTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.twoColor << 24) + this.slotIndex;\n\t\t};\n\t\tTwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\n\t\t\tframeIndex *= TwoColorTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R] = r;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G] = g;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B] = b;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.A] = a;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R2] = r2;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G2] = g2;\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B2] = b2;\n\t\t};\n\t\tTwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\n\t\t\tif (!slot.bone.active)\n\t\t\t\treturn;\n\t\t\tvar frames = this.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\n\t\t\t\t\t\tslot.darkColor.setFromColor(slot.data.darkColor);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tvar light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\n\t\t\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n\t\t\t\t\t\tdark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n\t\t\tif (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n\t\t\t\tvar i = frames.length;\n\t\t\t\tr = frames[i + TwoColorTimeline.PREV_R];\n\t\t\t\tg = frames[i + TwoColorTimeline.PREV_G];\n\t\t\t\tb = frames[i + TwoColorTimeline.PREV_B];\n\t\t\t\ta = frames[i + TwoColorTimeline.PREV_A];\n\t\t\t\tr2 = frames[i + TwoColorTimeline.PREV_R2];\n\t\t\t\tg2 = frames[i + TwoColorTimeline.PREV_G2];\n\t\t\t\tb2 = frames[i + TwoColorTimeline.PREV_B2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n\t\t\t\tr = frames[frame + TwoColorTimeline.PREV_R];\n\t\t\t\tg = frames[frame + TwoColorTimeline.PREV_G];\n\t\t\t\tb = frames[frame + TwoColorTimeline.PREV_B];\n\t\t\t\ta = frames[frame + TwoColorTimeline.PREV_A];\n\t\t\t\tr2 = frames[frame + TwoColorTimeline.PREV_R2];\n\t\t\t\tg2 = frames[frame + TwoColorTimeline.PREV_G2];\n\t\t\t\tb2 = frames[frame + TwoColorTimeline.PREV_B2];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\t\t\t\tr += (frames[frame + TwoColorTimeline.R] - r) * percent;\n\t\t\t\tg += (frames[frame + TwoColorTimeline.G] - g) * percent;\n\t\t\t\tb += (frames[frame + TwoColorTimeline.B] - b) * percent;\n\t\t\t\ta += (frames[frame + TwoColorTimeline.A] - a) * percent;\n\t\t\t\tr2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n\t\t\t\tg2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n\t\t\t\tb2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n\t\t\t}\n\t\t\tif (alpha == 1) {\n\t\t\t\tslot.color.set(r, g, b, a);\n\t\t\t\tslot.darkColor.set(r2, g2, b2, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar light = slot.color, dark = slot.darkColor;\n\t\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\t\tlight.setFromColor(slot.data.color);\n\t\t\t\t\tdark.setFromColor(slot.data.darkColor);\n\t\t\t\t}\n\t\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n\t\t\t\tdark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n\t\t\t}\n\t\t};\n\t\tTwoColorTimeline.ENTRIES = 8;\n\t\tTwoColorTimeline.PREV_TIME = -8;\n\t\tTwoColorTimeline.PREV_R = -7;\n\t\tTwoColorTimeline.PREV_G = -6;\n\t\tTwoColorTimeline.PREV_B = -5;\n\t\tTwoColorTimeline.PREV_A = -4;\n\t\tTwoColorTimeline.PREV_R2 = -3;\n\t\tTwoColorTimeline.PREV_G2 = -2;\n\t\tTwoColorTimeline.PREV_B2 = -1;\n\t\tTwoColorTimeline.R = 1;\n\t\tTwoColorTimeline.G = 2;\n\t\tTwoColorTimeline.B = 3;\n\t\tTwoColorTimeline.A = 4;\n\t\tTwoColorTimeline.R2 = 5;\n\t\tTwoColorTimeline.G2 = 6;\n\t\tTwoColorTimeline.B2 = 7;\n\t\treturn TwoColorTimeline;\n\t}(CurveTimeline));\n\tspine.TwoColorTimeline = TwoColorTimeline;\n\tvar AttachmentTimeline = (function () {\n\t\tfunction AttachmentTimeline(frameCount) {\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\n\t\t\tthis.attachmentNames = new Array(frameCount);\n\t\t}\n\t\tAttachmentTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.attachment << 24) + this.slotIndex;\n\t\t};\n\t\tAttachmentTimeline.prototype.getFrameCount = function () {\n\t\t\treturn this.frames.length;\n\t\t};\n\t\tAttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.attachmentNames[frameIndex] = attachmentName;\n\t\t};\n\t\tAttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\n\t\t\tif (!slot.bone.active)\n\t\t\t\treturn;\n\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\tif (blend == MixBlend.setup)\n\t\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frames = this.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first)\n\t\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frameIndex = 0;\n\t\t\tif (time >= frames[frames.length - 1])\n\t\t\t\tframeIndex = frames.length - 1;\n\t\t\telse\n\t\t\t\tframeIndex = Animation.binarySearch(frames, time, 1) - 1;\n\t\t\tvar attachmentName = this.attachmentNames[frameIndex];\n\t\t\tskeleton.slots[this.slotIndex]\n\t\t\t\t.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n\t\t};\n\t\tAttachmentTimeline.prototype.setAttachment = function (skeleton, slot, attachmentName) {\n\t\t\tslot.attachment = attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName);\n\t\t};\n\t\treturn AttachmentTimeline;\n\t}());\n\tspine.AttachmentTimeline = AttachmentTimeline;\n\tvar zeros = null;\n\tvar DeformTimeline = (function (_super) {\n\t\t__extends(DeformTimeline, _super);\n\t\tfunction DeformTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount);\n\t\t\t_this.frameVertices = new Array(frameCount);\n\t\t\tif (zeros == null)\n\t\t\t\tzeros = spine.Utils.newFloatArray(64);\n\t\t\treturn _this;\n\t\t}\n\t\tDeformTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\n\t\t};\n\t\tDeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frameVertices[frameIndex] = vertices;\n\t\t};\n\t\tDeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\n\t\t\tif (!slot.bone.active)\n\t\t\t\treturn;\n\t\t\tvar slotAttachment = slot.getAttachment();\n\t\t\tif (!(slotAttachment instanceof spine.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\n\t\t\t\treturn;\n\t\t\tvar deformArray = slot.deform;\n\t\t\tif (deformArray.length == 0)\n\t\t\t\tblend = MixBlend.setup;\n\t\t\tvar frameVertices = this.frameVertices;\n\t\t\tvar vertexCount = frameVertices[0].length;\n\t\t\tvar frames = this.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tvar vertexAttachment = slotAttachment;\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tdeformArray.length = 0;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tif (alpha == 1) {\n\t\t\t\t\t\t\tdeformArray.length = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar deform_1 = spine.Utils.setArraySize(deformArray, vertexCount);\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\t\tdeform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\talpha = 1 - alpha;\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\n\t\t\t\t\t\t\t\tdeform_1[i] *= alpha;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar deform = spine.Utils.setArraySize(deformArray, vertexCount);\n\t\t\tif (time >= frames[frames.length - 1]) {\n\t\t\t\tvar lastVertices = frameVertices[frames.length - 1];\n\t\t\t\tif (alpha == 1) {\n\t\t\t\t\tif (blend == MixBlend.add) {\n\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tfor (var i_1 = 0; i_1 < vertexCount; i_1++) {\n\t\t\t\t\t\t\t\tdeform[i_1] += lastVertices[i_1] - setupVertices[i_1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (var i_2 = 0; i_2 < vertexCount; i_2++)\n\t\t\t\t\t\t\t\tdeform[i_2] += lastVertices[i_2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tspine.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch (blend) {\n\t\t\t\t\t\tcase MixBlend.setup: {\n\t\t\t\t\t\t\tvar vertexAttachment_1 = slotAttachment;\n\t\t\t\t\t\t\tif (vertexAttachment_1.bones == null) {\n\t\t\t\t\t\t\t\tvar setupVertices = vertexAttachment_1.vertices;\n\t\t\t\t\t\t\t\tfor (var i_3 = 0; i_3 < vertexCount; i_3++) {\n\t\t\t\t\t\t\t\t\tvar setup = setupVertices[i_3];\n\t\t\t\t\t\t\t\t\tdeform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfor (var i_4 = 0; i_4 < vertexCount; i_4++)\n\t\t\t\t\t\t\t\t\tdeform[i_4] = lastVertices[i_4] * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\t\tfor (var i_5 = 0; i_5 < vertexCount; i_5++)\n\t\t\t\t\t\t\t\tdeform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\n\t\t\t\t\t\t\tif (vertexAttachment.bones == null) {\n\t\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\t\tfor (var i_6 = 0; i_6 < vertexCount; i_6++) {\n\t\t\t\t\t\t\t\t\tdeform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfor (var i_7 = 0; i_7 < vertexCount; i_7++)\n\t\t\t\t\t\t\t\t\tdeform[i_7] += lastVertices[i_7] * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frame = Animation.binarySearch(frames, time);\n\t\t\tvar prevVertices = frameVertices[frame - 1];\n\t\t\tvar nextVertices = frameVertices[frame];\n\t\t\tvar frameTime = frames[frame];\n\t\t\tvar percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\t\t\tif (alpha == 1) {\n\t\t\t\tif (blend == MixBlend.add) {\n\t\t\t\t\tvar vertexAttachment = slotAttachment;\n\t\t\t\t\tif (vertexAttachment.bones == null) {\n\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\tfor (var i_8 = 0; i_8 < vertexCount; i_8++) {\n\t\t\t\t\t\t\tvar prev = prevVertices[i_8];\n\t\t\t\t\t\t\tdeform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (var i_9 = 0; i_9 < vertexCount; i_9++) {\n\t\t\t\t\t\t\tvar prev = prevVertices[i_9];\n\t\t\t\t\t\t\tdeform[i_9] += prev + (nextVertices[i_9] - prev) * percent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (var i_10 = 0; i_10 < vertexCount; i_10++) {\n\t\t\t\t\t\tvar prev = prevVertices[i_10];\n\t\t\t\t\t\tdeform[i_10] = prev + (nextVertices[i_10] - prev) * percent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup: {\n\t\t\t\t\t\tvar vertexAttachment_2 = slotAttachment;\n\t\t\t\t\t\tif (vertexAttachment_2.bones == null) {\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment_2.vertices;\n\t\t\t\t\t\t\tfor (var i_11 = 0; i_11 < vertexCount; i_11++) {\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_11], setup = setupVertices[i_11];\n\t\t\t\t\t\t\t\tdeform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (var i_12 = 0; i_12 < vertexCount; i_12++) {\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_12];\n\t\t\t\t\t\t\t\tdeform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\tcase MixBlend.replace:\n\t\t\t\t\t\tfor (var i_13 = 0; i_13 < vertexCount; i_13++) {\n\t\t\t\t\t\t\tvar prev = prevVertices[i_13];\n\t\t\t\t\t\t\tdeform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MixBlend.add:\n\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\n\t\t\t\t\t\t\tfor (var i_14 = 0; i_14 < vertexCount; i_14++) {\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_14];\n\t\t\t\t\t\t\t\tdeform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (var i_15 = 0; i_15 < vertexCount; i_15++) {\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_15];\n\t\t\t\t\t\t\t\tdeform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn DeformTimeline;\n\t}(CurveTimeline));\n\tspine.DeformTimeline = DeformTimeline;\n\tvar EventTimeline = (function () {\n\t\tfunction EventTimeline(frameCount) {\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\n\t\t\tthis.events = new Array(frameCount);\n\t\t}\n\t\tEventTimeline.prototype.getPropertyId = function () {\n\t\t\treturn TimelineType.event << 24;\n\t\t};\n\t\tEventTimeline.prototype.getFrameCount = function () {\n\t\t\treturn this.frames.length;\n\t\t};\n\t\tEventTimeline.prototype.setFrame = function (frameIndex, event) {\n\t\t\tthis.frames[frameIndex] = event.time;\n\t\t\tthis.events[frameIndex] = event;\n\t\t};\n\t\tEventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tif (firedEvents == null)\n\t\t\t\treturn;\n\t\t\tvar frames = this.frames;\n\t\t\tvar frameCount = this.frames.length;\n\t\t\tif (lastTime > time) {\n\t\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n\t\t\t\tlastTime = -1;\n\t\t\t}\n\t\t\telse if (lastTime >= frames[frameCount - 1])\n\t\t\t\treturn;\n\t\t\tif (time < frames[0])\n\t\t\t\treturn;\n\t\t\tvar frame = 0;\n\t\t\tif (lastTime < frames[0])\n\t\t\t\tframe = 0;\n\t\t\telse {\n\t\t\t\tframe = Animation.binarySearch(frames, lastTime);\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\twhile (frame > 0) {\n\t\t\t\t\tif (frames[frame - 1] != frameTime)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tframe--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; frame < frameCount && time >= frames[frame]; frame++)\n\t\t\t\tfiredEvents.push(this.events[frame]);\n\t\t};\n\t\treturn EventTimeline;\n\t}());\n\tspine.EventTimeline = EventTimeline;\n\tvar DrawOrderTimeline = (function () {\n\t\tfunction DrawOrderTimeline(frameCount) {\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\n\t\t\tthis.drawOrders = new Array(frameCount);\n\t\t}\n\t\tDrawOrderTimeline.prototype.getPropertyId = function () {\n\t\t\treturn TimelineType.drawOrder << 24;\n\t\t};\n\t\tDrawOrderTimeline.prototype.getFrameCount = function () {\n\t\t\treturn this.frames.length;\n\t\t};\n\t\tDrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.drawOrders[frameIndex] = drawOrder;\n\t\t};\n\t\tDrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar drawOrder = skeleton.drawOrder;\n\t\t\tvar slots = skeleton.slots;\n\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\tif (blend == MixBlend.setup)\n\t\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frames = this.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first)\n\t\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frame = 0;\n\t\t\tif (time >= frames[frames.length - 1])\n\t\t\t\tframe = frames.length - 1;\n\t\t\telse\n\t\t\t\tframe = Animation.binarySearch(frames, time) - 1;\n\t\t\tvar drawOrderToSetupIndex = this.drawOrders[frame];\n\t\t\tif (drawOrderToSetupIndex == null)\n\t\t\t\tspine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n\t\t\telse {\n\t\t\t\tfor (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n\t\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\n\t\t\t}\n\t\t};\n\t\treturn DrawOrderTimeline;\n\t}());\n\tspine.DrawOrderTimeline = DrawOrderTimeline;\n\tvar IkConstraintTimeline = (function (_super) {\n\t\t__extends(IkConstraintTimeline, _super);\n\t\tfunction IkConstraintTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tIkConstraintTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n\t\t};\n\t\tIkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {\n\t\t\tframeIndex *= IkConstraintTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n\t\t};\n\t\tIkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tconstraint.mix = constraint.data.mix;\n\t\t\t\t\t\tconstraint.softness = constraint.data.softness;\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n\t\t\t\t\t\tconstraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n\t\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\t\tconstraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n\t\t\t\t\tconstraint.softness = constraint.data.softness\n\t\t\t\t\t\t+ (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\n\t\t\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n\t\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n\t\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconstraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n\t\t\t\t\tconstraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\n\t\t\t\t\tif (direction == MixDirection.mixIn) {\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n\t\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n\t\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n\t\t\tvar mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n\t\t\tvar softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\n\t\t\tvar frameTime = frames[frame];\n\t\t\tvar percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tconstraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n\t\t\t\tconstraint.softness = constraint.data.softness\n\t\t\t\t\t+ (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\n\t\t\t\tif (direction == MixDirection.mixOut) {\n\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n\t\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n\t\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n\t\t\t\tconstraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\n\t\t\t\tif (direction == MixDirection.mixIn) {\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n\t\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n\t\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tIkConstraintTimeline.ENTRIES = 6;\n\t\tIkConstraintTimeline.PREV_TIME = -6;\n\t\tIkConstraintTimeline.PREV_MIX = -5;\n\t\tIkConstraintTimeline.PREV_SOFTNESS = -4;\n\t\tIkConstraintTimeline.PREV_BEND_DIRECTION = -3;\n\t\tIkConstraintTimeline.PREV_COMPRESS = -2;\n\t\tIkConstraintTimeline.PREV_STRETCH = -1;\n\t\tIkConstraintTimeline.MIX = 1;\n\t\tIkConstraintTimeline.SOFTNESS = 2;\n\t\tIkConstraintTimeline.BEND_DIRECTION = 3;\n\t\tIkConstraintTimeline.COMPRESS = 4;\n\t\tIkConstraintTimeline.STRETCH = 5;\n\t\treturn IkConstraintTimeline;\n\t}(CurveTimeline));\n\tspine.IkConstraintTimeline = IkConstraintTimeline;\n\tvar TransformConstraintTimeline = (function (_super) {\n\t\t__extends(TransformConstraintTimeline, _super);\n\t\tfunction TransformConstraintTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tTransformConstraintTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n\t\t};\n\t\tTransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n\t\t\tframeIndex *= TransformConstraintTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n\t\t};\n\t\tTransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tvar data = constraint.data;\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tconstraint.rotateMix = data.rotateMix;\n\t\t\t\t\t\tconstraint.translateMix = data.translateMix;\n\t\t\t\t\t\tconstraint.scaleMix = data.scaleMix;\n\t\t\t\t\t\tconstraint.shearMix = data.shearMix;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tconstraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n\t\t\t\t\t\tconstraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n\t\t\t\t\t\tconstraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n\t\t\t\t\t\tconstraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar rotate = 0, translate = 0, scale = 0, shear = 0;\n\t\t\tif (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n\t\t\t\tvar i = frames.length;\n\t\t\t\trotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n\t\t\t\ttranslate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n\t\t\t\tscale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n\t\t\t\tshear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n\t\t\t\trotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n\t\t\t\ttranslate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n\t\t\t\tscale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n\t\t\t\tshear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\t\t\t\trotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n\t\t\t\ttranslate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n\t\t\t\tscale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n\t\t\t\tshear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n\t\t\t}\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tvar data = constraint.data;\n\t\t\t\tconstraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n\t\t\t\tconstraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n\t\t\t\tconstraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n\t\t\t\tconstraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\n\t\t\t\tconstraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n\t\t\t\tconstraint.shearMix += (shear - constraint.shearMix) * alpha;\n\t\t\t}\n\t\t};\n\t\tTransformConstraintTimeline.ENTRIES = 5;\n\t\tTransformConstraintTimeline.PREV_TIME = -5;\n\t\tTransformConstraintTimeline.PREV_ROTATE = -4;\n\t\tTransformConstraintTimeline.PREV_TRANSLATE = -3;\n\t\tTransformConstraintTimeline.PREV_SCALE = -2;\n\t\tTransformConstraintTimeline.PREV_SHEAR = -1;\n\t\tTransformConstraintTimeline.ROTATE = 1;\n\t\tTransformConstraintTimeline.TRANSLATE = 2;\n\t\tTransformConstraintTimeline.SCALE = 3;\n\t\tTransformConstraintTimeline.SHEAR = 4;\n\t\treturn TransformConstraintTimeline;\n\t}(CurveTimeline));\n\tspine.TransformConstraintTimeline = TransformConstraintTimeline;\n\tvar PathConstraintPositionTimeline = (function (_super) {\n\t\t__extends(PathConstraintPositionTimeline, _super);\n\t\tfunction PathConstraintPositionTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tPathConstraintPositionTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n\t\t};\n\t\tPathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\n\t\t\tframeIndex *= PathConstraintPositionTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n\t\t};\n\t\tPathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tconstraint.position = constraint.data.position;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tconstraint.position += (constraint.data.position - constraint.position) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar position = 0;\n\t\t\tif (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\n\t\t\t\tposition = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n\t\t\t\tposition = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\t\t\t\tposition += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n\t\t\t}\n\t\t\tif (blend == MixBlend.setup)\n\t\t\t\tconstraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n\t\t\telse\n\t\t\t\tconstraint.position += (position - constraint.position) * alpha;\n\t\t};\n\t\tPathConstraintPositionTimeline.ENTRIES = 2;\n\t\tPathConstraintPositionTimeline.PREV_TIME = -2;\n\t\tPathConstraintPositionTimeline.PREV_VALUE = -1;\n\t\tPathConstraintPositionTimeline.VALUE = 1;\n\t\treturn PathConstraintPositionTimeline;\n\t}(CurveTimeline));\n\tspine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\n\tvar PathConstraintSpacingTimeline = (function (_super) {\n\t\t__extends(PathConstraintSpacingTimeline, _super);\n\t\tfunction PathConstraintSpacingTimeline(frameCount) {\n\t\t\treturn _super.call(this, frameCount) || this;\n\t\t}\n\t\tPathConstraintSpacingTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n\t\t};\n\t\tPathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tconstraint.spacing = constraint.data.spacing;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tconstraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar spacing = 0;\n\t\t\tif (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n\t\t\t\tspacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n\t\t\t\tspacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\t\t\t\tspacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n\t\t\t}\n\t\t\tif (blend == MixBlend.setup)\n\t\t\t\tconstraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n\t\t\telse\n\t\t\t\tconstraint.spacing += (spacing - constraint.spacing) * alpha;\n\t\t};\n\t\treturn PathConstraintSpacingTimeline;\n\t}(PathConstraintPositionTimeline));\n\tspine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\n\tvar PathConstraintMixTimeline = (function (_super) {\n\t\t__extends(PathConstraintMixTimeline, _super);\n\t\tfunction PathConstraintMixTimeline(frameCount) {\n\t\t\tvar _this = _super.call(this, frameCount) || this;\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n\t\t\treturn _this;\n\t\t}\n\t\tPathConstraintMixTimeline.prototype.getPropertyId = function () {\n\t\t\treturn (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n\t\t};\n\t\tPathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\n\t\t\tframeIndex *= PathConstraintMixTimeline.ENTRIES;\n\t\t\tthis.frames[frameIndex] = time;\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n\t\t};\n\t\tPathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n\t\t\tvar frames = this.frames;\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase MixBlend.setup:\n\t\t\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix;\n\t\t\t\t\t\tconstraint.translateMix = constraint.data.translateMix;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase MixBlend.first:\n\t\t\t\t\t\tconstraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n\t\t\t\t\t\tconstraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar rotate = 0, translate = 0;\n\t\t\tif (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n\t\t\t\trotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n\t\t\t\ttranslate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n\t\t\t\trotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n\t\t\t\ttranslate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\t\t\t\trotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n\t\t\t\ttranslate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n\t\t\t}\n\t\t\tif (blend == MixBlend.setup) {\n\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n\t\t\t\tconstraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\n\t\t\t}\n\t\t};\n\t\tPathConstraintMixTimeline.ENTRIES = 3;\n\t\tPathConstraintMixTimeline.PREV_TIME = -3;\n\t\tPathConstraintMixTimeline.PREV_ROTATE = -2;\n\t\tPathConstraintMixTimeline.PREV_TRANSLATE = -1;\n\t\tPathConstraintMixTimeline.ROTATE = 1;\n\t\tPathConstraintMixTimeline.TRANSLATE = 2;\n\t\treturn PathConstraintMixTimeline;\n\t}(CurveTimeline));\n\tspine.PathConstraintMixTimeline = PathConstraintMixTimeline;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar AnimationState = (function () {\n\t\tfunction AnimationState(data) {\n\t\t\tthis.tracks = new Array();\n\t\t\tthis.timeScale = 1;\n\t\t\tthis.unkeyedState = 0;\n\t\t\tthis.events = new Array();\n\t\t\tthis.listeners = new Array();\n\t\t\tthis.queue = new EventQueue(this);\n\t\t\tthis.propertyIDs = new spine.IntSet();\n\t\t\tthis.animationsChanged = false;\n\t\t\tthis.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\n\t\t\tthis.data = data;\n\t\t}\n\t\tAnimationState.prototype.update = function (delta) {\n\t\t\tdelta *= this.timeScale;\n\t\t\tvar tracks = this.tracks;\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\n\t\t\t\tvar current = tracks[i];\n\t\t\t\tif (current == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tcurrent.animationLast = current.nextAnimationLast;\n\t\t\t\tcurrent.trackLast = current.nextTrackLast;\n\t\t\t\tvar currentDelta = delta * current.timeScale;\n\t\t\t\tif (current.delay > 0) {\n\t\t\t\t\tcurrent.delay -= currentDelta;\n\t\t\t\t\tif (current.delay > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcurrentDelta = -current.delay;\n\t\t\t\t\tcurrent.delay = 0;\n\t\t\t\t}\n\t\t\t\tvar next = current.next;\n\t\t\t\tif (next != null) {\n\t\t\t\t\tvar nextTime = current.trackLast - next.delay;\n\t\t\t\t\tif (nextTime >= 0) {\n\t\t\t\t\t\tnext.delay = 0;\n\t\t\t\t\t\tnext.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n\t\t\t\t\t\tcurrent.trackTime += currentDelta;\n\t\t\t\t\t\tthis.setCurrent(i, next, true);\n\t\t\t\t\t\twhile (next.mixingFrom != null) {\n\t\t\t\t\t\t\tnext.mixTime += delta;\n\t\t\t\t\t\t\tnext = next.mixingFrom;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n\t\t\t\t\ttracks[i] = null;\n\t\t\t\t\tthis.queue.end(current);\n\t\t\t\t\tthis.disposeNext(current);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n\t\t\t\t\tvar from = current.mixingFrom;\n\t\t\t\t\tcurrent.mixingFrom = null;\n\t\t\t\t\tif (from != null)\n\t\t\t\t\t\tfrom.mixingTo = null;\n\t\t\t\t\twhile (from != null) {\n\t\t\t\t\t\tthis.queue.end(from);\n\t\t\t\t\t\tfrom = from.mixingFrom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent.trackTime += currentDelta;\n\t\t\t}\n\t\t\tthis.queue.drain();\n\t\t};\n\t\tAnimationState.prototype.updateMixingFrom = function (to, delta) {\n\t\t\tvar from = to.mixingFrom;\n\t\t\tif (from == null)\n\t\t\t\treturn true;\n\t\t\tvar finished = this.updateMixingFrom(from, delta);\n\t\t\tfrom.animationLast = from.nextAnimationLast;\n\t\t\tfrom.trackLast = from.nextTrackLast;\n\t\t\tif (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n\t\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0) {\n\t\t\t\t\tto.mixingFrom = from.mixingFrom;\n\t\t\t\t\tif (from.mixingFrom != null)\n\t\t\t\t\t\tfrom.mixingFrom.mixingTo = to;\n\t\t\t\t\tto.interruptAlpha = from.interruptAlpha;\n\t\t\t\t\tthis.queue.end(from);\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t}\n\t\t\tfrom.trackTime += delta * from.timeScale;\n\t\t\tto.mixTime += delta;\n\t\t\treturn false;\n\t\t};\n\t\tAnimationState.prototype.apply = function (skeleton) {\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tif (this.animationsChanged)\n\t\t\t\tthis._animationsChanged();\n\t\t\tvar events = this.events;\n\t\t\tvar tracks = this.tracks;\n\t\t\tvar applied = false;\n\t\t\tfor (var i_16 = 0, n_1 = tracks.length; i_16 < n_1; i_16++) {\n\t\t\t\tvar current = tracks[i_16];\n\t\t\t\tif (current == null || current.delay > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tapplied = true;\n\t\t\t\tvar blend = i_16 == 0 ? spine.MixBlend.first : current.mixBlend;\n\t\t\t\tvar mix = current.alpha;\n\t\t\t\tif (current.mixingFrom != null)\n\t\t\t\t\tmix *= this.applyMixingFrom(current, skeleton, blend);\n\t\t\t\telse if (current.trackTime >= current.trackEnd && current.next == null)\n\t\t\t\t\tmix = 0;\n\t\t\t\tvar animationLast = current.animationLast, animationTime = current.getAnimationTime();\n\t\t\t\tvar timelineCount = current.animation.timelines.length;\n\t\t\t\tvar timelines = current.animation.timelines;\n\t\t\t\tif ((i_16 == 0 && mix == 1) || blend == spine.MixBlend.add) {\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++) {\n\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(mix, blend);\n\t\t\t\t\t\tvar timeline = timelines[ii];\n\t\t\t\t\t\tif (timeline instanceof spine.AttachmentTimeline)\n\t\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection.mixIn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar timelineMode = current.timelineMode;\n\t\t\t\t\tvar firstFrame = current.timelinesRotation.length == 0;\n\t\t\t\t\tif (firstFrame)\n\t\t\t\t\t\tspine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n\t\t\t\t\tvar timelinesRotation = current.timelinesRotation;\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++) {\n\t\t\t\t\t\tvar timeline_1 = timelines[ii];\n\t\t\t\t\t\tvar timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;\n\t\t\t\t\t\tif (timeline_1 instanceof spine.RotateTimeline) {\n\t\t\t\t\t\t\tthis.applyRotateTimeline(timeline_1, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (timeline_1 instanceof spine.AttachmentTimeline) {\n\t\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline_1, skeleton, animationTime, blend, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(mix, blend);\n\t\t\t\t\t\t\ttimeline_1.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection.mixIn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.queueEvents(current, animationTime);\n\t\t\t\tevents.length = 0;\n\t\t\t\tcurrent.nextAnimationLast = animationTime;\n\t\t\t\tcurrent.nextTrackLast = current.trackTime;\n\t\t\t}\n\t\t\tvar setupState = this.unkeyedState + AnimationState.SETUP;\n\t\t\tvar slots = skeleton.slots;\n\t\t\tfor (var i = 0, n = skeleton.slots.length; i < n; i++) {\n\t\t\t\tvar slot = slots[i];\n\t\t\t\tif (slot.attachmentState == setupState) {\n\t\t\t\t\tvar attachmentName = slot.data.attachmentName;\n\t\t\t\t\tslot.attachment = (attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.unkeyedState += 2;\n\t\t\tthis.queue.drain();\n\t\t\treturn applied;\n\t\t};\n\t\tAnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\n\t\t\tvar from = to.mixingFrom;\n\t\t\tif (from.mixingFrom != null)\n\t\t\t\tthis.applyMixingFrom(from, skeleton, blend);\n\t\t\tvar mix = 0;\n\t\t\tif (to.mixDuration == 0) {\n\t\t\t\tmix = 1;\n\t\t\t\tif (blend == spine.MixBlend.first)\n\t\t\t\t\tblend = spine.MixBlend.setup;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmix = to.mixTime / to.mixDuration;\n\t\t\t\tif (mix > 1)\n\t\t\t\t\tmix = 1;\n\t\t\t\tif (blend != spine.MixBlend.first)\n\t\t\t\t\tblend = from.mixBlend;\n\t\t\t}\n\t\t\tvar events = mix < from.eventThreshold ? this.events : null;\n\t\t\tvar attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\n\t\t\tvar animationLast = from.animationLast, animationTime = from.getAnimationTime();\n\t\t\tvar timelineCount = from.animation.timelines.length;\n\t\t\tvar timelines = from.animation.timelines;\n\t\t\tvar alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\n\t\t\tif (blend == spine.MixBlend.add) {\n\t\t\t\tfor (var i = 0; i < timelineCount; i++)\n\t\t\t\t\ttimelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.mixOut);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar timelineMode = from.timelineMode;\n\t\t\t\tvar timelineHoldMix = from.timelineHoldMix;\n\t\t\t\tvar firstFrame = from.timelinesRotation.length == 0;\n\t\t\t\tif (firstFrame)\n\t\t\t\t\tspine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n\t\t\t\tvar timelinesRotation = from.timelinesRotation;\n\t\t\t\tfrom.totalAlpha = 0;\n\t\t\t\tfor (var i = 0; i < timelineCount; i++) {\n\t\t\t\t\tvar timeline = timelines[i];\n\t\t\t\t\tvar direction = spine.MixDirection.mixOut;\n\t\t\t\t\tvar timelineBlend = void 0;\n\t\t\t\t\tvar alpha = 0;\n\t\t\t\t\tswitch (timelineMode[i]) {\n\t\t\t\t\t\tcase AnimationState.SUBSEQUENT:\n\t\t\t\t\t\t\tif (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\ttimelineBlend = blend;\n\t\t\t\t\t\t\talpha = alphaMix;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AnimationState.FIRST:\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\n\t\t\t\t\t\t\talpha = alphaMix;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AnimationState.HOLD_SUBSEQUENT:\n\t\t\t\t\t\t\ttimelineBlend = blend;\n\t\t\t\t\t\t\talpha = alphaHold;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase AnimationState.HOLD_FIRST:\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\n\t\t\t\t\t\t\talpha = alphaHold;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\n\t\t\t\t\t\t\tvar holdMix = timelineHoldMix[i];\n\t\t\t\t\t\t\talpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfrom.totalAlpha += alpha;\n\t\t\t\t\tif (timeline instanceof spine.RotateTimeline)\n\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n\t\t\t\t\telse if (timeline instanceof spine.AttachmentTimeline)\n\t\t\t\t\t\tthis.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n\t\t\t\t\telse {\n\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(alpha, blend);\n\t\t\t\t\t\tif (drawOrder && timeline instanceof spine.DrawOrderTimeline && timelineBlend == spine.MixBlend.setup)\n\t\t\t\t\t\t\tdirection = spine.MixDirection.mixIn;\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (to.mixDuration > 0)\n\t\t\t\tthis.queueEvents(from, animationTime);\n\t\t\tthis.events.length = 0;\n\t\t\tfrom.nextAnimationLast = animationTime;\n\t\t\tfrom.nextTrackLast = from.trackTime;\n\t\t\treturn mix;\n\t\t};\n\t\tAnimationState.prototype.applyAttachmentTimeline = function (timeline, skeleton, time, blend, attachments) {\n\t\t\tvar slot = skeleton.slots[timeline.slotIndex];\n\t\t\tif (!slot.bone.active)\n\t\t\t\treturn;\n\t\t\tvar frames = timeline.frames;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tif (blend == spine.MixBlend.setup || blend == spine.MixBlend.first)\n\t\t\t\t\tthis.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar frameIndex;\n\t\t\t\tif (time >= frames[frames.length - 1])\n\t\t\t\t\tframeIndex = frames.length - 1;\n\t\t\t\telse\n\t\t\t\t\tframeIndex = spine.Animation.binarySearch(frames, time) - 1;\n\t\t\t\tthis.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n\t\t\t}\n\t\t\tif (slot.attachmentState <= this.unkeyedState)\n\t\t\t\tslot.attachmentState = this.unkeyedState + AnimationState.SETUP;\n\t\t};\n\t\tAnimationState.prototype.setAttachment = function (skeleton, slot, attachmentName, attachments) {\n\t\t\tslot.attachment = attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName);\n\t\t\tif (attachments)\n\t\t\t\tslot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\n\t\t};\n\t\tAnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n\t\t\tif (firstFrame)\n\t\t\t\ttimelinesRotation[i] = 0;\n\t\t\tif (alpha == 1) {\n\t\t\t\ttimeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection.mixIn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar rotateTimeline = timeline;\n\t\t\tvar frames = rotateTimeline.frames;\n\t\t\tvar bone = skeleton.bones[rotateTimeline.boneIndex];\n\t\t\tif (!bone.active)\n\t\t\t\treturn;\n\t\t\tvar r1 = 0, r2 = 0;\n\t\t\tif (time < frames[0]) {\n\t\t\t\tswitch (blend) {\n\t\t\t\t\tcase spine.MixBlend.setup:\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase spine.MixBlend.first:\n\t\t\t\t\t\tr1 = bone.rotation;\n\t\t\t\t\t\tr2 = bone.data.rotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;\n\t\t\t\tif (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\n\t\t\t\t\tr2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\n\t\t\t\telse {\n\t\t\t\t\tvar frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\n\t\t\t\t\tvar prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\n\t\t\t\t\tvar frameTime = frames[frame];\n\t\t\t\t\tvar percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\n\t\t\t\t\tr2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\n\t\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n\t\t\t\t\tr2 = prevRotation + r2 * percent + bone.data.rotation;\n\t\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar total = 0, diff = r2 - r1;\n\t\t\tdiff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n\t\t\tif (diff == 0) {\n\t\t\t\ttotal = timelinesRotation[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar lastTotal = 0, lastDiff = 0;\n\t\t\t\tif (firstFrame) {\n\t\t\t\t\tlastTotal = 0;\n\t\t\t\t\tlastDiff = diff;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlastTotal = timelinesRotation[i];\n\t\t\t\t\tlastDiff = timelinesRotation[i + 1];\n\t\t\t\t}\n\t\t\t\tvar current = diff > 0, dir = lastTotal >= 0;\n\t\t\t\tif (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n\t\t\t\t\tif (Math.abs(lastTotal) > 180)\n\t\t\t\t\t\tlastTotal += 360 * spine.MathUtils.signum(lastTotal);\n\t\t\t\t\tdir = current;\n\t\t\t\t}\n\t\t\t\ttotal = diff + lastTotal - lastTotal % 360;\n\t\t\t\tif (dir != current)\n\t\t\t\t\ttotal += 360 * spine.MathUtils.signum(lastTotal);\n\t\t\t\ttimelinesRotation[i] = total;\n\t\t\t}\n\t\t\ttimelinesRotation[i + 1] = diff;\n\t\t\tr1 += total * alpha;\n\t\t\tbone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n\t\t};\n\t\tAnimationState.prototype.queueEvents = function (entry, animationTime) {\n\t\t\tvar animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n\t\t\tvar duration = animationEnd - animationStart;\n\t\t\tvar trackLastWrapped = entry.trackLast % duration;\n\t\t\tvar events = this.events;\n\t\t\tvar i = 0, n = events.length;\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tvar event_1 = events[i];\n\t\t\t\tif (event_1.time < trackLastWrapped)\n\t\t\t\t\tbreak;\n\t\t\t\tif (event_1.time > animationEnd)\n\t\t\t\t\tcontinue;\n\t\t\t\tthis.queue.event(entry, event_1);\n\t\t\t}\n\t\t\tvar complete = false;\n\t\t\tif (entry.loop)\n\t\t\t\tcomplete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n\t\t\telse\n\t\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n\t\t\tif (complete)\n\t\t\t\tthis.queue.complete(entry);\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tvar event_2 = events[i];\n\t\t\t\tif (event_2.time < animationStart)\n\t\t\t\t\tcontinue;\n\t\t\t\tthis.queue.event(entry, events[i]);\n\t\t\t}\n\t\t};\n\t\tAnimationState.prototype.clearTracks = function () {\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\n\t\t\tthis.queue.drainDisabled = true;\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++)\n\t\t\t\tthis.clearTrack(i);\n\t\t\tthis.tracks.length = 0;\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\n\t\t\tthis.queue.drain();\n\t\t};\n\t\tAnimationState.prototype.clearTrack = function (trackIndex) {\n\t\t\tif (trackIndex >= this.tracks.length)\n\t\t\t\treturn;\n\t\t\tvar current = this.tracks[trackIndex];\n\t\t\tif (current == null)\n\t\t\t\treturn;\n\t\t\tthis.queue.end(current);\n\t\t\tthis.disposeNext(current);\n\t\t\tvar entry = current;\n\t\t\twhile (true) {\n\t\t\t\tvar from = entry.mixingFrom;\n\t\t\t\tif (from == null)\n\t\t\t\t\tbreak;\n\t\t\t\tthis.queue.end(from);\n\t\t\t\tentry.mixingFrom = null;\n\t\t\t\tentry.mixingTo = null;\n\t\t\t\tentry = from;\n\t\t\t}\n\t\t\tthis.tracks[current.trackIndex] = null;\n\t\t\tthis.queue.drain();\n\t\t};\n\t\tAnimationState.prototype.setCurrent = function (index, current, interrupt) {\n\t\t\tvar from = this.expandToIndex(index);\n\t\t\tthis.tracks[index] = current;\n\t\t\tif (from != null) {\n\t\t\t\tif (interrupt)\n\t\t\t\t\tthis.queue.interrupt(from);\n\t\t\t\tcurrent.mixingFrom = from;\n\t\t\t\tfrom.mixingTo = current;\n\t\t\t\tcurrent.mixTime = 0;\n\t\t\t\tif (from.mixingFrom != null && from.mixDuration > 0)\n\t\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\t\t\t\tfrom.timelinesRotation.length = 0;\n\t\t\t}\n\t\t\tthis.queue.start(current);\n\t\t};\n\t\tAnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\n\t\t\tif (animation == null)\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\n\t\t\treturn this.setAnimationWith(trackIndex, animation, loop);\n\t\t};\n\t\tAnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\n\t\t\tif (animation == null)\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\n\t\t\tvar interrupt = true;\n\t\t\tvar current = this.expandToIndex(trackIndex);\n\t\t\tif (current != null) {\n\t\t\t\tif (current.nextTrackLast == -1) {\n\t\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\n\t\t\t\t\tthis.queue.interrupt(current);\n\t\t\t\t\tthis.queue.end(current);\n\t\t\t\t\tthis.disposeNext(current);\n\t\t\t\t\tcurrent = current.mixingFrom;\n\t\t\t\t\tinterrupt = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthis.disposeNext(current);\n\t\t\t}\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, current);\n\t\t\tthis.setCurrent(trackIndex, entry, interrupt);\n\t\t\tthis.queue.drain();\n\t\t\treturn entry;\n\t\t};\n\t\tAnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\n\t\t\tif (animation == null)\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\n\t\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\n\t\t};\n\t\tAnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\n\t\t\tif (animation == null)\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\n\t\t\tvar last = this.expandToIndex(trackIndex);\n\t\t\tif (last != null) {\n\t\t\t\twhile (last.next != null)\n\t\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, last);\n\t\t\tif (last == null) {\n\t\t\t\tthis.setCurrent(trackIndex, entry, true);\n\t\t\t\tthis.queue.drain();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlast.next = entry;\n\t\t\t\tif (delay <= 0) {\n\t\t\t\t\tvar duration = last.animationEnd - last.animationStart;\n\t\t\t\t\tif (duration != 0) {\n\t\t\t\t\t\tif (last.loop)\n\t\t\t\t\t\t\tdelay += duration * (1 + ((last.trackTime / duration) | 0));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdelay += Math.max(duration, last.trackTime);\n\t\t\t\t\t\tdelay -= this.data.getMix(last.animation, animation);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdelay = last.trackTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.delay = delay;\n\t\t\treturn entry;\n\t\t};\n\t\tAnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\n\t\t\tvar entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n\t\t\tentry.mixDuration = mixDuration;\n\t\t\tentry.trackEnd = mixDuration;\n\t\t\treturn entry;\n\t\t};\n\t\tAnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\n\t\t\tif (delay <= 0)\n\t\t\t\tdelay -= mixDuration;\n\t\t\tvar entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n\t\t\tentry.mixDuration = mixDuration;\n\t\t\tentry.trackEnd = mixDuration;\n\t\t\treturn entry;\n\t\t};\n\t\tAnimationState.prototype.setEmptyAnimations = function (mixDuration) {\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\n\t\t\tthis.queue.drainDisabled = true;\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\n\t\t\t\tvar current = this.tracks[i];\n\t\t\t\tif (current != null)\n\t\t\t\t\tthis.setEmptyAnimation(current.trackIndex, mixDuration);\n\t\t\t}\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\n\t\t\tthis.queue.drain();\n\t\t};\n\t\tAnimationState.prototype.expandToIndex = function (index) {\n\t\t\tif (index < this.tracks.length)\n\t\t\t\treturn this.tracks[index];\n\t\t\tspine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n\t\t\tthis.tracks.length = index + 1;\n\t\t\treturn null;\n\t\t};\n\t\tAnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\n\t\t\tvar entry = this.trackEntryPool.obtain();\n\t\t\tentry.trackIndex = trackIndex;\n\t\t\tentry.animation = animation;\n\t\t\tentry.loop = loop;\n\t\t\tentry.holdPrevious = false;\n\t\t\tentry.eventThreshold = 0;\n\t\t\tentry.attachmentThreshold = 0;\n\t\t\tentry.drawOrderThreshold = 0;\n\t\t\tentry.animationStart = 0;\n\t\t\tentry.animationEnd = animation.duration;\n\t\t\tentry.animationLast = -1;\n\t\t\tentry.nextAnimationLast = -1;\n\t\t\tentry.delay = 0;\n\t\t\tentry.trackTime = 0;\n\t\t\tentry.trackLast = -1;\n\t\t\tentry.nextTrackLast = -1;\n\t\t\tentry.trackEnd = Number.MAX_VALUE;\n\t\t\tentry.timeScale = 1;\n\t\t\tentry.alpha = 1;\n\t\t\tentry.interruptAlpha = 1;\n\t\t\tentry.mixTime = 0;\n\t\t\tentry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n\t\t\tentry.mixBlend = spine.MixBlend.replace;\n\t\t\treturn entry;\n\t\t};\n\t\tAnimationState.prototype.disposeNext = function (entry) {\n\t\t\tvar next = entry.next;\n\t\t\twhile (next != null) {\n\t\t\t\tthis.queue.dispose(next);\n\t\t\t\tnext = next.next;\n\t\t\t}\n\t\t\tentry.next = null;\n\t\t};\n\t\tAnimationState.prototype._animationsChanged = function () {\n\t\t\tthis.animationsChanged = false;\n\t\t\tthis.propertyIDs.clear();\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\n\t\t\t\tvar entry = this.tracks[i];\n\t\t\t\tif (entry == null)\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (entry.mixingFrom != null)\n\t\t\t\t\tentry = entry.mixingFrom;\n\t\t\t\tdo {\n\t\t\t\t\tif (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add)\n\t\t\t\t\t\tthis.computeHold(entry);\n\t\t\t\t\tentry = entry.mixingTo;\n\t\t\t\t} while (entry != null);\n\t\t\t}\n\t\t};\n\t\tAnimationState.prototype.computeHold = function (entry) {\n\t\t\tvar to = entry.mixingTo;\n\t\t\tvar timelines = entry.animation.timelines;\n\t\t\tvar timelinesCount = entry.animation.timelines.length;\n\t\t\tvar timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);\n\t\t\tentry.timelineHoldMix.length = 0;\n\t\t\tvar timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n\t\t\tvar propertyIDs = this.propertyIDs;\n\t\t\tif (to != null && to.holdPrevious) {\n\t\t\t\tfor (var i = 0; i < timelinesCount; i++) {\n\t\t\t\t\ttimelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\touter: for (var i = 0; i < timelinesCount; i++) {\n\t\t\t\tvar timeline = timelines[i];\n\t\t\t\tvar id = timeline.getPropertyId();\n\t\t\t\tif (!propertyIDs.add(id))\n\t\t\t\t\ttimelineMode[i] = AnimationState.SUBSEQUENT;\n\t\t\t\telse if (to == null || timeline instanceof spine.AttachmentTimeline || timeline instanceof spine.DrawOrderTimeline\n\t\t\t\t\t|| timeline instanceof spine.EventTimeline || !to.animation.hasTimeline(id)) {\n\t\t\t\t\ttimelineMode[i] = AnimationState.FIRST;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (var next = to.mixingTo; next != null; next = next.mixingTo) {\n\t\t\t\t\t\tif (next.animation.hasTimeline(id))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (entry.mixDuration > 0) {\n\t\t\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD_MIX;\n\t\t\t\t\t\t\ttimelineDipMix[i] = next;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD_FIRST;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tAnimationState.prototype.getCurrent = function (trackIndex) {\n\t\t\tif (trackIndex >= this.tracks.length)\n\t\t\t\treturn null;\n\t\t\treturn this.tracks[trackIndex];\n\t\t};\n\t\tAnimationState.prototype.addListener = function (listener) {\n\t\t\tif (listener == null)\n\t\t\t\tthrow new Error(\"listener cannot be null.\");\n\t\t\tthis.listeners.push(listener);\n\t\t};\n\t\tAnimationState.prototype.removeListener = function (listener) {\n\t\t\tvar index = this.listeners.indexOf(listener);\n\t\t\tif (index >= 0)\n\t\t\t\tthis.listeners.splice(index, 1);\n\t\t};\n\t\tAnimationState.prototype.clearListeners = function () {\n\t\t\tthis.listeners.length = 0;\n\t\t};\n\t\tAnimationState.prototype.clearListenerNotifications = function () {\n\t\t\tthis.queue.clear();\n\t\t};\n\t\tAnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\n\t\tAnimationState.SUBSEQUENT = 0;\n\t\tAnimationState.FIRST = 1;\n\t\tAnimationState.HOLD_SUBSEQUENT = 2;\n\t\tAnimationState.HOLD_FIRST = 3;\n\t\tAnimationState.HOLD_MIX = 4;\n\t\tAnimationState.SETUP = 1;\n\t\tAnimationState.CURRENT = 2;\n\t\treturn AnimationState;\n\t}());\n\tspine.AnimationState = AnimationState;\n\tvar TrackEntry = (function () {\n\t\tfunction TrackEntry() {\n\t\t\tthis.mixBlend = spine.MixBlend.replace;\n\t\t\tthis.timelineMode = new Array();\n\t\t\tthis.timelineHoldMix = new Array();\n\t\t\tthis.timelinesRotation = new Array();\n\t\t}\n\t\tTrackEntry.prototype.reset = function () {\n\t\t\tthis.next = null;\n\t\t\tthis.mixingFrom = null;\n\t\t\tthis.mixingTo = null;\n\t\t\tthis.animation = null;\n\t\t\tthis.listener = null;\n\t\t\tthis.timelineMode.length = 0;\n\t\t\tthis.timelineHoldMix.length = 0;\n\t\t\tthis.timelinesRotation.length = 0;\n\t\t};\n\t\tTrackEntry.prototype.getAnimationTime = function () {\n\t\t\tif (this.loop) {\n\t\t\t\tvar duration = this.animationEnd - this.animationStart;\n\t\t\t\tif (duration == 0)\n\t\t\t\t\treturn this.animationStart;\n\t\t\t\treturn (this.trackTime % duration) + this.animationStart;\n\t\t\t}\n\t\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\n\t\t};\n\t\tTrackEntry.prototype.setAnimationLast = function (animationLast) {\n\t\t\tthis.animationLast = animationLast;\n\t\t\tthis.nextAnimationLast = animationLast;\n\t\t};\n\t\tTrackEntry.prototype.isComplete = function () {\n\t\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\n\t\t};\n\t\tTrackEntry.prototype.resetRotationDirections = function () {\n\t\t\tthis.timelinesRotation.length = 0;\n\t\t};\n\t\treturn TrackEntry;\n\t}());\n\tspine.TrackEntry = TrackEntry;\n\tvar EventQueue = (function () {\n\t\tfunction EventQueue(animState) {\n\t\t\tthis.objects = [];\n\t\t\tthis.drainDisabled = false;\n\t\t\tthis.animState = animState;\n\t\t}\n\t\tEventQueue.prototype.start = function (entry) {\n\t\t\tthis.objects.push(EventType.start);\n\t\t\tthis.objects.push(entry);\n\t\t\tthis.animState.animationsChanged = true;\n\t\t};\n\t\tEventQueue.prototype.interrupt = function (entry) {\n\t\t\tthis.objects.push(EventType.interrupt);\n\t\t\tthis.objects.push(entry);\n\t\t};\n\t\tEventQueue.prototype.end = function (entry) {\n\t\t\tthis.objects.push(EventType.end);\n\t\t\tthis.objects.push(entry);\n\t\t\tthis.animState.animationsChanged = true;\n\t\t};\n\t\tEventQueue.prototype.dispose = function (entry) {\n\t\t\tthis.objects.push(EventType.dispose);\n\t\t\tthis.objects.push(entry);\n\t\t};\n\t\tEventQueue.prototype.complete = function (entry) {\n\t\t\tthis.objects.push(EventType.complete);\n\t\t\tthis.objects.push(entry);\n\t\t};\n\t\tEventQueue.prototype.event = function (entry, event) {\n\t\t\tthis.objects.push(EventType.event);\n\t\t\tthis.objects.push(entry);\n\t\t\tthis.objects.push(event);\n\t\t};\n\t\tEventQueue.prototype.drain = function () {\n\t\t\tif (this.drainDisabled)\n\t\t\t\treturn;\n\t\t\tthis.drainDisabled = true;\n\t\t\tvar objects = this.objects;\n\t\t\tvar listeners = this.animState.listeners;\n\t\t\tfor (var i = 0; i < objects.length; i += 2) {\n\t\t\t\tvar type = objects[i];\n\t\t\t\tvar entry = objects[i + 1];\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase EventType.start:\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.start)\n\t\t\t\t\t\t\tentry.listener.start(entry);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].start)\n\t\t\t\t\t\t\t\tlisteners[ii].start(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EventType.interrupt:\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.interrupt)\n\t\t\t\t\t\t\tentry.listener.interrupt(entry);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].interrupt)\n\t\t\t\t\t\t\t\tlisteners[ii].interrupt(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EventType.end:\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.end)\n\t\t\t\t\t\t\tentry.listener.end(entry);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].end)\n\t\t\t\t\t\t\t\tlisteners[ii].end(entry);\n\t\t\t\t\tcase EventType.dispose:\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.dispose)\n\t\t\t\t\t\t\tentry.listener.dispose(entry);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].dispose)\n\t\t\t\t\t\t\t\tlisteners[ii].dispose(entry);\n\t\t\t\t\t\tthis.animState.trackEntryPool.free(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EventType.complete:\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.complete)\n\t\t\t\t\t\t\tentry.listener.complete(entry);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].complete)\n\t\t\t\t\t\t\t\tlisteners[ii].complete(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EventType.event:\n\t\t\t\t\t\tvar event_3 = objects[i++ + 2];\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.event)\n\t\t\t\t\t\t\tentry.listener.event(entry, event_3);\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\n\t\t\t\t\t\t\tif (listeners[ii].event)\n\t\t\t\t\t\t\t\tlisteners[ii].event(entry, event_3);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.clear();\n\t\t\tthis.drainDisabled = false;\n\t\t};\n\t\tEventQueue.prototype.clear = function () {\n\t\t\tthis.objects.length = 0;\n\t\t};\n\t\treturn EventQueue;\n\t}());\n\tspine.EventQueue = EventQueue;\n\tvar EventType;\n\t(function (EventType) {\n\t\tEventType[EventType[\"start\"] = 0] = \"start\";\n\t\tEventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\n\t\tEventType[EventType[\"end\"] = 2] = \"end\";\n\t\tEventType[EventType[\"dispose\"] = 3] = \"dispose\";\n\t\tEventType[EventType[\"complete\"] = 4] = \"complete\";\n\t\tEventType[EventType[\"event\"] = 5] = \"event\";\n\t})(EventType = spine.EventType || (spine.EventType = {}));\n\tvar AnimationStateAdapter = (function () {\n\t\tfunction AnimationStateAdapter() {\n\t\t}\n\t\tAnimationStateAdapter.prototype.start = function (entry) {\n\t\t};\n\t\tAnimationStateAdapter.prototype.interrupt = function (entry) {\n\t\t};\n\t\tAnimationStateAdapter.prototype.end = function (entry) {\n\t\t};\n\t\tAnimationStateAdapter.prototype.dispose = function (entry) {\n\t\t};\n\t\tAnimationStateAdapter.prototype.complete = function (entry) {\n\t\t};\n\t\tAnimationStateAdapter.prototype.event = function (entry, event) {\n\t\t};\n\t\treturn AnimationStateAdapter;\n\t}());\n\tspine.AnimationStateAdapter = AnimationStateAdapter;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar AnimationStateData = (function () {\n\t\tfunction AnimationStateData(skeletonData) {\n\t\t\tthis.animationToMixTime = {};\n\t\t\tthis.defaultMix = 0;\n\t\t\tif (skeletonData == null)\n\t\t\t\tthrow new Error(\"skeletonData cannot be null.\");\n\t\t\tthis.skeletonData = skeletonData;\n\t\t}\n\t\tAnimationStateData.prototype.setMix = function (fromName, toName, duration) {\n\t\t\tvar from = this.skeletonData.findAnimation(fromName);\n\t\t\tif (from == null)\n\t\t\t\tthrow new Error(\"Animation not found: \" + fromName);\n\t\t\tvar to = this.skeletonData.findAnimation(toName);\n\t\t\tif (to == null)\n\t\t\t\tthrow new Error(\"Animation not found: \" + toName);\n\t\t\tthis.setMixWith(from, to, duration);\n\t\t};\n\t\tAnimationStateData.prototype.setMixWith = function (from, to, duration) {\n\t\t\tif (from == null)\n\t\t\t\tthrow new Error(\"from cannot be null.\");\n\t\t\tif (to == null)\n\t\t\t\tthrow new Error(\"to cannot be null.\");\n\t\t\tvar key = from.name + \".\" + to.name;\n\t\t\tthis.animationToMixTime[key] = duration;\n\t\t};\n\t\tAnimationStateData.prototype.getMix = function (from, to) {\n\t\t\tvar key = from.name + \".\" + to.name;\n\t\t\tvar value = this.animationToMixTime[key];\n\t\t\treturn value === undefined ? this.defaultMix : value;\n\t\t};\n\t\treturn AnimationStateData;\n\t}());\n\tspine.AnimationStateData = AnimationStateData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar AssetManager = (function () {\n\t\tfunction AssetManager(textureLoader, pathPrefix) {\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\n\t\t\tthis.assets = {};\n\t\t\tthis.errors = {};\n\t\t\tthis.toLoad = 0;\n\t\t\tthis.loaded = 0;\n\t\t\tthis.rawDataUris = {};\n\t\t\tthis.textureLoader = textureLoader;\n\t\t\tthis.pathPrefix = pathPrefix;\n\t\t}\n\t\tAssetManager.prototype.downloadText = function (url, success, error) {\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.overrideMimeType(\"text/html\");\n\t\t\tif (this.rawDataUris[url])\n\t\t\t\turl = this.rawDataUris[url];\n\t\t\trequest.open(\"GET\", url, true);\n\t\t\trequest.onload = function () {\n\t\t\t\tif (request.status == 200) {\n\t\t\t\t\tsuccess(request.responseText);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\terror(request.status, request.responseText);\n\t\t\t\t}\n\t\t\t};\n\t\t\trequest.onerror = function () {\n\t\t\t\terror(request.status, request.responseText);\n\t\t\t};\n\t\t\trequest.send();\n\t\t};\n\t\tAssetManager.prototype.downloadBinary = function (url, success, error) {\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\tif (this.rawDataUris[url])\n\t\t\t\turl = this.rawDataUris[url];\n\t\t\trequest.open(\"GET\", url, true);\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.onload = function () {\n\t\t\t\tif (request.status == 200) {\n\t\t\t\t\tsuccess(new Uint8Array(request.response));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\terror(request.status, request.responseText);\n\t\t\t\t}\n\t\t\t};\n\t\t\trequest.onerror = function () {\n\t\t\t\terror(request.status, request.responseText);\n\t\t\t};\n\t\t\trequest.send();\n\t\t};\n\t\tAssetManager.prototype.setRawDataURI = function (path, data) {\n\t\t\tthis.rawDataUris[this.pathPrefix + path] = data;\n\t\t};\n\t\tAssetManager.prototype.loadBinary = function (path, success, error) {\n\t\t\tvar _this = this;\n\t\t\tif (success === void 0) { success = null; }\n\t\t\tif (error === void 0) { error = null; }\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tthis.toLoad++;\n\t\t\tthis.downloadBinary(path, function (data) {\n\t\t\t\t_this.assets[path] = data;\n\t\t\t\tif (success)\n\t\t\t\t\tsuccess(path, data);\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t}, function (state, responseText) {\n\t\t\t\t_this.errors[path] = \"Couldn't load binary \" + path + \": status \" + status + \", \" + responseText;\n\t\t\t\tif (error)\n\t\t\t\t\terror(path, \"Couldn't load binary \" + path + \": status \" + status + \", \" + responseText);\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t});\n\t\t};\n\t\tAssetManager.prototype.loadText = function (path, success, error) {\n\t\t\tvar _this = this;\n\t\t\tif (success === void 0) { success = null; }\n\t\t\tif (error === void 0) { error = null; }\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tthis.toLoad++;\n\t\t\tthis.downloadText(path, function (data) {\n\t\t\t\t_this.assets[path] = data;\n\t\t\t\tif (success)\n\t\t\t\t\tsuccess(path, data);\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t}, function (state, responseText) {\n\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\n\t\t\t\tif (error)\n\t\t\t\t\terror(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t});\n\t\t};\n\t\tAssetManager.prototype.loadTexture = function (path, success, error) {\n\t\t\tvar _this = this;\n\t\t\tif (success === void 0) { success = null; }\n\t\t\tif (error === void 0) { error = null; }\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tvar storagePath = path;\n\t\t\tthis.toLoad++;\n\t\t\tvar img = new Image();\n\t\t\timg.crossOrigin = \"anonymous\";\n\t\t\timg.onload = function (ev) {\n\t\t\t\tvar texture = _this.textureLoader(img);\n\t\t\t\t_this.assets[storagePath] = texture;\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t\tif (success)\n\t\t\t\t\tsuccess(path, img);\n\t\t\t};\n\t\t\timg.onerror = function (ev) {\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t\tif (error)\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\n\t\t\t};\n\t\t\tif (this.rawDataUris[path])\n\t\t\t\tpath = this.rawDataUris[path];\n\t\t\timg.src = path;\n\t\t};\n\t\tAssetManager.prototype.loadTextureAtlas = function (path, success, error) {\n\t\t\tvar _this = this;\n\t\t\tif (success === void 0) { success = null; }\n\t\t\tif (error === void 0) { error = null; }\n\t\t\tvar parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tthis.toLoad++;\n\t\t\tthis.downloadText(path, function (atlasData) {\n\t\t\t\tvar pagesLoaded = { count: 0 };\n\t\t\t\tvar atlasPages = new Array();\n\t\t\t\ttry {\n\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\n\t\t\t\t\t\tatlasPages.push(parent == \"\" ? path : parent + \"/\" + path);\n\t\t\t\t\t\tvar image = document.createElement(\"img\");\n\t\t\t\t\t\timage.width = 16;\n\t\t\t\t\t\timage.height = 16;\n\t\t\t\t\t\treturn new spine.FakeTexture(image);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tvar ex = e;\n\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\n\t\t\t\t\tif (error)\n\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\n\t\t\t\t\t_this.toLoad--;\n\t\t\t\t\t_this.loaded++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar _loop_1 = function (atlasPage) {\n\t\t\t\t\tvar pageLoadError = false;\n\t\t\t\t\t_this.loadTexture(atlasPage, function (imagePath, image) {\n\t\t\t\t\t\tpagesLoaded.count++;\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\n\t\t\t\t\t\t\tif (!pageLoadError) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\n\t\t\t\t\t\t\t\t\t\treturn _this.get(parent == \"\" ? path : parent + \"/\" + path);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t_this.assets[path] = atlas;\n\t\t\t\t\t\t\t\t\tif (success)\n\t\t\t\t\t\t\t\t\t\tsuccess(path, atlas);\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\n\t\t\t\t\t\t\t\t\t_this.loaded++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\t\t\tvar ex = e;\n\t\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\n\t\t\t\t\t\t\t\t\tif (error)\n\t\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\n\t\t\t\t\t\t\t\t\t_this.loaded++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\n\t\t\t\t\t\t\t\tif (error)\n\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\n\t\t\t\t\t\t\t\t_this.toLoad--;\n\t\t\t\t\t\t\t\t_this.loaded++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, function (imagePath, errorMessage) {\n\t\t\t\t\t\tpageLoadError = true;\n\t\t\t\t\t\tpagesLoaded.count++;\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\n\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\n\t\t\t\t\t\t\tif (error)\n\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\n\t\t\t\t\t\t\t_this.toLoad--;\n\t\t\t\t\t\t\t_this.loaded++;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tfor (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\n\t\t\t\t\tvar atlasPage = atlasPages_1[_i];\n\t\t\t\t\t_loop_1(atlasPage);\n\t\t\t\t}\n\t\t\t}, function (state, responseText) {\n\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\n\t\t\t\tif (error)\n\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\n\t\t\t\t_this.toLoad--;\n\t\t\t\t_this.loaded++;\n\t\t\t});\n\t\t};\n\t\tAssetManager.prototype.get = function (path) {\n\t\t\tpath = this.pathPrefix + path;\n\t\t\treturn this.assets[path];\n\t\t};\n\t\tAssetManager.prototype.remove = function (path) {\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tvar asset = this.assets[path];\n\t\t\tif (asset.dispose)\n\t\t\t\tasset.dispose();\n\t\t\tthis.assets[path] = null;\n\t\t};\n\t\tAssetManager.prototype.removeAll = function () {\n\t\t\tfor (var key in this.assets) {\n\t\t\t\tvar asset = this.assets[key];\n\t\t\t\tif (asset.dispose)\n\t\t\t\t\tasset.dispose();\n\t\t\t}\n\t\t\tthis.assets = {};\n\t\t};\n\t\tAssetManager.prototype.isLoadingComplete = function () {\n\t\t\treturn this.toLoad == 0;\n\t\t};\n\t\tAssetManager.prototype.getToLoad = function () {\n\t\t\treturn this.toLoad;\n\t\t};\n\t\tAssetManager.prototype.getLoaded = function () {\n\t\t\treturn this.loaded;\n\t\t};\n\t\tAssetManager.prototype.dispose = function () {\n\t\t\tthis.removeAll();\n\t\t};\n\t\tAssetManager.prototype.hasErrors = function () {\n\t\t\treturn Object.keys(this.errors).length > 0;\n\t\t};\n\t\tAssetManager.prototype.getErrors = function () {\n\t\t\treturn this.errors;\n\t\t};\n\t\treturn AssetManager;\n\t}());\n\tspine.AssetManager = AssetManager;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar AtlasAttachmentLoader = (function () {\n\t\tfunction AtlasAttachmentLoader(atlas) {\n\t\t\tthis.atlas = atlas;\n\t\t}\n\t\tAtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\n\t\t\tvar region = this.atlas.findRegion(path);\n\t\t\tif (region == null)\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n\t\t\tregion.renderObject = region;\n\t\t\tvar attachment = new spine.RegionAttachment(name);\n\t\t\tattachment.setRegion(region);\n\t\t\treturn attachment;\n\t\t};\n\t\tAtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\n\t\t\tvar region = this.atlas.findRegion(path);\n\t\t\tif (region == null)\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n\t\t\tregion.renderObject = region;\n\t\t\tvar attachment = new spine.MeshAttachment(name);\n\t\t\tattachment.region = region;\n\t\t\treturn attachment;\n\t\t};\n\t\tAtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\n\t\t\treturn new spine.BoundingBoxAttachment(name);\n\t\t};\n\t\tAtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\n\t\t\treturn new spine.PathAttachment(name);\n\t\t};\n\t\tAtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\n\t\t\treturn new spine.PointAttachment(name);\n\t\t};\n\t\tAtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\n\t\t\treturn new spine.ClippingAttachment(name);\n\t\t};\n\t\treturn AtlasAttachmentLoader;\n\t}());\n\tspine.AtlasAttachmentLoader = AtlasAttachmentLoader;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar BlendMode;\n\t(function (BlendMode) {\n\t\tBlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n\t\tBlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\n\t\tBlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\n\t\tBlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\n\t})(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Bone = (function () {\n\t\tfunction Bone(data, skeleton, parent) {\n\t\t\tthis.children = new Array();\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.rotation = 0;\n\t\t\tthis.scaleX = 0;\n\t\t\tthis.scaleY = 0;\n\t\t\tthis.shearX = 0;\n\t\t\tthis.shearY = 0;\n\t\t\tthis.ax = 0;\n\t\t\tthis.ay = 0;\n\t\t\tthis.arotation = 0;\n\t\t\tthis.ascaleX = 0;\n\t\t\tthis.ascaleY = 0;\n\t\t\tthis.ashearX = 0;\n\t\t\tthis.ashearY = 0;\n\t\t\tthis.appliedValid = false;\n\t\t\tthis.a = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.c = 0;\n\t\t\tthis.d = 0;\n\t\t\tthis.worldY = 0;\n\t\t\tthis.worldX = 0;\n\t\t\tthis.sorted = false;\n\t\t\tthis.active = false;\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.skeleton = skeleton;\n\t\t\tthis.parent = parent;\n\t\t\tthis.setToSetupPose();\n\t\t}\n\t\tBone.prototype.isActive = function () {\n\t\t\treturn this.active;\n\t\t};\n\t\tBone.prototype.update = function () {\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n\t\t};\n\t\tBone.prototype.updateWorldTransform = function () {\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n\t\t};\n\t\tBone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\n\t\t\tthis.ax = x;\n\t\t\tthis.ay = y;\n\t\t\tthis.arotation = rotation;\n\t\t\tthis.ascaleX = scaleX;\n\t\t\tthis.ascaleY = scaleY;\n\t\t\tthis.ashearX = shearX;\n\t\t\tthis.ashearY = shearY;\n\t\t\tthis.appliedValid = true;\n\t\t\tvar parent = this.parent;\n\t\t\tif (parent == null) {\n\t\t\t\tvar skeleton = this.skeleton;\n\t\t\t\tvar rotationY = rotation + 90 + shearY;\n\t\t\t\tvar sx = skeleton.scaleX;\n\t\t\t\tvar sy = skeleton.scaleY;\n\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;\n\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;\n\t\t\t\tthis.worldX = x * sx + skeleton.x;\n\t\t\t\tthis.worldY = y * sy + skeleton.y;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\t\tthis.worldX = pa * x + pb * y + parent.worldX;\n\t\t\tthis.worldY = pc * x + pd * y + parent.worldY;\n\t\t\tswitch (this.data.transformMode) {\n\t\t\t\tcase spine.TransformMode.Normal: {\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\n\t\t\t\t\tthis.a = pa * la + pb * lc;\n\t\t\t\t\tthis.b = pa * lb + pb * ld;\n\t\t\t\t\tthis.c = pc * la + pd * lc;\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase spine.TransformMode.OnlyTranslation: {\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\n\t\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\n\t\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\n\t\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\n\t\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase spine.TransformMode.NoRotationOrReflection: {\n\t\t\t\t\tvar s = pa * pa + pc * pc;\n\t\t\t\t\tvar prx = 0;\n\t\t\t\t\tif (s > 0.0001) {\n\t\t\t\t\t\ts = Math.abs(pa * pd - pb * pc) / s;\n\t\t\t\t\t\tpa /= this.skeleton.scaleX;\n\t\t\t\t\t\tpc /= this.skeleton.scaleY;\n\t\t\t\t\t\tpb = pc * s;\n\t\t\t\t\t\tpd = pa * s;\n\t\t\t\t\t\tprx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpa = 0;\n\t\t\t\t\t\tpc = 0;\n\t\t\t\t\t\tprx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\n\t\t\t\t\t}\n\t\t\t\t\tvar rx = rotation + shearX - prx;\n\t\t\t\t\tvar ry = rotation + shearY - prx + 90;\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rx) * scaleX;\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(ry) * scaleY;\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rx) * scaleX;\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(ry) * scaleY;\n\t\t\t\t\tthis.a = pa * la - pb * lc;\n\t\t\t\t\tthis.b = pa * lb - pb * ld;\n\t\t\t\t\tthis.c = pc * la + pd * lc;\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase spine.TransformMode.NoScale:\n\t\t\t\tcase spine.TransformMode.NoScaleOrReflection: {\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(rotation);\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(rotation);\n\t\t\t\t\tvar za = (pa * cos + pb * sin) / this.skeleton.scaleX;\n\t\t\t\t\tvar zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\n\t\t\t\t\tvar s = Math.sqrt(za * za + zc * zc);\n\t\t\t\t\tif (s > 0.00001)\n\t\t\t\t\t\ts = 1 / s;\n\t\t\t\t\tza *= s;\n\t\t\t\t\tzc *= s;\n\t\t\t\t\ts = Math.sqrt(za * za + zc * zc);\n\t\t\t\t\tif (this.data.transformMode == spine.TransformMode.NoScale\n\t\t\t\t\t\t&& (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n\t\t\t\t\t\ts = -s;\n\t\t\t\t\tvar r = Math.PI / 2 + Math.atan2(zc, za);\n\t\t\t\t\tvar zb = Math.cos(r) * s;\n\t\t\t\t\tvar zd = Math.sin(r) * s;\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(shearX) * scaleX;\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(shearX) * scaleX;\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\n\t\t\t\t\tthis.a = za * la + zb * lc;\n\t\t\t\t\tthis.b = za * lb + zb * ld;\n\t\t\t\t\tthis.c = zc * la + zd * lc;\n\t\t\t\t\tthis.d = zc * lb + zd * ld;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.a *= this.skeleton.scaleX;\n\t\t\tthis.b *= this.skeleton.scaleX;\n\t\t\tthis.c *= this.skeleton.scaleY;\n\t\t\tthis.d *= this.skeleton.scaleY;\n\t\t};\n\t\tBone.prototype.setToSetupPose = function () {\n\t\t\tvar data = this.data;\n\t\t\tthis.x = data.x;\n\t\t\tthis.y = data.y;\n\t\t\tthis.rotation = data.rotation;\n\t\t\tthis.scaleX = data.scaleX;\n\t\t\tthis.scaleY = data.scaleY;\n\t\t\tthis.shearX = data.shearX;\n\t\t\tthis.shearY = data.shearY;\n\t\t};\n\t\tBone.prototype.getWorldRotationX = function () {\n\t\t\treturn Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\n\t\t};\n\t\tBone.prototype.getWorldRotationY = function () {\n\t\t\treturn Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\n\t\t};\n\t\tBone.prototype.getWorldScaleX = function () {\n\t\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\n\t\t};\n\t\tBone.prototype.getWorldScaleY = function () {\n\t\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\n\t\t};\n\t\tBone.prototype.updateAppliedTransform = function () {\n\t\t\tthis.appliedValid = true;\n\t\t\tvar parent = this.parent;\n\t\t\tif (parent == null) {\n\t\t\t\tthis.ax = this.worldX;\n\t\t\t\tthis.ay = this.worldY;\n\t\t\t\tthis.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\n\t\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\n\t\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\n\t\t\t\tthis.ashearX = 0;\n\t\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n\t\t\tvar pid = 1 / (pa * pd - pb * pc);\n\t\t\tvar dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\n\t\t\tthis.ax = (dx * pd * pid - dy * pb * pid);\n\t\t\tthis.ay = (dy * pa * pid - dx * pc * pid);\n\t\t\tvar ia = pid * pd;\n\t\t\tvar id = pid * pa;\n\t\t\tvar ib = pid * pb;\n\t\t\tvar ic = pid * pc;\n\t\t\tvar ra = ia * this.a - ib * this.c;\n\t\t\tvar rb = ia * this.b - ib * this.d;\n\t\t\tvar rc = id * this.c - ic * this.a;\n\t\t\tvar rd = id * this.d - ic * this.b;\n\t\t\tthis.ashearX = 0;\n\t\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\n\t\t\tif (this.ascaleX > 0.0001) {\n\t\t\t\tvar det = ra * rd - rb * rc;\n\t\t\t\tthis.ascaleY = det / this.ascaleX;\n\t\t\t\tthis.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\n\t\t\t\tthis.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.ascaleX = 0;\n\t\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\n\t\t\t\tthis.ashearY = 0;\n\t\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\n\t\t\t}\n\t\t};\n\t\tBone.prototype.worldToLocal = function (world) {\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\n\t\t\tvar invDet = 1 / (a * d - b * c);\n\t\t\tvar x = world.x - this.worldX, y = world.y - this.worldY;\n\t\t\tworld.x = (x * d * invDet - y * b * invDet);\n\t\t\tworld.y = (y * a * invDet - x * c * invDet);\n\t\t\treturn world;\n\t\t};\n\t\tBone.prototype.localToWorld = function (local) {\n\t\t\tvar x = local.x, y = local.y;\n\t\t\tlocal.x = x * this.a + y * this.b + this.worldX;\n\t\t\tlocal.y = x * this.c + y * this.d + this.worldY;\n\t\t\treturn local;\n\t\t};\n\t\tBone.prototype.worldToLocalRotation = function (worldRotation) {\n\t\t\tvar sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\n\t\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;\n\t\t};\n\t\tBone.prototype.localToWorldRotation = function (localRotation) {\n\t\t\tlocalRotation -= this.rotation - this.shearX;\n\t\t\tvar sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\n\t\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\n\t\t};\n\t\tBone.prototype.rotateWorld = function (degrees) {\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\n\t\t\tvar cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\n\t\t\tthis.a = cos * a - sin * c;\n\t\t\tthis.b = cos * b - sin * d;\n\t\t\tthis.c = sin * a + cos * c;\n\t\t\tthis.d = sin * b + cos * d;\n\t\t\tthis.appliedValid = false;\n\t\t};\n\t\treturn Bone;\n\t}());\n\tspine.Bone = Bone;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar BoneData = (function () {\n\t\tfunction BoneData(index, name, parent) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.rotation = 0;\n\t\t\tthis.scaleX = 1;\n\t\t\tthis.scaleY = 1;\n\t\t\tthis.shearX = 0;\n\t\t\tthis.shearY = 0;\n\t\t\tthis.transformMode = TransformMode.Normal;\n\t\t\tthis.skinRequired = false;\n\t\t\tthis.color = new spine.Color();\n\t\t\tif (index < 0)\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"name cannot be null.\");\n\t\t\tthis.index = index;\n\t\t\tthis.name = name;\n\t\t\tthis.parent = parent;\n\t\t}\n\t\treturn BoneData;\n\t}());\n\tspine.BoneData = BoneData;\n\tvar TransformMode;\n\t(function (TransformMode) {\n\t\tTransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\n\t\tTransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n\t\tTransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n\t\tTransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\n\t\tTransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n\t})(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar ConstraintData = (function () {\n\t\tfunction ConstraintData(name, order, skinRequired) {\n\t\t\tthis.name = name;\n\t\t\tthis.order = order;\n\t\t\tthis.skinRequired = skinRequired;\n\t\t}\n\t\treturn ConstraintData;\n\t}());\n\tspine.ConstraintData = ConstraintData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Event = (function () {\n\t\tfunction Event(time, data) {\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tthis.time = time;\n\t\t\tthis.data = data;\n\t\t}\n\t\treturn Event;\n\t}());\n\tspine.Event = Event;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar EventData = (function () {\n\t\tfunction EventData(name) {\n\t\t\tthis.name = name;\n\t\t}\n\t\treturn EventData;\n\t}());\n\tspine.EventData = EventData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar IkConstraint = (function () {\n\t\tfunction IkConstraint(data, skeleton) {\n\t\t\tthis.bendDirection = 0;\n\t\t\tthis.compress = false;\n\t\t\tthis.stretch = false;\n\t\t\tthis.mix = 1;\n\t\t\tthis.softness = 0;\n\t\t\tthis.active = false;\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.mix = data.mix;\n\t\t\tthis.softness = data.softness;\n\t\t\tthis.bendDirection = data.bendDirection;\n\t\t\tthis.compress = data.compress;\n\t\t\tthis.stretch = data.stretch;\n\t\t\tthis.bones = new Array();\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\n\t\t\tthis.target = skeleton.findBone(data.target.name);\n\t\t}\n\t\tIkConstraint.prototype.isActive = function () {\n\t\t\treturn this.active;\n\t\t};\n\t\tIkConstraint.prototype.apply = function () {\n\t\t\tthis.update();\n\t\t};\n\t\tIkConstraint.prototype.update = function () {\n\t\t\tvar target = this.target;\n\t\t\tvar bones = this.bones;\n\t\t\tswitch (bones.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tIkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\n\t\t\tif (!bone.appliedValid)\n\t\t\t\tbone.updateAppliedTransform();\n\t\t\tvar p = bone.parent;\n\t\t\tvar pa = p.a, pb = p.b, pc = p.c, pd = p.d;\n\t\t\tvar rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\n\t\t\tswitch (bone.data.transformMode) {\n\t\t\t\tcase spine.TransformMode.OnlyTranslation:\n\t\t\t\t\ttx = targetX - bone.worldX;\n\t\t\t\t\tty = targetY - bone.worldY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase spine.TransformMode.NoRotationOrReflection:\n\t\t\t\t\tvar s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n\t\t\t\t\tvar sa = pa / bone.skeleton.scaleX;\n\t\t\t\t\tvar sc = pc / bone.skeleton.scaleY;\n\t\t\t\t\tpb = -sc * s * bone.skeleton.scaleX;\n\t\t\t\t\tpd = sa * s * bone.skeleton.scaleY;\n\t\t\t\t\trotationIK += Math.atan2(sc, sa) * spine.MathUtils.radDeg;\n\t\t\t\tdefault:\n\t\t\t\t\tvar x = targetX - p.worldX, y = targetY - p.worldY;\n\t\t\t\t\tvar d = pa * pd - pb * pc;\n\t\t\t\t\ttx = (x * pd - y * pb) / d - bone.ax;\n\t\t\t\t\tty = (y * pa - x * pc) / d - bone.ay;\n\t\t\t}\n\t\t\trotationIK += Math.atan2(ty, tx) * spine.MathUtils.radDeg;\n\t\t\tif (bone.ascaleX < 0)\n\t\t\t\trotationIK += 180;\n\t\t\tif (rotationIK > 180)\n\t\t\t\trotationIK -= 360;\n\t\t\telse if (rotationIK < -180)\n\t\t\t\trotationIK += 360;\n\t\t\tvar sx = bone.ascaleX, sy = bone.ascaleY;\n\t\t\tif (compress || stretch) {\n\t\t\t\tswitch (bone.data.transformMode) {\n\t\t\t\t\tcase spine.TransformMode.NoScale:\n\t\t\t\t\tcase spine.TransformMode.NoScaleOrReflection:\n\t\t\t\t\t\ttx = targetX - bone.worldX;\n\t\t\t\t\t\tty = targetY - bone.worldY;\n\t\t\t\t}\n\t\t\t\tvar b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\n\t\t\t\tif ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\n\t\t\t\t\tvar s = (dd / b - 1) * alpha + 1;\n\t\t\t\t\tsx *= s;\n\t\t\t\t\tif (uniform)\n\t\t\t\t\t\tsy *= s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n\t\t};\n\t\tIkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\n\t\t\tif (alpha == 0) {\n\t\t\t\tchild.updateWorldTransform();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!parent.appliedValid)\n\t\t\t\tparent.updateAppliedTransform();\n\t\t\tif (!child.appliedValid)\n\t\t\t\tchild.updateAppliedTransform();\n\t\t\tvar px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\n\t\t\tvar os1 = 0, os2 = 0, s2 = 0;\n\t\t\tif (psx < 0) {\n\t\t\t\tpsx = -psx;\n\t\t\t\tos1 = 180;\n\t\t\t\ts2 = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tos1 = 0;\n\t\t\t\ts2 = 1;\n\t\t\t}\n\t\t\tif (psy < 0) {\n\t\t\t\tpsy = -psy;\n\t\t\t\ts2 = -s2;\n\t\t\t}\n\t\t\tif (csx < 0) {\n\t\t\t\tcsx = -csx;\n\t\t\t\tos2 = 180;\n\t\t\t}\n\t\t\telse\n\t\t\t\tos2 = 0;\n\t\t\tvar cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\n\t\t\tvar u = Math.abs(psx - psy) <= 0.0001;\n\t\t\tif (!u) {\n\t\t\t\tcy = 0;\n\t\t\t\tcwx = a * cx + parent.worldX;\n\t\t\t\tcwy = c * cx + parent.worldY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcy = child.ay;\n\t\t\t\tcwx = a * cx + b * cy + parent.worldX;\n\t\t\t\tcwy = c * cx + d * cy + parent.worldY;\n\t\t\t}\n\t\t\tvar pp = parent.parent;\n\t\t\ta = pp.a;\n\t\t\tb = pp.b;\n\t\t\tc = pp.c;\n\t\t\td = pp.d;\n\t\t\tvar id = 1 / (a * d - b * c), x = cwx - pp.worldX, y = cwy - pp.worldY;\n\t\t\tvar dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n\t\t\tvar l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n\t\t\tif (l1 < 0.0001) {\n\t\t\t\tthis.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n\t\t\t\tchild.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tx = targetX - pp.worldX;\n\t\t\ty = targetY - pp.worldY;\n\t\t\tvar tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n\t\t\tvar dd = tx * tx + ty * ty;\n\t\t\tif (softness != 0) {\n\t\t\t\tsoftness *= psx * (csx + 1) / 2;\n\t\t\t\tvar td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\n\t\t\t\tif (sd > 0) {\n\t\t\t\t\tvar p = Math.min(1, sd / (softness * 2)) - 1;\n\t\t\t\t\tp = (sd - softness * (1 - p * p)) / td;\n\t\t\t\t\ttx -= p * tx;\n\t\t\t\t\tty -= p * ty;\n\t\t\t\t\tdd = tx * tx + ty * ty;\n\t\t\t\t}\n\t\t\t}\n\t\t\touter: if (u) {\n\t\t\t\tl2 *= psx;\n\t\t\t\tvar cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\t\t\t\tif (cos < -1)\n\t\t\t\t\tcos = -1;\n\t\t\t\telse if (cos > 1) {\n\t\t\t\t\tcos = 1;\n\t\t\t\t\tif (stretch)\n\t\t\t\t\t\tsx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n\t\t\t\t}\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\n\t\t\t\ta = l1 + l2 * cos;\n\t\t\t\tb = l2 * Math.sin(a2);\n\t\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = psx * l2;\n\t\t\t\tb = psy * l2;\n\t\t\t\tvar aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\n\t\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\n\t\t\t\tvar c1 = -2 * bb * l1, c2 = bb - aa;\n\t\t\t\td = c1 * c1 - 4 * c2 * c;\n\t\t\t\tif (d >= 0) {\n\t\t\t\t\tvar q = Math.sqrt(d);\n\t\t\t\t\tif (c1 < 0)\n\t\t\t\t\t\tq = -q;\n\t\t\t\t\tq = -(c1 + q) / 2;\n\t\t\t\t\tvar r0 = q / c2, r1 = c / q;\n\t\t\t\t\tvar r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\t\t\t\t\tif (r * r <= dd) {\n\t\t\t\t\t\ty = Math.sqrt(dd - r * r) * bendDir;\n\t\t\t\t\t\ta1 = ta - Math.atan2(y, r);\n\t\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n\t\t\t\tvar maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n\t\t\t\tc = -a * l1 / (aa - bb);\n\t\t\t\tif (c >= -1 && c <= 1) {\n\t\t\t\t\tc = Math.acos(c);\n\t\t\t\t\tx = a * Math.cos(c) + l1;\n\t\t\t\t\ty = b * Math.sin(c);\n\t\t\t\t\td = x * x + y * y;\n\t\t\t\t\tif (d < minDist) {\n\t\t\t\t\t\tminAngle = c;\n\t\t\t\t\t\tminDist = d;\n\t\t\t\t\t\tminX = x;\n\t\t\t\t\t\tminY = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (d > maxDist) {\n\t\t\t\t\t\tmaxAngle = c;\n\t\t\t\t\t\tmaxDist = d;\n\t\t\t\t\t\tmaxX = x;\n\t\t\t\t\t\tmaxY = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dd <= (minDist + maxDist) / 2) {\n\t\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\n\t\t\t\t\ta2 = minAngle * bendDir;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\n\t\t\t\t\ta2 = maxAngle * bendDir;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar os = Math.atan2(cy, cx) * s2;\n\t\t\tvar rotation = parent.arotation;\n\t\t\ta1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\n\t\t\tif (a1 > 180)\n\t\t\t\ta1 -= 360;\n\t\t\telse if (a1 < -180)\n\t\t\t\ta1 += 360;\n\t\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n\t\t\trotation = child.arotation;\n\t\t\ta2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n\t\t\tif (a2 > 180)\n\t\t\t\ta2 -= 360;\n\t\t\telse if (a2 < -180)\n\t\t\t\ta2 += 360;\n\t\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\t\t};\n\t\treturn IkConstraint;\n\t}());\n\tspine.IkConstraint = IkConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar IkConstraintData = (function (_super) {\n\t\t__extends(IkConstraintData, _super);\n\t\tfunction IkConstraintData(name) {\n\t\t\tvar _this = _super.call(this, name, 0, false) || this;\n\t\t\t_this.bones = new Array();\n\t\t\t_this.bendDirection = 1;\n\t\t\t_this.compress = false;\n\t\t\t_this.stretch = false;\n\t\t\t_this.uniform = false;\n\t\t\t_this.mix = 1;\n\t\t\t_this.softness = 0;\n\t\t\treturn _this;\n\t\t}\n\t\treturn IkConstraintData;\n\t}(spine.ConstraintData));\n\tspine.IkConstraintData = IkConstraintData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar PathConstraint = (function () {\n\t\tfunction PathConstraint(data, skeleton) {\n\t\t\tthis.position = 0;\n\t\t\tthis.spacing = 0;\n\t\t\tthis.rotateMix = 0;\n\t\t\tthis.translateMix = 0;\n\t\t\tthis.spaces = new Array();\n\t\t\tthis.positions = new Array();\n\t\t\tthis.world = new Array();\n\t\t\tthis.curves = new Array();\n\t\t\tthis.lengths = new Array();\n\t\t\tthis.segments = new Array();\n\t\t\tthis.active = false;\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.bones = new Array();\n\t\t\tfor (var i = 0, n = data.bones.length; i < n; i++)\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\n\t\t\tthis.target = skeleton.findSlot(data.target.name);\n\t\t\tthis.position = data.position;\n\t\t\tthis.spacing = data.spacing;\n\t\t\tthis.rotateMix = data.rotateMix;\n\t\t\tthis.translateMix = data.translateMix;\n\t\t}\n\t\tPathConstraint.prototype.isActive = function () {\n\t\t\treturn this.active;\n\t\t};\n\t\tPathConstraint.prototype.apply = function () {\n\t\t\tthis.update();\n\t\t};\n\t\tPathConstraint.prototype.update = function () {\n\t\t\tvar attachment = this.target.getAttachment();\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\n\t\t\t\treturn;\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix;\n\t\t\tvar translate = translateMix > 0, rotate = rotateMix > 0;\n\t\t\tif (!translate && !rotate)\n\t\t\t\treturn;\n\t\t\tvar data = this.data;\n\t\t\tvar percentSpacing = data.spacingMode == spine.SpacingMode.Percent;\n\t\t\tvar rotateMode = data.rotateMode;\n\t\t\tvar tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\n\t\t\tvar boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n\t\t\tvar bones = this.bones;\n\t\t\tvar spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\n\t\t\tvar spacing = this.spacing;\n\t\t\tif (scale || !percentSpacing) {\n\t\t\t\tif (scale)\n\t\t\t\t\tlengths = spine.Utils.setArraySize(this.lengths, boneCount);\n\t\t\t\tvar lengthSpacing = data.spacingMode == spine.SpacingMode.Length;\n\t\t\t\tfor (var i = 0, n = spacesCount - 1; i < n;) {\n\t\t\t\t\tvar bone = bones[i];\n\t\t\t\t\tvar setupLength = bone.data.length;\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\n\t\t\t\t\t\tif (scale)\n\t\t\t\t\t\t\tlengths[i] = 0;\n\t\t\t\t\t\tspaces[++i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (percentSpacing) {\n\t\t\t\t\t\tif (scale) {\n\t\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\n\t\t\t\t\t\t\tvar length_1 = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\t\tlengths[i] = length_1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tspaces[++i] = spacing;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\n\t\t\t\t\t\tvar length_2 = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\tif (scale)\n\t\t\t\t\t\t\tlengths[i] = length_2;\n\t\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\n\t\t\t\t\tspaces[i] = spacing;\n\t\t\t}\n\t\t\tvar positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);\n\t\t\tvar boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n\t\t\tvar tip = false;\n\t\t\tif (offsetRotation == 0)\n\t\t\t\ttip = rotateMode == spine.RotateMode.Chain;\n\t\t\telse {\n\t\t\t\ttip = false;\n\t\t\t\tvar p = this.target.bone;\n\t\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n\t\t\t}\n\t\t\tfor (var i = 0, p = 3; i < boneCount; i++, p += 3) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tbone.worldX += (boneX - bone.worldX) * translateMix;\n\t\t\t\tbone.worldY += (boneY - bone.worldY) * translateMix;\n\t\t\t\tvar x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n\t\t\t\tif (scale) {\n\t\t\t\t\tvar length_3 = lengths[i];\n\t\t\t\t\tif (length_3 != 0) {\n\t\t\t\t\t\tvar s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;\n\t\t\t\t\t\tbone.a *= s;\n\t\t\t\t\t\tbone.c *= s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboneX = x;\n\t\t\t\tboneY = y;\n\t\t\t\tif (rotate) {\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\n\t\t\t\t\tif (tangents)\n\t\t\t\t\t\tr = positions[p - 1];\n\t\t\t\t\telse if (spaces[i + 1] == 0)\n\t\t\t\t\t\tr = positions[p + 2];\n\t\t\t\t\telse\n\t\t\t\t\t\tr = Math.atan2(dy, dx);\n\t\t\t\t\tr -= Math.atan2(c, a);\n\t\t\t\t\tif (tip) {\n\t\t\t\t\t\tcos = Math.cos(r);\n\t\t\t\t\t\tsin = Math.sin(r);\n\t\t\t\t\t\tvar length_4 = bone.data.length;\n\t\t\t\t\t\tboneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;\n\t\t\t\t\t\tboneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tr += offsetRotation;\n\t\t\t\t\t}\n\t\t\t\t\tif (r > spine.MathUtils.PI)\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\n\t\t\t\t\tr *= rotateMix;\n\t\t\t\t\tcos = Math.cos(r);\n\t\t\t\t\tsin = Math.sin(r);\n\t\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t\t}\n\t\t\t\tbone.appliedValid = false;\n\t\t\t}\n\t\t};\n\t\tPathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\n\t\t\tvar target = this.target;\n\t\t\tvar position = this.position;\n\t\t\tvar spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\n\t\t\tvar closed = path.closed;\n\t\t\tvar verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\t\t\tif (!path.constantSpeed) {\n\t\t\t\tvar lengths = path.lengths;\n\t\t\t\tcurveCount -= closed ? 1 : 2;\n\t\t\t\tvar pathLength_1 = lengths[curveCount];\n\t\t\t\tif (percentPosition)\n\t\t\t\t\tposition *= pathLength_1;\n\t\t\t\tif (percentSpacing) {\n\t\t\t\t\tfor (var i = 1; i < spacesCount; i++)\n\t\t\t\t\t\tspaces[i] *= pathLength_1;\n\t\t\t\t}\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, 8);\n\t\t\t\tfor (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n\t\t\t\t\tvar space = spaces[i];\n\t\t\t\t\tposition += space;\n\t\t\t\t\tvar p = position;\n\t\t\t\t\tif (closed) {\n\t\t\t\t\t\tp %= pathLength_1;\n\t\t\t\t\t\tif (p < 0)\n\t\t\t\t\t\t\tp += pathLength_1;\n\t\t\t\t\t\tcurve = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p < 0) {\n\t\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\n\t\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p > pathLength_1) {\n\t\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\n\t\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.addAfterPosition(p - pathLength_1, world, 0, out, o);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (;; curve++) {\n\t\t\t\t\t\tvar length_5 = lengths[curve];\n\t\t\t\t\t\tif (p > length_5)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (curve == 0)\n\t\t\t\t\t\t\tp /= length_5;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar prev = lengths[curve - 1];\n\t\t\t\t\t\t\tp = (p - prev) / (length_5 - prev);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (curve != prevCurve) {\n\t\t\t\t\t\tprevCurve = curve;\n\t\t\t\t\t\tif (closed && curve == curveCount) {\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n\t\t\t\t\t}\n\t\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\tif (closed) {\n\t\t\t\tverticesLength += 2;\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n\t\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n\t\t\t\tworld[verticesLength - 2] = world[0];\n\t\t\t\tworld[verticesLength - 1] = world[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurveCount--;\n\t\t\t\tverticesLength -= 4;\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n\t\t\t}\n\t\t\tvar curves = spine.Utils.setArraySize(this.curves, curveCount);\n\t\t\tvar pathLength = 0;\n\t\t\tvar x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n\t\t\tvar tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n\t\t\tfor (var i = 0, w = 2; i < curveCount; i++, w += 6) {\n\t\t\t\tcx1 = world[w];\n\t\t\t\tcy1 = world[w + 1];\n\t\t\t\tcx2 = world[w + 2];\n\t\t\t\tcy2 = world[w + 3];\n\t\t\t\tx2 = world[w + 4];\n\t\t\t\ty2 = world[w + 5];\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n\t\t\t\tddfx = tmpx * 2 + dddfx;\n\t\t\t\tddfy = tmpy * 2 + dddfy;\n\t\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n\t\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tdfx += ddfx;\n\t\t\t\tdfy += ddfy;\n\t\t\t\tddfx += dddfx;\n\t\t\t\tddfy += dddfy;\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tdfx += ddfx;\n\t\t\t\tdfy += ddfy;\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tdfx += ddfx + dddfx;\n\t\t\t\tdfy += ddfy + dddfy;\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\tcurves[i] = pathLength;\n\t\t\t\tx1 = x2;\n\t\t\t\ty1 = y2;\n\t\t\t}\n\t\t\tif (percentPosition)\n\t\t\t\tposition *= pathLength;\n\t\t\telse\n\t\t\t\tposition *= pathLength / path.lengths[curveCount - 1];\n\t\t\tif (percentSpacing) {\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\n\t\t\t\t\tspaces[i] *= pathLength;\n\t\t\t}\n\t\t\tvar segments = this.segments;\n\t\t\tvar curveLength = 0;\n\t\t\tfor (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n\t\t\t\tvar space = spaces[i];\n\t\t\t\tposition += space;\n\t\t\t\tvar p = position;\n\t\t\t\tif (closed) {\n\t\t\t\t\tp %= pathLength;\n\t\t\t\t\tif (p < 0)\n\t\t\t\t\t\tp += pathLength;\n\t\t\t\t\tcurve = 0;\n\t\t\t\t}\n\t\t\t\telse if (p < 0) {\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (p > pathLength) {\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (;; curve++) {\n\t\t\t\t\tvar length_6 = curves[curve];\n\t\t\t\t\tif (p > length_6)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (curve == 0)\n\t\t\t\t\t\tp /= length_6;\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar prev = curves[curve - 1];\n\t\t\t\t\t\tp = (p - prev) / (length_6 - prev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (curve != prevCurve) {\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t\tvar ii = curve * 6;\n\t\t\t\t\tx1 = world[ii];\n\t\t\t\t\ty1 = world[ii + 1];\n\t\t\t\t\tcx1 = world[ii + 2];\n\t\t\t\t\tcy1 = world[ii + 3];\n\t\t\t\t\tcx2 = world[ii + 4];\n\t\t\t\t\tcy2 = world[ii + 5];\n\t\t\t\t\tx2 = world[ii + 6];\n\t\t\t\t\ty2 = world[ii + 7];\n\t\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n\t\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n\t\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n\t\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n\t\t\t\t\tddfx = tmpx * 2 + dddfx;\n\t\t\t\t\tddfy = tmpy * 2 + dddfy;\n\t\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n\t\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n\t\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\t\tsegments[0] = curveLength;\n\t\t\t\t\tfor (ii = 1; ii < 8; ii++) {\n\t\t\t\t\t\tdfx += ddfx;\n\t\t\t\t\t\tdfy += ddfy;\n\t\t\t\t\t\tddfx += dddfx;\n\t\t\t\t\t\tddfy += dddfy;\n\t\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\t\t\tsegments[ii] = curveLength;\n\t\t\t\t\t}\n\t\t\t\t\tdfx += ddfx;\n\t\t\t\t\tdfy += ddfy;\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\t\tsegments[8] = curveLength;\n\t\t\t\t\tdfx += ddfx + dddfx;\n\t\t\t\t\tdfy += ddfy + dddfy;\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n\t\t\t\t\tsegments[9] = curveLength;\n\t\t\t\t\tsegment = 0;\n\t\t\t\t}\n\t\t\t\tp *= curveLength;\n\t\t\t\tfor (;; segment++) {\n\t\t\t\t\tvar length_7 = segments[segment];\n\t\t\t\t\tif (p > length_7)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (segment == 0)\n\t\t\t\t\t\tp /= length_7;\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar prev = segments[segment - 1];\n\t\t\t\t\t\tp = segment + (p - prev) / (length_7 - prev);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\tPathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\n\t\t\tvar x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n\t\t\tout[o] = x1 + p * Math.cos(r);\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\n\t\t\tout[o + 2] = r;\n\t\t};\n\t\tPathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\n\t\t\tvar x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n\t\t\tout[o] = x1 + p * Math.cos(r);\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\n\t\t\tout[o + 2] = r;\n\t\t};\n\t\tPathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n\t\t\tif (p == 0 || isNaN(p)) {\n\t\t\t\tout[o] = x1;\n\t\t\t\tout[o + 1] = y1;\n\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n\t\t\tvar ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n\t\t\tvar x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\t\t\tout[o] = x;\n\t\t\tout[o + 1] = y;\n\t\t\tif (tangents) {\n\t\t\t\tif (p < 0.001)\n\t\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\t\t\t\telse\n\t\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n\t\t\t}\n\t\t};\n\t\tPathConstraint.NONE = -1;\n\t\tPathConstraint.BEFORE = -2;\n\t\tPathConstraint.AFTER = -3;\n\t\tPathConstraint.epsilon = 0.00001;\n\t\treturn PathConstraint;\n\t}());\n\tspine.PathConstraint = PathConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar PathConstraintData = (function (_super) {\n\t\t__extends(PathConstraintData, _super);\n\t\tfunction PathConstraintData(name) {\n\t\t\tvar _this = _super.call(this, name, 0, false) || this;\n\t\t\t_this.bones = new Array();\n\t\t\treturn _this;\n\t\t}\n\t\treturn PathConstraintData;\n\t}(spine.ConstraintData));\n\tspine.PathConstraintData = PathConstraintData;\n\tvar PositionMode;\n\t(function (PositionMode) {\n\t\tPositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\n\t\tPositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\n\t})(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\n\tvar SpacingMode;\n\t(function (SpacingMode) {\n\t\tSpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\n\t\tSpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\n\t\tSpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\n\t})(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\n\tvar RotateMode;\n\t(function (RotateMode) {\n\t\tRotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\n\t\tRotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\n\t\tRotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\n\t})(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Assets = (function () {\n\t\tfunction Assets(clientId) {\n\t\t\tthis.toLoad = new Array();\n\t\t\tthis.assets = {};\n\t\t\tthis.clientId = clientId;\n\t\t}\n\t\tAssets.prototype.loaded = function () {\n\t\t\tvar i = 0;\n\t\t\tfor (var v in this.assets)\n\t\t\t\ti++;\n\t\t\treturn i;\n\t\t};\n\t\treturn Assets;\n\t}());\n\tvar SharedAssetManager = (function () {\n\t\tfunction SharedAssetManager(pathPrefix) {\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\n\t\t\tthis.clientAssets = {};\n\t\t\tthis.queuedAssets = {};\n\t\t\tthis.rawAssets = {};\n\t\t\tthis.errors = {};\n\t\t\tthis.pathPrefix = pathPrefix;\n\t\t}\n\t\tSharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\n\t\t\tvar clientAssets = this.clientAssets[clientId];\n\t\t\tif (clientAssets === null || clientAssets === undefined) {\n\t\t\t\tclientAssets = new Assets(clientId);\n\t\t\t\tthis.clientAssets[clientId] = clientAssets;\n\t\t\t}\n\t\t\tif (textureLoader !== null)\n\t\t\t\tclientAssets.textureLoader = textureLoader;\n\t\t\tclientAssets.toLoad.push(path);\n\t\t\tif (this.queuedAssets[path] === path) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.queuedAssets[path] = path;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tSharedAssetManager.prototype.loadText = function (clientId, path) {\n\t\t\tvar _this = this;\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tif (!this.queueAsset(clientId, null, path))\n\t\t\t\treturn;\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.overrideMimeType(\"text/html\");\n\t\t\trequest.onreadystatechange = function () {\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\n\t\t\t\t\t\t_this.rawAssets[path] = request.responseText;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\trequest.open(\"GET\", path, true);\n\t\t\trequest.send();\n\t\t};\n\t\tSharedAssetManager.prototype.loadJson = function (clientId, path) {\n\t\t\tvar _this = this;\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tif (!this.queueAsset(clientId, null, path))\n\t\t\t\treturn;\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.overrideMimeType(\"text/html\");\n\t\t\trequest.onreadystatechange = function () {\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\n\t\t\t\t\t\t_this.rawAssets[path] = JSON.parse(request.responseText);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\trequest.open(\"GET\", path, true);\n\t\t\trequest.send();\n\t\t};\n\t\tSharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\n\t\t\tvar _this = this;\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tif (!this.queueAsset(clientId, textureLoader, path))\n\t\t\t\treturn;\n\t\t\tvar isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document);\n\t\t\tvar isWebWorker = !isBrowser && typeof importScripts !== 'undefined';\n\t\t\tif (isWebWorker) {\n\t\t\t\tvar options = { mode: \"cors\" };\n\t\t\t\tfetch(path, options).then(function (response) {\n\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\n\t\t\t\t\t}\n\t\t\t\t\treturn response.blob();\n\t\t\t\t}).then(function (blob) {\n\t\t\t\t\treturn createImageBitmap(blob, {\n\t\t\t\t\t\tpremultiplyAlpha: 'none',\n\t\t\t\t\t\tcolorSpaceConversion: 'none'\n\t\t\t\t\t});\n\t\t\t\t}).then(function (bitmap) {\n\t\t\t\t\t_this.rawAssets[path] = bitmap;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar img_1 = new Image();\n\t\t\t\timg_1.crossOrigin = \"anonymous\";\n\t\t\t\timg_1.onload = function (ev) {\n\t\t\t\t\t_this.rawAssets[path] = img_1;\n\t\t\t\t};\n\t\t\t\timg_1.onerror = function (ev) {\n\t\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\n\t\t\t\t};\n\t\t\t\timg_1.src = path;\n\t\t\t}\n\t\t};\n\t\tSharedAssetManager.prototype.get = function (clientId, path) {\n\t\t\tpath = this.pathPrefix + path;\n\t\t\tvar clientAssets = this.clientAssets[clientId];\n\t\t\tif (clientAssets === null || clientAssets === undefined)\n\t\t\t\treturn true;\n\t\t\treturn clientAssets.assets[path];\n\t\t};\n\t\tSharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\n\t\t\tvar isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document);\n\t\t\tvar isWebWorker = !isBrowser && typeof importScripts !== 'undefined';\n\t\t\tfor (var i = 0; i < clientAssets.toLoad.length; i++) {\n\t\t\t\tvar path = clientAssets.toLoad[i];\n\t\t\t\tvar asset = clientAssets.assets[path];\n\t\t\t\tif (asset === null || asset === undefined) {\n\t\t\t\t\tvar rawAsset = this.rawAssets[path];\n\t\t\t\t\tif (rawAsset === null || rawAsset === undefined)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (isWebWorker) {\n\t\t\t\t\t\tif (rawAsset instanceof ImageBitmap) {\n\t\t\t\t\t\t\tclientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclientAssets.assets[path] = rawAsset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (rawAsset instanceof HTMLImageElement) {\n\t\t\t\t\t\t\tclientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclientAssets.assets[path] = rawAsset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSharedAssetManager.prototype.isLoadingComplete = function (clientId) {\n\t\t\tvar clientAssets = this.clientAssets[clientId];\n\t\t\tif (clientAssets === null || clientAssets === undefined)\n\t\t\t\treturn true;\n\t\t\tthis.updateClientAssets(clientAssets);\n\t\t\treturn clientAssets.toLoad.length == clientAssets.loaded();\n\t\t};\n\t\tSharedAssetManager.prototype.dispose = function () {\n\t\t};\n\t\tSharedAssetManager.prototype.hasErrors = function () {\n\t\t\treturn Object.keys(this.errors).length > 0;\n\t\t};\n\t\tSharedAssetManager.prototype.getErrors = function () {\n\t\t\treturn this.errors;\n\t\t};\n\t\treturn SharedAssetManager;\n\t}());\n\tspine.SharedAssetManager = SharedAssetManager;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Skeleton = (function () {\n\t\tfunction Skeleton(data) {\n\t\t\tthis._updateCache = new Array();\n\t\t\tthis.updateCacheReset = new Array();\n\t\t\tthis.time = 0;\n\t\t\tthis.scaleX = 1;\n\t\t\tthis.scaleY = 1;\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.bones = new Array();\n\t\t\tfor (var i = 0; i < data.bones.length; i++) {\n\t\t\t\tvar boneData = data.bones[i];\n\t\t\t\tvar bone = void 0;\n\t\t\t\tif (boneData.parent == null)\n\t\t\t\t\tbone = new spine.Bone(boneData, this, null);\n\t\t\t\telse {\n\t\t\t\t\tvar parent_1 = this.bones[boneData.parent.index];\n\t\t\t\t\tbone = new spine.Bone(boneData, this, parent_1);\n\t\t\t\t\tparent_1.children.push(bone);\n\t\t\t\t}\n\t\t\t\tthis.bones.push(bone);\n\t\t\t}\n\t\t\tthis.slots = new Array();\n\t\t\tthis.drawOrder = new Array();\n\t\t\tfor (var i = 0; i < data.slots.length; i++) {\n\t\t\t\tvar slotData = data.slots[i];\n\t\t\t\tvar bone = this.bones[slotData.boneData.index];\n\t\t\t\tvar slot = new spine.Slot(slotData, bone);\n\t\t\t\tthis.slots.push(slot);\n\t\t\t\tthis.drawOrder.push(slot);\n\t\t\t}\n\t\t\tthis.ikConstraints = new Array();\n\t\t\tfor (var i = 0; i < data.ikConstraints.length; i++) {\n\t\t\t\tvar ikConstraintData = data.ikConstraints[i];\n\t\t\t\tthis.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\n\t\t\t}\n\t\t\tthis.transformConstraints = new Array();\n\t\t\tfor (var i = 0; i < data.transformConstraints.length; i++) {\n\t\t\t\tvar transformConstraintData = data.transformConstraints[i];\n\t\t\t\tthis.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\n\t\t\t}\n\t\t\tthis.pathConstraints = new Array();\n\t\t\tfor (var i = 0; i < data.pathConstraints.length; i++) {\n\t\t\t\tvar pathConstraintData = data.pathConstraints[i];\n\t\t\t\tthis.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\n\t\t\t}\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\n\t\t\tthis.updateCache();\n\t\t}\n\t\tSkeleton.prototype.updateCache = function () {\n\t\t\tvar updateCache = this._updateCache;\n\t\t\tupdateCache.length = 0;\n\t\t\tthis.updateCacheReset.length = 0;\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tbone.sorted = bone.data.skinRequired;\n\t\t\t\tbone.active = !bone.sorted;\n\t\t\t}\n\t\t\tif (this.skin != null) {\n\t\t\t\tvar skinBones = this.skin.bones;\n\t\t\t\tfor (var i = 0, n = this.skin.bones.length; i < n; i++) {\n\t\t\t\t\tvar bone = this.bones[skinBones[i].index];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tbone.sorted = false;\n\t\t\t\t\t\tbone.active = true;\n\t\t\t\t\t\tbone = bone.parent;\n\t\t\t\t\t} while (bone != null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ikConstraints = this.ikConstraints;\n\t\t\tvar transformConstraints = this.transformConstraints;\n\t\t\tvar pathConstraints = this.pathConstraints;\n\t\t\tvar ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n\t\t\tvar constraintCount = ikCount + transformCount + pathCount;\n\t\t\touter: for (var i = 0; i < constraintCount; i++) {\n\t\t\t\tfor (var ii = 0; ii < ikCount; ii++) {\n\t\t\t\t\tvar constraint = ikConstraints[ii];\n\t\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\t\tthis.sortIkConstraint(constraint);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var ii = 0; ii < transformCount; ii++) {\n\t\t\t\t\tvar constraint = transformConstraints[ii];\n\t\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\t\tthis.sortTransformConstraint(constraint);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var ii = 0; ii < pathCount; ii++) {\n\t\t\t\t\tvar constraint = pathConstraints[ii];\n\t\t\t\t\tif (constraint.data.order == i) {\n\t\t\t\t\t\tthis.sortPathConstraint(constraint);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\t\tthis.sortBone(bones[i]);\n\t\t};\n\t\tSkeleton.prototype.sortIkConstraint = function (constraint) {\n\t\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tvar target = constraint.target;\n\t\t\tthis.sortBone(target);\n\t\t\tvar constrained = constraint.bones;\n\t\t\tvar parent = constrained[0];\n\t\t\tthis.sortBone(parent);\n\t\t\tif (constrained.length > 1) {\n\t\t\t\tvar child = constrained[constrained.length - 1];\n\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\n\t\t\t\t\tthis.updateCacheReset.push(child);\n\t\t\t}\n\t\t\tthis._updateCache.push(constraint);\n\t\t\tthis.sortReset(parent.children);\n\t\t\tconstrained[constrained.length - 1].sorted = true;\n\t\t};\n\t\tSkeleton.prototype.sortPathConstraint = function (constraint) {\n\t\t\tconstraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tvar slot = constraint.target;\n\t\t\tvar slotIndex = slot.data.index;\n\t\t\tvar slotBone = slot.bone;\n\t\t\tif (this.skin != null)\n\t\t\t\tthis.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n\t\t\tif (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n\t\t\tfor (var i = 0, n = this.data.skins.length; i < n; i++)\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\t\t\tvar attachment = slot.getAttachment();\n\t\t\tif (attachment instanceof spine.PathAttachment)\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachment, slotBone);\n\t\t\tvar constrained = constraint.bones;\n\t\t\tvar boneCount = constrained.length;\n\t\t\tfor (var i = 0; i < boneCount; i++)\n\t\t\t\tthis.sortBone(constrained[i]);\n\t\t\tthis._updateCache.push(constraint);\n\t\t\tfor (var i = 0; i < boneCount; i++)\n\t\t\t\tthis.sortReset(constrained[i].children);\n\t\t\tfor (var i = 0; i < boneCount; i++)\n\t\t\t\tconstrained[i].sorted = true;\n\t\t};\n\t\tSkeleton.prototype.sortTransformConstraint = function (constraint) {\n\t\t\tconstraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\n\t\t\tif (!constraint.active)\n\t\t\t\treturn;\n\t\t\tthis.sortBone(constraint.target);\n\t\t\tvar constrained = constraint.bones;\n\t\t\tvar boneCount = constrained.length;\n\t\t\tif (constraint.data.local) {\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\n\t\t\t\t\tvar child = constrained[i];\n\t\t\t\t\tthis.sortBone(child.parent);\n\t\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\n\t\t\t\t\t\tthis.updateCacheReset.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\n\t\t\t\t\tthis.sortBone(constrained[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._updateCache.push(constraint);\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\n\t\t\t\tthis.sortReset(constrained[ii].children);\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\n\t\t\t\tconstrained[ii].sorted = true;\n\t\t};\n\t\tSkeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\n\t\t\tvar attachments = skin.attachments[slotIndex];\n\t\t\tif (!attachments)\n\t\t\t\treturn;\n\t\t\tfor (var key in attachments) {\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n\t\t\t}\n\t\t};\n\t\tSkeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\n\t\t\t\treturn;\n\t\t\tvar pathBones = attachment.bones;\n\t\t\tif (pathBones == null)\n\t\t\t\tthis.sortBone(slotBone);\n\t\t\telse {\n\t\t\t\tvar bones = this.bones;\n\t\t\t\tvar i = 0;\n\t\t\t\twhile (i < pathBones.length) {\n\t\t\t\t\tvar boneCount = pathBones[i++];\n\t\t\t\t\tfor (var n = i + boneCount; i < n; i++) {\n\t\t\t\t\t\tvar boneIndex = pathBones[i];\n\t\t\t\t\t\tthis.sortBone(bones[boneIndex]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSkeleton.prototype.sortBone = function (bone) {\n\t\t\tif (bone.sorted)\n\t\t\t\treturn;\n\t\t\tvar parent = bone.parent;\n\t\t\tif (parent != null)\n\t\t\t\tthis.sortBone(parent);\n\t\t\tbone.sorted = true;\n\t\t\tthis._updateCache.push(bone);\n\t\t};\n\t\tSkeleton.prototype.sortReset = function (bones) {\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tif (!bone.active)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bone.sorted)\n\t\t\t\t\tthis.sortReset(bone.children);\n\t\t\t\tbone.sorted = false;\n\t\t\t}\n\t\t};\n\t\tSkeleton.prototype.updateWorldTransform = function () {\n\t\t\tvar updateCacheReset = this.updateCacheReset;\n\t\t\tfor (var i = 0, n = updateCacheReset.length; i < n; i++) {\n\t\t\t\tvar bone = updateCacheReset[i];\n\t\t\t\tbone.ax = bone.x;\n\t\t\t\tbone.ay = bone.y;\n\t\t\t\tbone.arotation = bone.rotation;\n\t\t\t\tbone.ascaleX = bone.scaleX;\n\t\t\t\tbone.ascaleY = bone.scaleY;\n\t\t\t\tbone.ashearX = bone.shearX;\n\t\t\t\tbone.ashearY = bone.shearY;\n\t\t\t\tbone.appliedValid = true;\n\t\t\t}\n\t\t\tvar updateCache = this._updateCache;\n\t\t\tfor (var i = 0, n = updateCache.length; i < n; i++)\n\t\t\t\tupdateCache[i].update();\n\t\t};\n\t\tSkeleton.prototype.setToSetupPose = function () {\n\t\t\tthis.setBonesToSetupPose();\n\t\t\tthis.setSlotsToSetupPose();\n\t\t};\n\t\tSkeleton.prototype.setBonesToSetupPose = function () {\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\t\tbones[i].setToSetupPose();\n\t\t\tvar ikConstraints = this.ikConstraints;\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = ikConstraints[i];\n\t\t\t\tconstraint.mix = constraint.data.mix;\n\t\t\t\tconstraint.softness = constraint.data.softness;\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\n\t\t\t\tconstraint.compress = constraint.data.compress;\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\n\t\t\t}\n\t\t\tvar transformConstraints = this.transformConstraints;\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = transformConstraints[i];\n\t\t\t\tvar data = constraint.data;\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\n\t\t\t\tconstraint.translateMix = data.translateMix;\n\t\t\t\tconstraint.scaleMix = data.scaleMix;\n\t\t\t\tconstraint.shearMix = data.shearMix;\n\t\t\t}\n\t\t\tvar pathConstraints = this.pathConstraints;\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = pathConstraints[i];\n\t\t\t\tvar data = constraint.data;\n\t\t\t\tconstraint.position = data.position;\n\t\t\t\tconstraint.spacing = data.spacing;\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\n\t\t\t\tconstraint.translateMix = data.translateMix;\n\t\t\t}\n\t\t};\n\t\tSkeleton.prototype.setSlotsToSetupPose = function () {\n\t\t\tvar slots = this.slots;\n\t\t\tspine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\t\tslots[i].setToSetupPose();\n\t\t};\n\t\tSkeleton.prototype.getRootBone = function () {\n\t\t\tif (this.bones.length == 0)\n\t\t\t\treturn null;\n\t\t\treturn this.bones[0];\n\t\t};\n\t\tSkeleton.prototype.findBone = function (boneName) {\n\t\t\tif (boneName == null)\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tif (bone.data.name == boneName)\n\t\t\t\t\treturn bone;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.findBoneIndex = function (boneName) {\n\t\t\tif (boneName == null)\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\t\tif (bones[i].data.name == boneName)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\tSkeleton.prototype.findSlot = function (slotName) {\n\t\t\tif (slotName == null)\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\n\t\t\tvar slots = this.slots;\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\tvar slot = slots[i];\n\t\t\t\tif (slot.data.name == slotName)\n\t\t\t\t\treturn slot;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.findSlotIndex = function (slotName) {\n\t\t\tif (slotName == null)\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\n\t\t\tvar slots = this.slots;\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\t\tif (slots[i].data.name == slotName)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\tSkeleton.prototype.setSkinByName = function (skinName) {\n\t\t\tvar skin = this.data.findSkin(skinName);\n\t\t\tif (skin == null)\n\t\t\t\tthrow new Error(\"Skin not found: \" + skinName);\n\t\t\tthis.setSkin(skin);\n\t\t};\n\t\tSkeleton.prototype.setSkin = function (newSkin) {\n\t\t\tif (newSkin == this.skin)\n\t\t\t\treturn;\n\t\t\tif (newSkin != null) {\n\t\t\t\tif (this.skin != null)\n\t\t\t\t\tnewSkin.attachAll(this, this.skin);\n\t\t\t\telse {\n\t\t\t\t\tvar slots = this.slots;\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\t\tvar slot = slots[i];\n\t\t\t\t\t\tvar name_1 = slot.data.attachmentName;\n\t\t\t\t\t\tif (name_1 != null) {\n\t\t\t\t\t\t\tvar attachment = newSkin.getAttachment(i, name_1);\n\t\t\t\t\t\t\tif (attachment != null)\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.skin = newSkin;\n\t\t\tthis.updateCache();\n\t\t};\n\t\tSkeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\n\t\t\treturn this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n\t\t};\n\t\tSkeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\n\t\t\tif (attachmentName == null)\n\t\t\t\tthrow new Error(\"attachmentName cannot be null.\");\n\t\t\tif (this.skin != null) {\n\t\t\t\tvar attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\t\t\t\tif (attachment != null)\n\t\t\t\t\treturn attachment;\n\t\t\t}\n\t\t\tif (this.data.defaultSkin != null)\n\t\t\t\treturn this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.setAttachment = function (slotName, attachmentName) {\n\t\t\tif (slotName == null)\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\n\t\t\tvar slots = this.slots;\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\tvar slot = slots[i];\n\t\t\t\tif (slot.data.name == slotName) {\n\t\t\t\t\tvar attachment = null;\n\t\t\t\t\tif (attachmentName != null) {\n\t\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\n\t\t\t\t\t\tif (attachment == null)\n\t\t\t\t\t\t\tthrow new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n\t\t\t\t\t}\n\t\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new Error(\"Slot not found: \" + slotName);\n\t\t};\n\t\tSkeleton.prototype.findIkConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar ikConstraints = this.ikConstraints;\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\t\tvar ikConstraint = ikConstraints[i];\n\t\t\t\tif (ikConstraint.data.name == constraintName)\n\t\t\t\t\treturn ikConstraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.findTransformConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar transformConstraints = this.transformConstraints;\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = transformConstraints[i];\n\t\t\t\tif (constraint.data.name == constraintName)\n\t\t\t\t\treturn constraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.findPathConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar pathConstraints = this.pathConstraints;\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = pathConstraints[i];\n\t\t\t\tif (constraint.data.name == constraintName)\n\t\t\t\t\treturn constraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeleton.prototype.getBounds = function (offset, size, temp) {\n\t\t\tif (temp === void 0) { temp = new Array(2); }\n\t\t\tif (offset == null)\n\t\t\t\tthrow new Error(\"offset cannot be null.\");\n\t\t\tif (size == null)\n\t\t\t\tthrow new Error(\"size cannot be null.\");\n\t\t\tvar drawOrder = this.drawOrder;\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\t\tvar slot = drawOrder[i];\n\t\t\t\tif (!slot.bone.active)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar verticesLength = 0;\n\t\t\t\tvar vertices = null;\n\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\n\t\t\t\t\tverticesLength = 8;\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\t\tattachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n\t\t\t\t}\n\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\n\t\t\t\t\tvar mesh = attachment;\n\t\t\t\t\tverticesLength = mesh.worldVerticesLength;\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\n\t\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n\t\t\t\t}\n\t\t\t\tif (vertices != null) {\n\t\t\t\t\tfor (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\n\t\t\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset.set(minX, minY);\n\t\t\tsize.set(maxX - minX, maxY - minY);\n\t\t};\n\t\tSkeleton.prototype.update = function (delta) {\n\t\t\tthis.time += delta;\n\t\t};\n\t\treturn Skeleton;\n\t}());\n\tspine.Skeleton = Skeleton;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkeletonBinary = (function () {\n\t\tfunction SkeletonBinary(attachmentLoader) {\n\t\t\tthis.scale = 1;\n\t\t\tthis.linkedMeshes = new Array();\n\t\t\tthis.attachmentLoader = attachmentLoader;\n\t\t}\n\t\tSkeletonBinary.prototype.readSkeletonData = function (binary) {\n\t\t\tvar scale = this.scale;\n\t\t\tvar skeletonData = new spine.SkeletonData();\n\t\t\tskeletonData.name = \"\";\n\t\t\tvar input = new BinaryInput(binary);\n\t\t\tskeletonData.hash = input.readString();\n\t\t\tskeletonData.version = input.readString();\n\t\t\tif (\"3.8.75\" == skeletonData.version)\n\t\t\t\tthrow new Error(\"Unsupported skeleton data, please export with a newer version of Spine.\");\n\t\t\tskeletonData.x = input.readFloat();\n\t\t\tskeletonData.y = input.readFloat();\n\t\t\tskeletonData.width = input.readFloat();\n\t\t\tskeletonData.height = input.readFloat();\n\t\t\tvar nonessential = input.readBoolean();\n\t\t\tif (nonessential) {\n\t\t\t\tskeletonData.fps = input.readFloat();\n\t\t\t\tskeletonData.imagesPath = input.readString();\n\t\t\t\tskeletonData.audioPath = input.readString();\n\t\t\t}\n\t\t\tvar n = 0;\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\tinput.strings.push(input.readString());\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar name_2 = input.readString();\n\t\t\t\tvar parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n\t\t\t\tvar data = new spine.BoneData(i, name_2, parent_2);\n\t\t\t\tdata.rotation = input.readFloat();\n\t\t\t\tdata.x = input.readFloat() * scale;\n\t\t\t\tdata.y = input.readFloat() * scale;\n\t\t\t\tdata.scaleX = input.readFloat();\n\t\t\t\tdata.scaleY = input.readFloat();\n\t\t\t\tdata.shearX = input.readFloat();\n\t\t\t\tdata.shearY = input.readFloat();\n\t\t\t\tdata.length = input.readFloat() * scale;\n\t\t\t\tdata.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\n\t\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\t\tif (nonessential)\n\t\t\t\t\tspine.Color.rgba8888ToColor(data.color, input.readInt32());\n\t\t\t\tskeletonData.bones.push(data);\n\t\t\t}\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar slotName = input.readString();\n\t\t\t\tvar boneData = skeletonData.bones[input.readInt(true)];\n\t\t\t\tvar data = new spine.SlotData(i, slotName, boneData);\n\t\t\t\tspine.Color.rgba8888ToColor(data.color, input.readInt32());\n\t\t\t\tvar darkColor = input.readInt32();\n\t\t\t\tif (darkColor != -1)\n\t\t\t\t\tspine.Color.rgb888ToColor(data.darkColor = new spine.Color(), darkColor);\n\t\t\t\tdata.attachmentName = input.readStringRef();\n\t\t\t\tdata.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\n\t\t\t\tskeletonData.slots.push(data);\n\t\t\t}\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0, nn = void 0; i < n; i++) {\n\t\t\t\tvar data = new spine.IkConstraintData(input.readString());\n\t\t\t\tdata.order = input.readInt(true);\n\t\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\t\tnn = input.readInt(true);\n\t\t\t\tfor (var ii = 0; ii < nn; ii++)\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\t\tdata.mix = input.readFloat();\n\t\t\t\tdata.softness = input.readFloat() * scale;\n\t\t\t\tdata.bendDirection = input.readByte();\n\t\t\t\tdata.compress = input.readBoolean();\n\t\t\t\tdata.stretch = input.readBoolean();\n\t\t\t\tdata.uniform = input.readBoolean();\n\t\t\t\tskeletonData.ikConstraints.push(data);\n\t\t\t}\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0, nn = void 0; i < n; i++) {\n\t\t\t\tvar data = new spine.TransformConstraintData(input.readString());\n\t\t\t\tdata.order = input.readInt(true);\n\t\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\t\tnn = input.readInt(true);\n\t\t\t\tfor (var ii = 0; ii < nn; ii++)\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\n\t\t\t\tdata.local = input.readBoolean();\n\t\t\t\tdata.relative = input.readBoolean();\n\t\t\t\tdata.offsetRotation = input.readFloat();\n\t\t\t\tdata.offsetX = input.readFloat() * scale;\n\t\t\t\tdata.offsetY = input.readFloat() * scale;\n\t\t\t\tdata.offsetScaleX = input.readFloat();\n\t\t\t\tdata.offsetScaleY = input.readFloat();\n\t\t\t\tdata.offsetShearY = input.readFloat();\n\t\t\t\tdata.rotateMix = input.readFloat();\n\t\t\t\tdata.translateMix = input.readFloat();\n\t\t\t\tdata.scaleMix = input.readFloat();\n\t\t\t\tdata.shearMix = input.readFloat();\n\t\t\t\tskeletonData.transformConstraints.push(data);\n\t\t\t}\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0, nn = void 0; i < n; i++) {\n\t\t\t\tvar data = new spine.PathConstraintData(input.readString());\n\t\t\t\tdata.order = input.readInt(true);\n\t\t\t\tdata.skinRequired = input.readBoolean();\n\t\t\t\tnn = input.readInt(true);\n\t\t\t\tfor (var ii = 0; ii < nn; ii++)\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\n\t\t\t\tdata.target = skeletonData.slots[input.readInt(true)];\n\t\t\t\tdata.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\n\t\t\t\tdata.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\n\t\t\t\tdata.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\n\t\t\t\tdata.offsetRotation = input.readFloat();\n\t\t\t\tdata.position = input.readFloat();\n\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\n\t\t\t\t\tdata.position *= scale;\n\t\t\t\tdata.spacing = input.readFloat();\n\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n\t\t\t\t\tdata.spacing *= scale;\n\t\t\t\tdata.rotateMix = input.readFloat();\n\t\t\t\tdata.translateMix = input.readFloat();\n\t\t\t\tskeletonData.pathConstraints.push(data);\n\t\t\t}\n\t\t\tvar defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\t\t\tif (defaultSkin != null) {\n\t\t\t\tskeletonData.defaultSkin = defaultSkin;\n\t\t\t\tskeletonData.skins.push(defaultSkin);\n\t\t\t}\n\t\t\t{\n\t\t\t\tvar i = skeletonData.skins.length;\n\t\t\t\tspine.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n\t\t\t\tfor (; i < n; i++)\n\t\t\t\t\tskeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n\t\t\t}\n\t\t\tn = this.linkedMeshes.length;\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar linkedMesh = this.linkedMeshes[i];\n\t\t\t\tvar skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\t\t\t\tif (skin == null)\n\t\t\t\t\tthrow new Error(\"Skin not found: \" + linkedMesh.skin);\n\t\t\t\tvar parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\t\t\t\tif (parent_3 == null)\n\t\t\t\t\tthrow new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n\t\t\t\tlinkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent_3);\n\t\t\t\tlinkedMesh.mesh.updateUVs();\n\t\t\t}\n\t\t\tthis.linkedMeshes.length = 0;\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar data = new spine.EventData(input.readStringRef());\n\t\t\t\tdata.intValue = input.readInt(false);\n\t\t\t\tdata.floatValue = input.readFloat();\n\t\t\t\tdata.stringValue = input.readString();\n\t\t\t\tdata.audioPath = input.readString();\n\t\t\t\tif (data.audioPath != null) {\n\t\t\t\t\tdata.volume = input.readFloat();\n\t\t\t\t\tdata.balance = input.readFloat();\n\t\t\t\t}\n\t\t\t\tskeletonData.events.push(data);\n\t\t\t}\n\t\t\tn = input.readInt(true);\n\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\tskeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n\t\t\treturn skeletonData;\n\t\t};\n\t\tSkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {\n\t\t\tvar skin = null;\n\t\t\tvar slotCount = 0;\n\t\t\tif (defaultSkin) {\n\t\t\t\tslotCount = input.readInt(true);\n\t\t\t\tif (slotCount == 0)\n\t\t\t\t\treturn null;\n\t\t\t\tskin = new spine.Skin(\"default\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskin = new spine.Skin(input.readStringRef());\n\t\t\t\tskin.bones.length = input.readInt(true);\n\t\t\t\tfor (var i = 0, n = skin.bones.length; i < n; i++)\n\t\t\t\t\tskin.bones[i] = skeletonData.bones[input.readInt(true)];\n\t\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\t\tskin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n\t\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\t\tskin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n\t\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++)\n\t\t\t\t\tskin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\t\t\t\tslotCount = input.readInt(true);\n\t\t\t}\n\t\t\tfor (var i = 0; i < slotCount; i++) {\n\t\t\t\tvar slotIndex = input.readInt(true);\n\t\t\t\tfor (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\t\tvar name_3 = input.readStringRef();\n\t\t\t\t\tvar attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);\n\t\t\t\t\tif (attachment != null)\n\t\t\t\t\t\tskin.setAttachment(slotIndex, name_3, attachment);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn skin;\n\t\t};\n\t\tSkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n\t\t\tvar scale = this.scale;\n\t\t\tvar name = input.readStringRef();\n\t\t\tif (name == null)\n\t\t\t\tname = attachmentName;\n\t\t\tvar typeIndex = input.readByte();\n\t\t\tvar type = SkeletonBinary.AttachmentTypeValues[typeIndex];\n\t\t\tswitch (type) {\n\t\t\t\tcase spine.AttachmentType.Region: {\n\t\t\t\t\tvar path = input.readStringRef();\n\t\t\t\t\tvar rotation = input.readFloat();\n\t\t\t\t\tvar x = input.readFloat();\n\t\t\t\t\tvar y = input.readFloat();\n\t\t\t\t\tvar scaleX = input.readFloat();\n\t\t\t\t\tvar scaleY = input.readFloat();\n\t\t\t\t\tvar width = input.readFloat();\n\t\t\t\t\tvar height = input.readFloat();\n\t\t\t\t\tvar color = input.readInt32();\n\t\t\t\t\tif (path == null)\n\t\t\t\t\t\tpath = name;\n\t\t\t\t\tvar region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\t\t\t\t\tif (region == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tregion.path = path;\n\t\t\t\t\tregion.x = x * scale;\n\t\t\t\t\tregion.y = y * scale;\n\t\t\t\t\tregion.scaleX = scaleX;\n\t\t\t\t\tregion.scaleY = scaleY;\n\t\t\t\t\tregion.rotation = rotation;\n\t\t\t\t\tregion.width = width * scale;\n\t\t\t\t\tregion.height = height * scale;\n\t\t\t\t\tspine.Color.rgba8888ToColor(region.color, color);\n\t\t\t\t\tregion.updateOffset();\n\t\t\t\t\treturn region;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.BoundingBox: {\n\t\t\t\t\tvar vertexCount = input.readInt(true);\n\t\t\t\t\tvar vertices = this.readVertices(input, vertexCount);\n\t\t\t\t\tvar color = nonessential ? input.readInt32() : 0;\n\t\t\t\t\tvar box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\t\t\t\t\tif (box == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tbox.worldVerticesLength = vertexCount << 1;\n\t\t\t\t\tbox.vertices = vertices.vertices;\n\t\t\t\t\tbox.bones = vertices.bones;\n\t\t\t\t\tif (nonessential)\n\t\t\t\t\t\tspine.Color.rgba8888ToColor(box.color, color);\n\t\t\t\t\treturn box;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.Mesh: {\n\t\t\t\t\tvar path = input.readStringRef();\n\t\t\t\t\tvar color = input.readInt32();\n\t\t\t\t\tvar vertexCount = input.readInt(true);\n\t\t\t\t\tvar uvs = this.readFloatArray(input, vertexCount << 1, 1);\n\t\t\t\t\tvar triangles = this.readShortArray(input);\n\t\t\t\t\tvar vertices = this.readVertices(input, vertexCount);\n\t\t\t\t\tvar hullLength = input.readInt(true);\n\t\t\t\t\tvar edges = null;\n\t\t\t\t\tvar width = 0, height = 0;\n\t\t\t\t\tif (nonessential) {\n\t\t\t\t\t\tedges = this.readShortArray(input);\n\t\t\t\t\t\twidth = input.readFloat();\n\t\t\t\t\t\theight = input.readFloat();\n\t\t\t\t\t}\n\t\t\t\t\tif (path == null)\n\t\t\t\t\t\tpath = name;\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\t\t\t\t\tif (mesh == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tmesh.path = path;\n\t\t\t\t\tspine.Color.rgba8888ToColor(mesh.color, color);\n\t\t\t\t\tmesh.bones = vertices.bones;\n\t\t\t\t\tmesh.vertices = vertices.vertices;\n\t\t\t\t\tmesh.worldVerticesLength = vertexCount << 1;\n\t\t\t\t\tmesh.triangles = triangles;\n\t\t\t\t\tmesh.regionUVs = uvs;\n\t\t\t\t\tmesh.updateUVs();\n\t\t\t\t\tmesh.hullLength = hullLength << 1;\n\t\t\t\t\tif (nonessential) {\n\t\t\t\t\t\tmesh.edges = edges;\n\t\t\t\t\t\tmesh.width = width * scale;\n\t\t\t\t\t\tmesh.height = height * scale;\n\t\t\t\t\t}\n\t\t\t\t\treturn mesh;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.LinkedMesh: {\n\t\t\t\t\tvar path = input.readStringRef();\n\t\t\t\t\tvar color = input.readInt32();\n\t\t\t\t\tvar skinName = input.readStringRef();\n\t\t\t\t\tvar parent_4 = input.readStringRef();\n\t\t\t\t\tvar inheritDeform = input.readBoolean();\n\t\t\t\t\tvar width = 0, height = 0;\n\t\t\t\t\tif (nonessential) {\n\t\t\t\t\t\twidth = input.readFloat();\n\t\t\t\t\t\theight = input.readFloat();\n\t\t\t\t\t}\n\t\t\t\t\tif (path == null)\n\t\t\t\t\t\tpath = name;\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\t\t\t\t\tif (mesh == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tmesh.path = path;\n\t\t\t\t\tspine.Color.rgba8888ToColor(mesh.color, color);\n\t\t\t\t\tif (nonessential) {\n\t\t\t\t\t\tmesh.width = width * scale;\n\t\t\t\t\t\tmesh.height = height * scale;\n\t\t\t\t\t}\n\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));\n\t\t\t\t\treturn mesh;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.Path: {\n\t\t\t\t\tvar closed_1 = input.readBoolean();\n\t\t\t\t\tvar constantSpeed = input.readBoolean();\n\t\t\t\t\tvar vertexCount = input.readInt(true);\n\t\t\t\t\tvar vertices = this.readVertices(input, vertexCount);\n\t\t\t\t\tvar lengths = spine.Utils.newArray(vertexCount / 3, 0);\n\t\t\t\t\tfor (var i = 0, n = lengths.length; i < n; i++)\n\t\t\t\t\t\tlengths[i] = input.readFloat() * scale;\n\t\t\t\t\tvar color = nonessential ? input.readInt32() : 0;\n\t\t\t\t\tvar path = this.attachmentLoader.newPathAttachment(skin, name);\n\t\t\t\t\tif (path == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tpath.closed = closed_1;\n\t\t\t\t\tpath.constantSpeed = constantSpeed;\n\t\t\t\t\tpath.worldVerticesLength = vertexCount << 1;\n\t\t\t\t\tpath.vertices = vertices.vertices;\n\t\t\t\t\tpath.bones = vertices.bones;\n\t\t\t\t\tpath.lengths = lengths;\n\t\t\t\t\tif (nonessential)\n\t\t\t\t\t\tspine.Color.rgba8888ToColor(path.color, color);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.Point: {\n\t\t\t\t\tvar rotation = input.readFloat();\n\t\t\t\t\tvar x = input.readFloat();\n\t\t\t\t\tvar y = input.readFloat();\n\t\t\t\t\tvar color = nonessential ? input.readInt32() : 0;\n\t\t\t\t\tvar point = this.attachmentLoader.newPointAttachment(skin, name);\n\t\t\t\t\tif (point == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tpoint.x = x * scale;\n\t\t\t\t\tpoint.y = y * scale;\n\t\t\t\t\tpoint.rotation = rotation;\n\t\t\t\t\tif (nonessential)\n\t\t\t\t\t\tspine.Color.rgba8888ToColor(point.color, color);\n\t\t\t\t\treturn point;\n\t\t\t\t}\n\t\t\t\tcase spine.AttachmentType.Clipping: {\n\t\t\t\t\tvar endSlotIndex = input.readInt(true);\n\t\t\t\t\tvar vertexCount = input.readInt(true);\n\t\t\t\t\tvar vertices = this.readVertices(input, vertexCount);\n\t\t\t\t\tvar color = nonessential ? input.readInt32() : 0;\n\t\t\t\t\tvar clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\t\t\t\t\tif (clip == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tclip.endSlot = skeletonData.slots[endSlotIndex];\n\t\t\t\t\tclip.worldVerticesLength = vertexCount << 1;\n\t\t\t\t\tclip.vertices = vertices.vertices;\n\t\t\t\t\tclip.bones = vertices.bones;\n\t\t\t\t\tif (nonessential)\n\t\t\t\t\t\tspine.Color.rgba8888ToColor(clip.color, color);\n\t\t\t\t\treturn clip;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonBinary.prototype.readVertices = function (input, vertexCount) {\n\t\t\tvar verticesLength = vertexCount << 1;\n\t\t\tvar vertices = new Vertices();\n\t\t\tvar scale = this.scale;\n\t\t\tif (!input.readBoolean()) {\n\t\t\t\tvertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\t\t\t\treturn vertices;\n\t\t\t}\n\t\t\tvar weights = new Array();\n\t\t\tvar bonesArray = new Array();\n\t\t\tfor (var i = 0; i < vertexCount; i++) {\n\t\t\t\tvar boneCount = input.readInt(true);\n\t\t\t\tbonesArray.push(boneCount);\n\t\t\t\tfor (var ii = 0; ii < boneCount; ii++) {\n\t\t\t\t\tbonesArray.push(input.readInt(true));\n\t\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\t\tweights.push(input.readFloat() * scale);\n\t\t\t\t\tweights.push(input.readFloat());\n\t\t\t\t}\n\t\t\t}\n\t\t\tvertices.vertices = spine.Utils.toFloatArray(weights);\n\t\t\tvertices.bones = bonesArray;\n\t\t\treturn vertices;\n\t\t};\n\t\tSkeletonBinary.prototype.readFloatArray = function (input, n, scale) {\n\t\t\tvar array = new Array(n);\n\t\t\tif (scale == 1) {\n\t\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\t\tarray[i] = input.readFloat();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\t\tarray[i] = input.readFloat() * scale;\n\t\t\t}\n\t\t\treturn array;\n\t\t};\n\t\tSkeletonBinary.prototype.readShortArray = function (input) {\n\t\t\tvar n = input.readInt(true);\n\t\t\tvar array = new Array(n);\n\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\tarray[i] = input.readShort();\n\t\t\treturn array;\n\t\t};\n\t\tSkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {\n\t\t\tvar timelines = new Array();\n\t\t\tvar scale = this.scale;\n\t\t\tvar duration = 0;\n\t\t\tvar tempColor1 = new spine.Color();\n\t\t\tvar tempColor2 = new spine.Color();\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar slotIndex = input.readInt(true);\n\t\t\t\tfor (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\t\tvar timelineType = input.readByte();\n\t\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\t\tswitch (timelineType) {\n\t\t\t\t\t\tcase SkeletonBinary.SLOT_ATTACHMENT: {\n\t\t\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(frameCount);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++)\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SkeletonBinary.SLOT_COLOR: {\n\t\t\t\t\t\t\tvar timeline = new spine.ColorTimeline(frameCount);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\tvar time = input.readFloat();\n\t\t\t\t\t\t\t\tspine.Color.rgba8888ToColor(tempColor1, input.readInt32());\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.ColorTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SkeletonBinary.SLOT_TWO_COLOR: {\n\t\t\t\t\t\t\tvar timeline = new spine.TwoColorTimeline(frameCount);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\tvar time = input.readFloat();\n\t\t\t\t\t\t\t\tspine.Color.rgba8888ToColor(tempColor1, input.readInt32());\n\t\t\t\t\t\t\t\tspine.Color.rgb888ToColor(tempColor2, input.readInt32());\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TwoColorTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar boneIndex = input.readInt(true);\n\t\t\t\tfor (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\t\tvar timelineType = input.readByte();\n\t\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\t\tswitch (timelineType) {\n\t\t\t\t\t\tcase SkeletonBinary.BONE_ROTATE: {\n\t\t\t\t\t\t\tvar timeline = new spine.RotateTimeline(frameCount);\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.RotateTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SkeletonBinary.BONE_TRANSLATE:\n\t\t\t\t\t\tcase SkeletonBinary.BONE_SCALE:\n\t\t\t\t\t\tcase SkeletonBinary.BONE_SHEAR: {\n\t\t\t\t\t\t\tvar timeline = void 0;\n\t\t\t\t\t\t\tvar timelineScale = 1;\n\t\t\t\t\t\t\tif (timelineType == SkeletonBinary.BONE_SCALE)\n\t\t\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(frameCount);\n\t\t\t\t\t\t\telse if (timelineType == SkeletonBinary.BONE_SHEAR)\n\t\t\t\t\t\t\t\ttimeline = new spine.ShearTimeline(frameCount);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(frameCount);\n\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TranslateTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar index = input.readInt(true);\n\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\tvar timeline = new spine.IkConstraintTimeline(frameCount);\n\t\t\t\ttimeline.ikConstraintIndex = index;\n\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\n\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.IkConstraintTimeline.ENTRIES]);\n\t\t\t}\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar index = input.readInt(true);\n\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\tvar timeline = new spine.TransformConstraintTimeline(frameCount);\n\t\t\t\ttimeline.transformConstraintIndex = index;\n\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TransformConstraintTimeline.ENTRIES]);\n\t\t\t}\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar index = input.readInt(true);\n\t\t\t\tvar data = skeletonData.pathConstraints[index];\n\t\t\t\tfor (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\t\tvar timelineType = input.readByte();\n\t\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\t\tswitch (timelineType) {\n\t\t\t\t\t\tcase SkeletonBinary.PATH_POSITION:\n\t\t\t\t\t\tcase SkeletonBinary.PATH_SPACING: {\n\t\t\t\t\t\t\tvar timeline = void 0;\n\t\t\t\t\t\t\tvar timelineScale = 1;\n\t\t\t\t\t\t\tif (timelineType == SkeletonBinary.PATH_SPACING) {\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintSpacingTimeline(frameCount);\n\t\t\t\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintPositionTimeline(frameCount);\n\t\t\t\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SkeletonBinary.PATH_MIX: {\n\t\t\t\t\t\t\tvar timeline = new spine.PathConstraintMixTimeline(frameCount);\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\n\t\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, n = input.readInt(true); i < n; i++) {\n\t\t\t\tvar skin = skeletonData.skins[input.readInt(true)];\n\t\t\t\tfor (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n\t\t\t\t\tvar slotIndex = input.readInt(true);\n\t\t\t\t\tfor (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n\t\t\t\t\t\tvar attachment = skin.getAttachment(slotIndex, input.readStringRef());\n\t\t\t\t\t\tvar weighted = attachment.bones != null;\n\t\t\t\t\t\tvar vertices = attachment.vertices;\n\t\t\t\t\t\tvar deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\t\t\t\t\t\tvar frameCount = input.readInt(true);\n\t\t\t\t\t\tvar timeline = new spine.DeformTimeline(frameCount);\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\ttimeline.attachment = attachment;\n\t\t\t\t\t\tfor (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n\t\t\t\t\t\t\tvar time = input.readFloat();\n\t\t\t\t\t\t\tvar deform = void 0;\n\t\t\t\t\t\t\tvar end = input.readInt(true);\n\t\t\t\t\t\t\tif (end == 0)\n\t\t\t\t\t\t\t\tdeform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdeform = spine.Utils.newFloatArray(deformLength);\n\t\t\t\t\t\t\t\tvar start = input.readInt(true);\n\t\t\t\t\t\t\t\tend += start;\n\t\t\t\t\t\t\t\tif (scale == 1) {\n\t\t\t\t\t\t\t\t\tfor (var v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (var v = start; v < end; v++)\n\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat() * scale;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!weighted) {\n\t\t\t\t\t\t\t\t\tfor (var v = 0, vn = deform.length; v < vn; v++)\n\t\t\t\t\t\t\t\t\t\tdeform[v] += vertices[v];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, deform);\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1)\n\t\t\t\t\t\t\t\tthis.readCurve(input, frameIndex, timeline);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar drawOrderCount = input.readInt(true);\n\t\t\tif (drawOrderCount > 0) {\n\t\t\t\tvar timeline = new spine.DrawOrderTimeline(drawOrderCount);\n\t\t\t\tvar slotCount = skeletonData.slots.length;\n\t\t\t\tfor (var i = 0; i < drawOrderCount; i++) {\n\t\t\t\t\tvar time = input.readFloat();\n\t\t\t\t\tvar offsetCount = input.readInt(true);\n\t\t\t\t\tvar drawOrder = spine.Utils.newArray(slotCount, 0);\n\t\t\t\t\tfor (var ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\t\tdrawOrder[ii] = -1;\n\t\t\t\t\tvar unchanged = spine.Utils.newArray(slotCount - offsetCount, 0);\n\t\t\t\t\tvar originalIndex = 0, unchangedIndex = 0;\n\t\t\t\t\tfor (var ii = 0; ii < offsetCount; ii++) {\n\t\t\t\t\t\tvar slotIndex = input.readInt(true);\n\t\t\t\t\t\twhile (originalIndex != slotIndex)\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t\tdrawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (originalIndex < slotCount)\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\tfor (var ii = slotCount - 1; ii >= 0; ii--)\n\t\t\t\t\t\tif (drawOrder[ii] == -1)\n\t\t\t\t\t\t\tdrawOrder[ii] = unchanged[--unchangedIndex];\n\t\t\t\t\ttimeline.setFrame(i, time, drawOrder);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\n\t\t\t}\n\t\t\tvar eventCount = input.readInt(true);\n\t\t\tif (eventCount > 0) {\n\t\t\t\tvar timeline = new spine.EventTimeline(eventCount);\n\t\t\t\tfor (var i = 0; i < eventCount; i++) {\n\t\t\t\t\tvar time = input.readFloat();\n\t\t\t\t\tvar eventData = skeletonData.events[input.readInt(true)];\n\t\t\t\t\tvar event_4 = new spine.Event(time, eventData);\n\t\t\t\t\tevent_4.intValue = input.readInt(false);\n\t\t\t\t\tevent_4.floatValue = input.readFloat();\n\t\t\t\t\tevent_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n\t\t\t\t\tif (event_4.data.audioPath != null) {\n\t\t\t\t\t\tevent_4.volume = input.readFloat();\n\t\t\t\t\t\tevent_4.balance = input.readFloat();\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.setFrame(i, event_4);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[eventCount - 1]);\n\t\t\t}\n\t\t\treturn new spine.Animation(name, timelines, duration);\n\t\t};\n\t\tSkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {\n\t\t\tswitch (input.readByte()) {\n\t\t\t\tcase SkeletonBinary.CURVE_STEPPED:\n\t\t\t\t\ttimeline.setStepped(frameIndex);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SkeletonBinary.CURVE_BEZIER:\n\t\t\t\t\tthis.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tSkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {\n\t\t\ttimeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\n\t\t};\n\t\tSkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];\n\t\tSkeletonBinary.TransformModeValues = [spine.TransformMode.Normal, spine.TransformMode.OnlyTranslation, spine.TransformMode.NoRotationOrReflection, spine.TransformMode.NoScale, spine.TransformMode.NoScaleOrReflection];\n\t\tSkeletonBinary.PositionModeValues = [spine.PositionMode.Fixed, spine.PositionMode.Percent];\n\t\tSkeletonBinary.SpacingModeValues = [spine.SpacingMode.Length, spine.SpacingMode.Fixed, spine.SpacingMode.Percent];\n\t\tSkeletonBinary.RotateModeValues = [spine.RotateMode.Tangent, spine.RotateMode.Chain, spine.RotateMode.ChainScale];\n\t\tSkeletonBinary.BlendModeValues = [spine.BlendMode.Normal, spine.BlendMode.Additive, spine.BlendMode.Multiply, spine.BlendMode.Screen];\n\t\tSkeletonBinary.BONE_ROTATE = 0;\n\t\tSkeletonBinary.BONE_TRANSLATE = 1;\n\t\tSkeletonBinary.BONE_SCALE = 2;\n\t\tSkeletonBinary.BONE_SHEAR = 3;\n\t\tSkeletonBinary.SLOT_ATTACHMENT = 0;\n\t\tSkeletonBinary.SLOT_COLOR = 1;\n\t\tSkeletonBinary.SLOT_TWO_COLOR = 2;\n\t\tSkeletonBinary.PATH_POSITION = 0;\n\t\tSkeletonBinary.PATH_SPACING = 1;\n\t\tSkeletonBinary.PATH_MIX = 2;\n\t\tSkeletonBinary.CURVE_LINEAR = 0;\n\t\tSkeletonBinary.CURVE_STEPPED = 1;\n\t\tSkeletonBinary.CURVE_BEZIER = 2;\n\t\treturn SkeletonBinary;\n\t}());\n\tspine.SkeletonBinary = SkeletonBinary;\n\tvar BinaryInput = (function () {\n\t\tfunction BinaryInput(data, strings, index, buffer) {\n\t\t\tif (strings === void 0) { strings = new Array(); }\n\t\t\tif (index === void 0) { index = 0; }\n\t\t\tif (buffer === void 0) { buffer = new DataView(data.buffer); }\n\t\t\tthis.strings = strings;\n\t\t\tthis.index = index;\n\t\t\tthis.buffer = buffer;\n\t\t}\n\t\tBinaryInput.prototype.readByte = function () {\n\t\t\treturn this.buffer.getInt8(this.index++);\n\t\t};\n\t\tBinaryInput.prototype.readShort = function () {\n\t\t\tvar value = this.buffer.getInt16(this.index);\n\t\t\tthis.index += 2;\n\t\t\treturn value;\n\t\t};\n\t\tBinaryInput.prototype.readInt32 = function () {\n\t\t\tvar value = this.buffer.getInt32(this.index);\n\t\t\tthis.index += 4;\n\t\t\treturn value;\n\t\t};\n\t\tBinaryInput.prototype.readInt = function (optimizePositive) {\n\t\t\tvar b = this.readByte();\n\t\t\tvar result = b & 0x7F;\n\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\tb = this.readByte();\n\t\t\t\tresult |= (b & 0x7F) << 7;\n\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\tb = this.readByte();\n\t\t\t\t\tresult |= (b & 0x7F) << 14;\n\t\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\t\tb = this.readByte();\n\t\t\t\t\t\tresult |= (b & 0x7F) << 21;\n\t\t\t\t\t\tif ((b & 0x80) != 0) {\n\t\t\t\t\t\t\tb = this.readByte();\n\t\t\t\t\t\t\tresult |= (b & 0x7F) << 28;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\n\t\t};\n\t\tBinaryInput.prototype.readStringRef = function () {\n\t\t\tvar index = this.readInt(true);\n\t\t\treturn index == 0 ? null : this.strings[index - 1];\n\t\t};\n\t\tBinaryInput.prototype.readString = function () {\n\t\t\tvar byteCount = this.readInt(true);\n\t\t\tswitch (byteCount) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn null;\n\t\t\t\tcase 1:\n\t\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tbyteCount--;\n\t\t\tvar chars = \"\";\n\t\t\tvar charCount = 0;\n\t\t\tfor (var i = 0; i < byteCount;) {\n\t\t\t\tvar b = this.readByte();\n\t\t\t\tswitch (b >> 4) {\n\t\t\t\t\tcase 12:\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\tchars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 14:\n\t\t\t\t\t\tchars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tchars += String.fromCharCode(b);\n\t\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t};\n\t\tBinaryInput.prototype.readFloat = function () {\n\t\t\tvar value = this.buffer.getFloat32(this.index);\n\t\t\tthis.index += 4;\n\t\t\treturn value;\n\t\t};\n\t\tBinaryInput.prototype.readBoolean = function () {\n\t\t\treturn this.readByte() != 0;\n\t\t};\n\t\treturn BinaryInput;\n\t}());\n\tvar LinkedMesh = (function () {\n\t\tfunction LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.skin = skin;\n\t\t\tthis.slotIndex = slotIndex;\n\t\t\tthis.parent = parent;\n\t\t\tthis.inheritDeform = inheritDeform;\n\t\t}\n\t\treturn LinkedMesh;\n\t}());\n\tvar Vertices = (function () {\n\t\tfunction Vertices(bones, vertices) {\n\t\t\tif (bones === void 0) { bones = null; }\n\t\t\tif (vertices === void 0) { vertices = null; }\n\t\t\tthis.bones = bones;\n\t\t\tthis.vertices = vertices;\n\t\t}\n\t\treturn Vertices;\n\t}());\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkeletonBounds = (function () {\n\t\tfunction SkeletonBounds() {\n\t\t\tthis.minX = 0;\n\t\t\tthis.minY = 0;\n\t\t\tthis.maxX = 0;\n\t\t\tthis.maxY = 0;\n\t\t\tthis.boundingBoxes = new Array();\n\t\t\tthis.polygons = new Array();\n\t\t\tthis.polygonPool = new spine.Pool(function () {\n\t\t\t\treturn spine.Utils.newFloatArray(16);\n\t\t\t});\n\t\t}\n\t\tSkeletonBounds.prototype.update = function (skeleton, updateAabb) {\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tvar boundingBoxes = this.boundingBoxes;\n\t\t\tvar polygons = this.polygons;\n\t\t\tvar polygonPool = this.polygonPool;\n\t\t\tvar slots = skeleton.slots;\n\t\t\tvar slotCount = slots.length;\n\t\t\tboundingBoxes.length = 0;\n\t\t\tpolygonPool.freeAll(polygons);\n\t\t\tpolygons.length = 0;\n\t\t\tfor (var i = 0; i < slotCount; i++) {\n\t\t\t\tvar slot = slots[i];\n\t\t\t\tif (!slot.bone.active)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\tif (attachment instanceof spine.BoundingBoxAttachment) {\n\t\t\t\t\tvar boundingBox = attachment;\n\t\t\t\t\tboundingBoxes.push(boundingBox);\n\t\t\t\t\tvar polygon = polygonPool.obtain();\n\t\t\t\t\tif (polygon.length != boundingBox.worldVerticesLength) {\n\t\t\t\t\t\tpolygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\n\t\t\t\t\t}\n\t\t\t\t\tpolygons.push(polygon);\n\t\t\t\t\tboundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (updateAabb) {\n\t\t\t\tthis.aabbCompute();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.minX = Number.POSITIVE_INFINITY;\n\t\t\t\tthis.minY = Number.POSITIVE_INFINITY;\n\t\t\t\tthis.maxX = Number.NEGATIVE_INFINITY;\n\t\t\t\tthis.maxY = Number.NEGATIVE_INFINITY;\n\t\t\t}\n\t\t};\n\t\tSkeletonBounds.prototype.aabbCompute = function () {\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n\t\t\tvar polygons = this.polygons;\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\n\t\t\t\tvar polygon = polygons[i];\n\t\t\t\tvar vertices = polygon;\n\t\t\t\tfor (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n\t\t\t\t\tvar x = vertices[ii];\n\t\t\t\t\tvar y = vertices[ii + 1];\n\t\t\t\t\tminX = Math.min(minX, x);\n\t\t\t\t\tminY = Math.min(minY, y);\n\t\t\t\t\tmaxX = Math.max(maxX, x);\n\t\t\t\t\tmaxY = Math.max(maxY, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.minX = minX;\n\t\t\tthis.minY = minY;\n\t\t\tthis.maxX = maxX;\n\t\t\tthis.maxY = maxY;\n\t\t};\n\t\tSkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\n\t\t\treturn x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n\t\t};\n\t\tSkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\n\t\t\tvar minX = this.minX;\n\t\t\tvar minY = this.minY;\n\t\t\tvar maxX = this.maxX;\n\t\t\tvar maxY = this.maxY;\n\t\t\tif ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n\t\t\t\treturn false;\n\t\t\tvar m = (y2 - y1) / (x2 - x1);\n\t\t\tvar y = m * (minX - x1) + y1;\n\t\t\tif (y > minY && y < maxY)\n\t\t\t\treturn true;\n\t\t\ty = m * (maxX - x1) + y1;\n\t\t\tif (y > minY && y < maxY)\n\t\t\t\treturn true;\n\t\t\tvar x = (minY - y1) / m + x1;\n\t\t\tif (x > minX && x < maxX)\n\t\t\t\treturn true;\n\t\t\tx = (maxY - y1) / m + x1;\n\t\t\tif (x > minX && x < maxX)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t};\n\t\tSkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\n\t\t\treturn this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n\t\t};\n\t\tSkeletonBounds.prototype.containsPoint = function (x, y) {\n\t\t\tvar polygons = this.polygons;\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\n\t\t\t\tif (this.containsPointPolygon(polygons[i], x, y))\n\t\t\t\t\treturn this.boundingBoxes[i];\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\n\t\t\tvar vertices = polygon;\n\t\t\tvar nn = polygon.length;\n\t\t\tvar prevIndex = nn - 2;\n\t\t\tvar inside = false;\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\n\t\t\t\tvar vertexY = vertices[ii + 1];\n\t\t\t\tvar prevY = vertices[prevIndex + 1];\n\t\t\t\tif ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n\t\t\t\t\tvar vertexX = vertices[ii];\n\t\t\t\t\tif (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\n\t\t\t\t\t\tinside = !inside;\n\t\t\t\t}\n\t\t\t\tprevIndex = ii;\n\t\t\t}\n\t\t\treturn inside;\n\t\t};\n\t\tSkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\n\t\t\tvar polygons = this.polygons;\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\n\t\t\t\tif (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\n\t\t\t\t\treturn this.boundingBoxes[i];\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\n\t\t\tvar vertices = polygon;\n\t\t\tvar nn = polygon.length;\n\t\t\tvar width12 = x1 - x2, height12 = y1 - y2;\n\t\t\tvar det1 = x1 * y2 - y1 * x2;\n\t\t\tvar x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\n\t\t\t\tvar x4 = vertices[ii], y4 = vertices[ii + 1];\n\t\t\t\tvar det2 = x3 * y4 - y3 * x4;\n\t\t\t\tvar width34 = x3 - x4, height34 = y3 - y4;\n\t\t\t\tvar det3 = width12 * height34 - height12 * width34;\n\t\t\t\tvar x = (det1 * width34 - width12 * det2) / det3;\n\t\t\t\tif (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n\t\t\t\t\tvar y = (det1 * height34 - height12 * det2) / det3;\n\t\t\t\t\tif (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tx3 = x4;\n\t\t\t\ty3 = y4;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tSkeletonBounds.prototype.getPolygon = function (boundingBox) {\n\t\t\tif (boundingBox == null)\n\t\t\t\tthrow new Error(\"boundingBox cannot be null.\");\n\t\t\tvar index = this.boundingBoxes.indexOf(boundingBox);\n\t\t\treturn index == -1 ? null : this.polygons[index];\n\t\t};\n\t\tSkeletonBounds.prototype.getWidth = function () {\n\t\t\treturn this.maxX - this.minX;\n\t\t};\n\t\tSkeletonBounds.prototype.getHeight = function () {\n\t\t\treturn this.maxY - this.minY;\n\t\t};\n\t\treturn SkeletonBounds;\n\t}());\n\tspine.SkeletonBounds = SkeletonBounds;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkeletonClipping = (function () {\n\t\tfunction SkeletonClipping() {\n\t\t\tthis.triangulator = new spine.Triangulator();\n\t\t\tthis.clippingPolygon = new Array();\n\t\t\tthis.clipOutput = new Array();\n\t\t\tthis.clippedVertices = new Array();\n\t\t\tthis.clippedTriangles = new Array();\n\t\t\tthis.scratch = new Array();\n\t\t}\n\t\tSkeletonClipping.prototype.clipStart = function (slot, clip) {\n\t\t\tif (this.clipAttachment != null)\n\t\t\t\treturn 0;\n\t\t\tthis.clipAttachment = clip;\n\t\t\tvar n = clip.worldVerticesLength;\n\t\t\tvar vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n\t\t\tvar clippingPolygon = this.clippingPolygon;\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\n\t\t\tvar clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\t\t\tfor (var i = 0, n_2 = clippingPolygons.length; i < n_2; i++) {\n\t\t\t\tvar polygon = clippingPolygons[i];\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\n\t\t\t\tpolygon.push(polygon[0]);\n\t\t\t\tpolygon.push(polygon[1]);\n\t\t\t}\n\t\t\treturn clippingPolygons.length;\n\t\t};\n\t\tSkeletonClipping.prototype.clipEndWithSlot = function (slot) {\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\n\t\t\t\tthis.clipEnd();\n\t\t};\n\t\tSkeletonClipping.prototype.clipEnd = function () {\n\t\t\tif (this.clipAttachment == null)\n\t\t\t\treturn;\n\t\t\tthis.clipAttachment = null;\n\t\t\tthis.clippingPolygons = null;\n\t\t\tthis.clippedVertices.length = 0;\n\t\t\tthis.clippedTriangles.length = 0;\n\t\t\tthis.clippingPolygon.length = 0;\n\t\t};\n\t\tSkeletonClipping.prototype.isClipping = function () {\n\t\t\treturn this.clipAttachment != null;\n\t\t};\n\t\tSkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\n\t\t\tvar clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\t\tvar clippedTriangles = this.clippedTriangles;\n\t\t\tvar polygons = this.clippingPolygons;\n\t\t\tvar polygonsCount = this.clippingPolygons.length;\n\t\t\tvar vertexSize = twoColor ? 12 : 8;\n\t\t\tvar index = 0;\n\t\t\tclippedVertices.length = 0;\n\t\t\tclippedTriangles.length = 0;\n\t\t\touter: for (var i = 0; i < trianglesLength; i += 3) {\n\t\t\t\tvar vertexOffset = triangles[i] << 1;\n\t\t\t\tvar x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\t\tvar u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\t\tvar x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\t\tvar u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\t\tvar x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\t\tvar u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\t\t\t\tfor (var p = 0; p < polygonsCount; p++) {\n\t\t\t\t\tvar s = clippedVertices.length;\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\t\tvar clipOutputLength = clipOutput.length;\n\t\t\t\t\t\tif (clipOutputLength == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\t\tvar d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\t\t\t\t\t\tvar clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\t\tvar clipOutputItems = this.clipOutput;\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\t\t\t\t\t\tfor (var ii = 0; ii < clipOutputLength; ii += 2) {\n\t\t\t\t\t\t\tvar x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\t\tvar c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\t\tvar a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\t\tvar b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\t\tvar c = 1 - a - b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t\t\tif (twoColor) {\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts += vertexSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\t\tfor (var ii = 1; ii < clipOutputCount; ii++) {\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex += clipOutputCount + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\tif (!twoColor) {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\t\tindex += 3;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\n\t\t\tvar originalOutput = output;\n\t\t\tvar clipped = false;\n\t\t\tvar input = null;\n\t\t\tif (clippingArea.length % 4 >= 2) {\n\t\t\t\tinput = output;\n\t\t\t\toutput = this.scratch;\n\t\t\t}\n\t\t\telse\n\t\t\t\tinput = this.scratch;\n\t\t\tinput.length = 0;\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\tinput.push(x2);\n\t\t\tinput.push(y2);\n\t\t\tinput.push(x3);\n\t\t\tinput.push(y3);\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\toutput.length = 0;\n\t\t\tvar clippingVertices = clippingArea;\n\t\t\tvar clippingVerticesLast = clippingArea.length - 4;\n\t\t\tfor (var i = 0;; i += 2) {\n\t\t\t\tvar edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n\t\t\t\tvar edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\n\t\t\t\tvar deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\n\t\t\t\tvar inputVertices = input;\n\t\t\t\tvar inputVerticesLength = input.length - 2, outputStart = output.length;\n\t\t\t\tfor (var ii = 0; ii < inputVerticesLength; ii += 2) {\n\t\t\t\t\tvar inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n\t\t\t\t\tvar inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\n\t\t\t\t\tvar side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n\t\t\t\t\t\tif (side2) {\n\t\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tvar s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n\t\t\t\t\t\tif (Math.abs(s) > 0.000001) {\n\t\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n\t\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toutput.push(edgeX);\n\t\t\t\t\t\t\toutput.push(edgeY);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (side2) {\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tvar s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n\t\t\t\t\t\tif (Math.abs(s) > 0.000001) {\n\t\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n\t\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toutput.push(edgeX);\n\t\t\t\t\t\t\toutput.push(edgeY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t}\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\t\t\t\tif (outputStart == output.length) {\n\t\t\t\t\toriginalOutput.length = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\toutput.push(output[0]);\n\t\t\t\toutput.push(output[1]);\n\t\t\t\tif (i == clippingVerticesLast)\n\t\t\t\t\tbreak;\n\t\t\t\tvar temp = output;\n\t\t\t\toutput = input;\n\t\t\t\toutput.length = 0;\n\t\t\t\tinput = temp;\n\t\t\t}\n\t\t\tif (originalOutput != output) {\n\t\t\t\toriginalOutput.length = 0;\n\t\t\t\tfor (var i = 0, n = output.length - 2; i < n; i++)\n\t\t\t\t\toriginalOutput[i] = output[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\n\t\t\treturn clipped;\n\t\t};\n\t\tSkeletonClipping.makeClockwise = function (polygon) {\n\t\t\tvar vertices = polygon;\n\t\t\tvar verticeslength = polygon.length;\n\t\t\tvar area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n\t\t\tfor (var i = 0, n = verticeslength - 3; i < n; i += 2) {\n\t\t\t\tp1x = vertices[i];\n\t\t\t\tp1y = vertices[i + 1];\n\t\t\t\tp2x = vertices[i + 2];\n\t\t\t\tp2y = vertices[i + 3];\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\n\t\t\t}\n\t\t\tif (area < 0)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n\t\t\t\tvar x = vertices[i], y = vertices[i + 1];\n\t\t\t\tvar other = lastX - i;\n\t\t\t\tvertices[i] = vertices[other];\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\n\t\t\t\tvertices[other] = x;\n\t\t\t\tvertices[other + 1] = y;\n\t\t\t}\n\t\t};\n\t\treturn SkeletonClipping;\n\t}());\n\tspine.SkeletonClipping = SkeletonClipping;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkeletonData = (function () {\n\t\tfunction SkeletonData() {\n\t\t\tthis.bones = new Array();\n\t\t\tthis.slots = new Array();\n\t\t\tthis.skins = new Array();\n\t\t\tthis.events = new Array();\n\t\t\tthis.animations = new Array();\n\t\t\tthis.ikConstraints = new Array();\n\t\t\tthis.transformConstraints = new Array();\n\t\t\tthis.pathConstraints = new Array();\n\t\t\tthis.fps = 0;\n\t\t}\n\t\tSkeletonData.prototype.findBone = function (boneName) {\n\t\t\tif (boneName == null)\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tif (bone.name == boneName)\n\t\t\t\t\treturn bone;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findBoneIndex = function (boneName) {\n\t\t\tif (boneName == null)\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\n\t\t\t\tif (bones[i].name == boneName)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\tSkeletonData.prototype.findSlot = function (slotName) {\n\t\t\tif (slotName == null)\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\n\t\t\tvar slots = this.slots;\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\tvar slot = slots[i];\n\t\t\t\tif (slot.name == slotName)\n\t\t\t\t\treturn slot;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findSlotIndex = function (slotName) {\n\t\t\tif (slotName == null)\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\n\t\t\tvar slots = this.slots;\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\n\t\t\t\tif (slots[i].name == slotName)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\tSkeletonData.prototype.findSkin = function (skinName) {\n\t\t\tif (skinName == null)\n\t\t\t\tthrow new Error(\"skinName cannot be null.\");\n\t\t\tvar skins = this.skins;\n\t\t\tfor (var i = 0, n = skins.length; i < n; i++) {\n\t\t\t\tvar skin = skins[i];\n\t\t\t\tif (skin.name == skinName)\n\t\t\t\t\treturn skin;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findEvent = function (eventDataName) {\n\t\t\tif (eventDataName == null)\n\t\t\t\tthrow new Error(\"eventDataName cannot be null.\");\n\t\t\tvar events = this.events;\n\t\t\tfor (var i = 0, n = events.length; i < n; i++) {\n\t\t\t\tvar event_5 = events[i];\n\t\t\t\tif (event_5.name == eventDataName)\n\t\t\t\t\treturn event_5;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findAnimation = function (animationName) {\n\t\t\tif (animationName == null)\n\t\t\t\tthrow new Error(\"animationName cannot be null.\");\n\t\t\tvar animations = this.animations;\n\t\t\tfor (var i = 0, n = animations.length; i < n; i++) {\n\t\t\t\tvar animation = animations[i];\n\t\t\t\tif (animation.name == animationName)\n\t\t\t\t\treturn animation;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findIkConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar ikConstraints = this.ikConstraints;\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = ikConstraints[i];\n\t\t\t\tif (constraint.name == constraintName)\n\t\t\t\t\treturn constraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findTransformConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar transformConstraints = this.transformConstraints;\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = transformConstraints[i];\n\t\t\t\tif (constraint.name == constraintName)\n\t\t\t\t\treturn constraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findPathConstraint = function (constraintName) {\n\t\t\tif (constraintName == null)\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\n\t\t\tvar pathConstraints = this.pathConstraints;\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\n\t\t\t\tvar constraint = pathConstraints[i];\n\t\t\t\tif (constraint.name == constraintName)\n\t\t\t\t\treturn constraint;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\n\t\t\tif (pathConstraintName == null)\n\t\t\t\tthrow new Error(\"pathConstraintName cannot be null.\");\n\t\t\tvar pathConstraints = this.pathConstraints;\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++)\n\t\t\t\tif (pathConstraints[i].name == pathConstraintName)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t};\n\t\treturn SkeletonData;\n\t}());\n\tspine.SkeletonData = SkeletonData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkeletonJson = (function () {\n\t\tfunction SkeletonJson(attachmentLoader) {\n\t\t\tthis.scale = 1;\n\t\t\tthis.linkedMeshes = new Array();\n\t\t\tthis.attachmentLoader = attachmentLoader;\n\t\t}\n\t\tSkeletonJson.prototype.readSkeletonData = function (json) {\n\t\t\tvar scale = this.scale;\n\t\t\tvar skeletonData = new spine.SkeletonData();\n\t\t\tvar root = typeof (json) === \"string\" ? JSON.parse(json) : json;\n\t\t\tvar skeletonMap = root.skeleton;\n\t\t\tif (skeletonMap != null) {\n\t\t\t\tskeletonData.hash = skeletonMap.hash;\n\t\t\t\tskeletonData.version = skeletonMap.spine;\n\t\t\t\tif (\"3.8.75\" == skeletonData.version)\n\t\t\t\t\tthrow new Error(\"Unsupported skeleton data, please export with a newer version of Spine.\");\n\t\t\t\tskeletonData.x = skeletonMap.x;\n\t\t\t\tskeletonData.y = skeletonMap.y;\n\t\t\t\tskeletonData.width = skeletonMap.width;\n\t\t\t\tskeletonData.height = skeletonMap.height;\n\t\t\t\tskeletonData.fps = skeletonMap.fps;\n\t\t\t\tskeletonData.imagesPath = skeletonMap.images;\n\t\t\t}\n\t\t\tif (root.bones) {\n\t\t\t\tfor (var i = 0; i < root.bones.length; i++) {\n\t\t\t\t\tvar boneMap = root.bones[i];\n\t\t\t\t\tvar parent_5 = null;\n\t\t\t\t\tvar parentName = this.getValue(boneMap, \"parent\", null);\n\t\t\t\t\tif (parentName != null) {\n\t\t\t\t\t\tparent_5 = skeletonData.findBone(parentName);\n\t\t\t\t\t\tif (parent_5 == null)\n\t\t\t\t\t\t\tthrow new Error(\"Parent bone not found: \" + parentName);\n\t\t\t\t\t}\n\t\t\t\t\tvar data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_5);\n\t\t\t\t\tdata.length = this.getValue(boneMap, \"length\", 0) * scale;\n\t\t\t\t\tdata.x = this.getValue(boneMap, \"x\", 0) * scale;\n\t\t\t\t\tdata.y = this.getValue(boneMap, \"y\", 0) * scale;\n\t\t\t\t\tdata.rotation = this.getValue(boneMap, \"rotation\", 0);\n\t\t\t\t\tdata.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n\t\t\t\t\tdata.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n\t\t\t\t\tdata.shearX = this.getValue(boneMap, \"shearX\", 0);\n\t\t\t\t\tdata.shearY = this.getValue(boneMap, \"shearY\", 0);\n\t\t\t\t\tdata.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n\t\t\t\t\tdata.skinRequired = this.getValue(boneMap, \"skin\", false);\n\t\t\t\t\tskeletonData.bones.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.slots) {\n\t\t\t\tfor (var i = 0; i < root.slots.length; i++) {\n\t\t\t\t\tvar slotMap = root.slots[i];\n\t\t\t\t\tvar slotName = slotMap.name;\n\t\t\t\t\tvar boneName = slotMap.bone;\n\t\t\t\t\tvar boneData = skeletonData.findBone(boneName);\n\t\t\t\t\tif (boneData == null)\n\t\t\t\t\t\tthrow new Error(\"Slot bone not found: \" + boneName);\n\t\t\t\t\tvar data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\n\t\t\t\t\tvar color = this.getValue(slotMap, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tdata.color.setFromString(color);\n\t\t\t\t\tvar dark = this.getValue(slotMap, \"dark\", null);\n\t\t\t\t\tif (dark != null) {\n\t\t\t\t\t\tdata.darkColor = new spine.Color(1, 1, 1, 1);\n\t\t\t\t\t\tdata.darkColor.setFromString(dark);\n\t\t\t\t\t}\n\t\t\t\t\tdata.attachmentName = this.getValue(slotMap, \"attachment\", null);\n\t\t\t\t\tdata.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n\t\t\t\t\tskeletonData.slots.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.ik) {\n\t\t\t\tfor (var i = 0; i < root.ik.length; i++) {\n\t\t\t\t\tvar constraintMap = root.ik[i];\n\t\t\t\t\tvar data = new spine.IkConstraintData(constraintMap.name);\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\n\t\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\n\t\t\t\t\t\tif (bone == null)\n\t\t\t\t\t\t\tthrow new Error(\"IK bone not found: \" + boneName);\n\t\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t\t}\n\t\t\t\t\tvar targetName = constraintMap.target;\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\n\t\t\t\t\tif (data.target == null)\n\t\t\t\t\t\tthrow new Error(\"IK target bone not found: \" + targetName);\n\t\t\t\t\tdata.mix = this.getValue(constraintMap, \"mix\", 1);\n\t\t\t\t\tdata.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\n\t\t\t\t\tdata.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n\t\t\t\t\tdata.compress = this.getValue(constraintMap, \"compress\", false);\n\t\t\t\t\tdata.stretch = this.getValue(constraintMap, \"stretch\", false);\n\t\t\t\t\tdata.uniform = this.getValue(constraintMap, \"uniform\", false);\n\t\t\t\t\tskeletonData.ikConstraints.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.transform) {\n\t\t\t\tfor (var i = 0; i < root.transform.length; i++) {\n\t\t\t\t\tvar constraintMap = root.transform[i];\n\t\t\t\t\tvar data = new spine.TransformConstraintData(constraintMap.name);\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\n\t\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\n\t\t\t\t\t\tif (bone == null)\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\n\t\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t\t}\n\t\t\t\t\tvar targetName = constraintMap.target;\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\n\t\t\t\t\tif (data.target == null)\n\t\t\t\t\t\tthrow new Error(\"Transform constraint target bone not found: \" + targetName);\n\t\t\t\t\tdata.local = this.getValue(constraintMap, \"local\", false);\n\t\t\t\t\tdata.relative = this.getValue(constraintMap, \"relative\", false);\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n\t\t\t\t\tdata.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n\t\t\t\t\tdata.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n\t\t\t\t\tdata.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n\t\t\t\t\tdata.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n\t\t\t\t\tdata.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\t\t\t\t\tdata.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n\t\t\t\t\tdata.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\t\t\t\t\tskeletonData.transformConstraints.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.path) {\n\t\t\t\tfor (var i = 0; i < root.path.length; i++) {\n\t\t\t\t\tvar constraintMap = root.path[i];\n\t\t\t\t\tvar data = new spine.PathConstraintData(constraintMap.name);\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\n\t\t\t\t\tdata.skinRequired = this.getValue(constraintMap, \"skin\", false);\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\n\t\t\t\t\t\tif (bone == null)\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\n\t\t\t\t\t\tdata.bones.push(bone);\n\t\t\t\t\t}\n\t\t\t\t\tvar targetName = constraintMap.target;\n\t\t\t\t\tdata.target = skeletonData.findSlot(targetName);\n\t\t\t\t\tif (data.target == null)\n\t\t\t\t\t\tthrow new Error(\"Path target slot not found: \" + targetName);\n\t\t\t\t\tdata.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n\t\t\t\t\tdata.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n\t\t\t\t\tdata.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n\t\t\t\t\tdata.position = this.getValue(constraintMap, \"position\", 0);\n\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\n\t\t\t\t\t\tdata.position *= scale;\n\t\t\t\t\tdata.spacing = this.getValue(constraintMap, \"spacing\", 0);\n\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n\t\t\t\t\t\tdata.spacing *= scale;\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\t\t\t\t\tskeletonData.pathConstraints.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.skins) {\n\t\t\t\tfor (var i = 0; i < root.skins.length; i++) {\n\t\t\t\t\tvar skinMap = root.skins[i];\n\t\t\t\t\tvar skin = new spine.Skin(skinMap.name);\n\t\t\t\t\tif (skinMap.bones) {\n\t\t\t\t\t\tfor (var ii = 0; ii < skinMap.bones.length; ii++) {\n\t\t\t\t\t\t\tvar bone = skeletonData.findBone(skinMap.bones[ii]);\n\t\t\t\t\t\t\tif (bone == null)\n\t\t\t\t\t\t\t\tthrow new Error(\"Skin bone not found: \" + skinMap.bones[i]);\n\t\t\t\t\t\t\tskin.bones.push(bone);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skinMap.ik) {\n\t\t\t\t\t\tfor (var ii = 0; ii < skinMap.ik.length; ii++) {\n\t\t\t\t\t\t\tvar constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n\t\t\t\t\t\t\tif (constraint == null)\n\t\t\t\t\t\t\t\tthrow new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\n\t\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skinMap.transform) {\n\t\t\t\t\t\tfor (var ii = 0; ii < skinMap.transform.length; ii++) {\n\t\t\t\t\t\t\tvar constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n\t\t\t\t\t\t\tif (constraint == null)\n\t\t\t\t\t\t\t\tthrow new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\n\t\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (skinMap.path) {\n\t\t\t\t\t\tfor (var ii = 0; ii < skinMap.path.length; ii++) {\n\t\t\t\t\t\t\tvar constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n\t\t\t\t\t\t\tif (constraint == null)\n\t\t\t\t\t\t\t\tthrow new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\n\t\t\t\t\t\t\tskin.constraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (var slotName in skinMap.attachments) {\n\t\t\t\t\t\tvar slot = skeletonData.findSlot(slotName);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\n\t\t\t\t\t\tvar slotMap = skinMap.attachments[slotName];\n\t\t\t\t\t\tfor (var entryName in slotMap) {\n\t\t\t\t\t\t\tvar attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\t\t\t\t\t\t\tif (attachment != null)\n\t\t\t\t\t\t\t\tskin.setAttachment(slot.index, entryName, attachment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tskeletonData.skins.push(skin);\n\t\t\t\t\tif (skin.name == \"default\")\n\t\t\t\t\t\tskeletonData.defaultSkin = skin;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\n\t\t\t\tvar linkedMesh = this.linkedMeshes[i];\n\t\t\t\tvar skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\t\t\t\tif (skin == null)\n\t\t\t\t\tthrow new Error(\"Skin not found: \" + linkedMesh.skin);\n\t\t\t\tvar parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\t\t\t\tif (parent_6 == null)\n\t\t\t\t\tthrow new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n\t\t\t\tlinkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent_6);\n\t\t\t\tlinkedMesh.mesh.updateUVs();\n\t\t\t}\n\t\t\tthis.linkedMeshes.length = 0;\n\t\t\tif (root.events) {\n\t\t\t\tfor (var eventName in root.events) {\n\t\t\t\t\tvar eventMap = root.events[eventName];\n\t\t\t\t\tvar data = new spine.EventData(eventName);\n\t\t\t\t\tdata.intValue = this.getValue(eventMap, \"int\", 0);\n\t\t\t\t\tdata.floatValue = this.getValue(eventMap, \"float\", 0);\n\t\t\t\t\tdata.stringValue = this.getValue(eventMap, \"string\", \"\");\n\t\t\t\t\tdata.audioPath = this.getValue(eventMap, \"audio\", null);\n\t\t\t\t\tif (data.audioPath != null) {\n\t\t\t\t\t\tdata.volume = this.getValue(eventMap, \"volume\", 1);\n\t\t\t\t\t\tdata.balance = this.getValue(eventMap, \"balance\", 0);\n\t\t\t\t\t}\n\t\t\t\t\tskeletonData.events.push(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (root.animations) {\n\t\t\t\tfor (var animationName in root.animations) {\n\t\t\t\t\tvar animationMap = root.animations[animationName];\n\t\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn skeletonData;\n\t\t};\n\t\tSkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\n\t\t\tvar scale = this.scale;\n\t\t\tname = this.getValue(map, \"name\", name);\n\t\t\tvar type = this.getValue(map, \"type\", \"region\");\n\t\t\tswitch (type) {\n\t\t\t\tcase \"region\": {\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\n\t\t\t\t\tvar region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\t\t\t\t\tif (region == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tregion.path = path;\n\t\t\t\t\tregion.x = this.getValue(map, \"x\", 0) * scale;\n\t\t\t\t\tregion.y = this.getValue(map, \"y\", 0) * scale;\n\t\t\t\t\tregion.scaleX = this.getValue(map, \"scaleX\", 1);\n\t\t\t\t\tregion.scaleY = this.getValue(map, \"scaleY\", 1);\n\t\t\t\t\tregion.rotation = this.getValue(map, \"rotation\", 0);\n\t\t\t\t\tregion.width = map.width * scale;\n\t\t\t\t\tregion.height = map.height * scale;\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tregion.color.setFromString(color);\n\t\t\t\t\tregion.updateOffset();\n\t\t\t\t\treturn region;\n\t\t\t\t}\n\t\t\t\tcase \"boundingbox\": {\n\t\t\t\t\tvar box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\t\t\t\t\tif (box == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tbox.color.setFromString(color);\n\t\t\t\t\treturn box;\n\t\t\t\t}\n\t\t\t\tcase \"mesh\":\n\t\t\t\tcase \"linkedmesh\": {\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\t\t\t\t\tif (mesh == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tmesh.path = path;\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tmesh.color.setFromString(color);\n\t\t\t\t\tmesh.width = this.getValue(map, \"width\", 0) * scale;\n\t\t\t\t\tmesh.height = this.getValue(map, \"height\", 0) * scale;\n\t\t\t\t\tvar parent_7 = this.getValue(map, \"parent\", null);\n\t\t\t\t\tif (parent_7 != null) {\n\t\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_7, this.getValue(map, \"deform\", true)));\n\t\t\t\t\t\treturn mesh;\n\t\t\t\t\t}\n\t\t\t\t\tvar uvs = map.uvs;\n\t\t\t\t\tthis.readVertices(map, mesh, uvs.length);\n\t\t\t\t\tmesh.triangles = map.triangles;\n\t\t\t\t\tmesh.regionUVs = uvs;\n\t\t\t\t\tmesh.updateUVs();\n\t\t\t\t\tmesh.edges = this.getValue(map, \"edges\", null);\n\t\t\t\t\tmesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n\t\t\t\t\treturn mesh;\n\t\t\t\t}\n\t\t\t\tcase \"path\": {\n\t\t\t\t\tvar path = this.attachmentLoader.newPathAttachment(skin, name);\n\t\t\t\t\tif (path == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tpath.closed = this.getValue(map, \"closed\", false);\n\t\t\t\t\tpath.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\t\t\t\t\tvar vertexCount = map.vertexCount;\n\t\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\n\t\t\t\t\tvar lengths = spine.Utils.newArray(vertexCount / 3, 0);\n\t\t\t\t\tfor (var i = 0; i < map.lengths.length; i++)\n\t\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\n\t\t\t\t\tpath.lengths = lengths;\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tpath.color.setFromString(color);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\tcase \"point\": {\n\t\t\t\t\tvar point = this.attachmentLoader.newPointAttachment(skin, name);\n\t\t\t\t\tif (point == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tpoint.x = this.getValue(map, \"x\", 0) * scale;\n\t\t\t\t\tpoint.y = this.getValue(map, \"y\", 0) * scale;\n\t\t\t\t\tpoint.rotation = this.getValue(map, \"rotation\", 0);\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tpoint.color.setFromString(color);\n\t\t\t\t\treturn point;\n\t\t\t\t}\n\t\t\t\tcase \"clipping\": {\n\t\t\t\t\tvar clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\t\t\t\t\tif (clip == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar end = this.getValue(map, \"end\", null);\n\t\t\t\t\tif (end != null) {\n\t\t\t\t\t\tvar slot = skeletonData.findSlot(end);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t\tthrow new Error(\"Clipping end slot not found: \" + end);\n\t\t\t\t\t\tclip.endSlot = slot;\n\t\t\t\t\t}\n\t\t\t\t\tvar vertexCount = map.vertexCount;\n\t\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tclip.color.setFromString(color);\n\t\t\t\t\treturn clip;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tSkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\n\t\t\tvar scale = this.scale;\n\t\t\tattachment.worldVerticesLength = verticesLength;\n\t\t\tvar vertices = map.vertices;\n\t\t\tif (verticesLength == vertices.length) {\n\t\t\t\tvar scaledVertices = spine.Utils.toFloatArray(vertices);\n\t\t\t\tif (scale != 1) {\n\t\t\t\t\tfor (var i = 0, n = vertices.length; i < n; i++)\n\t\t\t\t\t\tscaledVertices[i] *= scale;\n\t\t\t\t}\n\t\t\t\tattachment.vertices = scaledVertices;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar weights = new Array();\n\t\t\tvar bones = new Array();\n\t\t\tfor (var i = 0, n = vertices.length; i < n;) {\n\t\t\t\tvar boneCount = vertices[i++];\n\t\t\t\tbones.push(boneCount);\n\t\t\t\tfor (var nn = i + boneCount * 4; i < nn; i += 4) {\n\t\t\t\t\tbones.push(vertices[i]);\n\t\t\t\t\tweights.push(vertices[i + 1] * scale);\n\t\t\t\t\tweights.push(vertices[i + 2] * scale);\n\t\t\t\t\tweights.push(vertices[i + 3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tattachment.bones = bones;\n\t\t\tattachment.vertices = spine.Utils.toFloatArray(weights);\n\t\t};\n\t\tSkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\n\t\t\tvar scale = this.scale;\n\t\t\tvar timelines = new Array();\n\t\t\tvar duration = 0;\n\t\t\tif (map.slots) {\n\t\t\t\tfor (var slotName in map.slots) {\n\t\t\t\t\tvar slotMap = map.slots[slotName];\n\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\n\t\t\t\t\tif (slotIndex == -1)\n\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\n\t\t\t\t\tfor (var timelineName in slotMap) {\n\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\n\t\t\t\t\t\tif (timelineName == \"attachment\") {\n\t\t\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (timelineName == \"color\") {\n\t\t\t\t\t\t\tvar timeline = new spine.ColorTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\tvar color = new spine.Color();\n\t\t\t\t\t\t\t\tcolor.setFromString(valueMap.color);\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (timelineName == \"twoColor\") {\n\t\t\t\t\t\t\tvar timeline = new spine.TwoColorTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\tvar light = new spine.Color();\n\t\t\t\t\t\t\t\tvar dark = new spine.Color();\n\t\t\t\t\t\t\t\tlight.setFromString(valueMap.light);\n\t\t\t\t\t\t\t\tdark.setFromString(valueMap.dark);\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.bones) {\n\t\t\t\tfor (var boneName in map.bones) {\n\t\t\t\t\tvar boneMap = map.bones[boneName];\n\t\t\t\t\tvar boneIndex = skeletonData.findBoneIndex(boneName);\n\t\t\t\t\tif (boneIndex == -1)\n\t\t\t\t\t\tthrow new Error(\"Bone not found: \" + boneName);\n\t\t\t\t\tfor (var timelineName in boneMap) {\n\t\t\t\t\t\tvar timelineMap = boneMap[timelineName];\n\t\t\t\t\t\tif (timelineName === \"rotate\") {\n\t\t\t\t\t\t\tvar timeline = new spine.RotateTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n\t\t\t\t\t\t\tvar timeline = null;\n\t\t\t\t\t\t\tvar timelineScale = 1, defaultValue = 0;\n\t\t\t\t\t\t\tif (timelineName === \"scale\") {\n\t\t\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(timelineMap.length);\n\t\t\t\t\t\t\t\tdefaultValue = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (timelineName === \"shear\")\n\t\t\t\t\t\t\t\ttimeline = new spine.ShearTimeline(timelineMap.length);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(timelineMap.length);\n\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\tvar x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.ik) {\n\t\t\t\tfor (var constraintName in map.ik) {\n\t\t\t\t\tvar constraintMap = map.ik[constraintName];\n\t\t\t\t\tvar constraint = skeletonData.findIkConstraint(constraintName);\n\t\t\t\t\tvar timeline = new spine.IkConstraintTimeline(constraintMap.length);\n\t\t\t\t\ttimeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale, this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.transform) {\n\t\t\t\tfor (var constraintName in map.transform) {\n\t\t\t\t\tvar constraintMap = map.transform[constraintName];\n\t\t\t\t\tvar constraint = skeletonData.findTransformConstraint(constraintName);\n\t\t\t\t\tvar timeline = new spine.TransformConstraintTimeline(constraintMap.length);\n\t\t\t\t\ttimeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t}\n\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.path) {\n\t\t\t\tfor (var constraintName in map.path) {\n\t\t\t\t\tvar constraintMap = map.path[constraintName];\n\t\t\t\t\tvar index = skeletonData.findPathConstraintIndex(constraintName);\n\t\t\t\t\tif (index == -1)\n\t\t\t\t\t\tthrow new Error(\"Path constraint not found: \" + constraintName);\n\t\t\t\t\tvar data = skeletonData.pathConstraints[index];\n\t\t\t\t\tfor (var timelineName in constraintMap) {\n\t\t\t\t\t\tvar timelineMap = constraintMap[timelineName];\n\t\t\t\t\t\tif (timelineName === \"position\" || timelineName === \"spacing\") {\n\t\t\t\t\t\t\tvar timeline = null;\n\t\t\t\t\t\t\tvar timelineScale = 1;\n\t\t\t\t\t\t\tif (timelineName === \"spacing\") {\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\n\t\t\t\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\n\t\t\t\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (timelineName === \"mix\") {\n\t\t\t\t\t\t\tvar timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.deform) {\n\t\t\t\tfor (var deformName in map.deform) {\n\t\t\t\t\tvar deformMap = map.deform[deformName];\n\t\t\t\t\tvar skin = skeletonData.findSkin(deformName);\n\t\t\t\t\tif (skin == null)\n\t\t\t\t\t\tthrow new Error(\"Skin not found: \" + deformName);\n\t\t\t\t\tfor (var slotName in deformMap) {\n\t\t\t\t\t\tvar slotMap = deformMap[slotName];\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\n\t\t\t\t\t\tif (slotIndex == -1)\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotMap.name);\n\t\t\t\t\t\tfor (var timelineName in slotMap) {\n\t\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\n\t\t\t\t\t\t\tvar attachment = skin.getAttachment(slotIndex, timelineName);\n\t\t\t\t\t\t\tif (attachment == null)\n\t\t\t\t\t\t\t\tthrow new Error(\"Deform attachment not found: \" + timelineMap.name);\n\t\t\t\t\t\t\tvar weighted = attachment.bones != null;\n\t\t\t\t\t\t\tvar vertices = attachment.vertices;\n\t\t\t\t\t\t\tvar deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\t\t\t\t\t\t\tvar timeline = new spine.DeformTimeline(timelineMap.length);\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\n\t\t\t\t\t\t\ttimeline.attachment = attachment;\n\t\t\t\t\t\t\tvar frameIndex = 0;\n\t\t\t\t\t\t\tfor (var j = 0; j < timelineMap.length; j++) {\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[j];\n\t\t\t\t\t\t\t\tvar deform = void 0;\n\t\t\t\t\t\t\t\tvar verticesValue = this.getValue(valueMap, \"vertices\", null);\n\t\t\t\t\t\t\t\tif (verticesValue == null)\n\t\t\t\t\t\t\t\t\tdeform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tdeform = spine.Utils.newFloatArray(deformLength);\n\t\t\t\t\t\t\t\t\tvar start = this.getValue(valueMap, \"offset\", 0);\n\t\t\t\t\t\t\t\t\tspine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n\t\t\t\t\t\t\t\t\tif (scale != 1) {\n\t\t\t\t\t\t\t\t\t\tfor (var i = start, n = i + verticesValue.length; i < n; i++)\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!weighted) {\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < deformLength; i++)\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\n\t\t\t\t\t\t\t\tframeIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttimelines.push(timeline);\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar drawOrderNode = map.drawOrder;\n\t\t\tif (drawOrderNode == null)\n\t\t\t\tdrawOrderNode = map.draworder;\n\t\t\tif (drawOrderNode != null) {\n\t\t\t\tvar timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\n\t\t\t\tvar slotCount = skeletonData.slots.length;\n\t\t\t\tvar frameIndex = 0;\n\t\t\t\tfor (var j = 0; j < drawOrderNode.length; j++) {\n\t\t\t\t\tvar drawOrderMap = drawOrderNode[j];\n\t\t\t\t\tvar drawOrder = null;\n\t\t\t\t\tvar offsets = this.getValue(drawOrderMap, \"offsets\", null);\n\t\t\t\t\tif (offsets != null) {\n\t\t\t\t\t\tdrawOrder = spine.Utils.newArray(slotCount, -1);\n\t\t\t\t\t\tvar unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\n\t\t\t\t\t\tvar originalIndex = 0, unchangedIndex = 0;\n\t\t\t\t\t\tfor (var i = 0; i < offsets.length; i++) {\n\t\t\t\t\t\t\tvar offsetMap = offsets[i];\n\t\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n\t\t\t\t\t\t\tif (slotIndex == -1)\n\t\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + offsetMap.slot);\n\t\t\t\t\t\t\twhile (originalIndex != slotIndex)\n\t\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (originalIndex < slotCount)\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\n\t\t\t\t\t\tfor (var i = slotCount - 1; i >= 0; i--)\n\t\t\t\t\t\t\tif (drawOrder[i] == -1)\n\t\t\t\t\t\t\t\tdrawOrder[i] = unchanged[--unchangedIndex];\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\t\t\t}\n\t\t\tif (map.events) {\n\t\t\t\tvar timeline = new spine.EventTimeline(map.events.length);\n\t\t\t\tvar frameIndex = 0;\n\t\t\t\tfor (var i = 0; i < map.events.length; i++) {\n\t\t\t\t\tvar eventMap = map.events[i];\n\t\t\t\t\tvar eventData = skeletonData.findEvent(eventMap.name);\n\t\t\t\t\tif (eventData == null)\n\t\t\t\t\t\tthrow new Error(\"Event not found: \" + eventMap.name);\n\t\t\t\t\tvar event_6 = new spine.Event(spine.Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\n\t\t\t\t\tevent_6.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n\t\t\t\t\tevent_6.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n\t\t\t\t\tevent_6.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n\t\t\t\t\tif (event_6.data.audioPath != null) {\n\t\t\t\t\t\tevent_6.volume = this.getValue(eventMap, \"volume\", 1);\n\t\t\t\t\t\tevent_6.balance = this.getValue(eventMap, \"balance\", 0);\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.setFrame(frameIndex++, event_6);\n\t\t\t\t}\n\t\t\t\ttimelines.push(timeline);\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\t\t\t}\n\t\t\tif (isNaN(duration)) {\n\t\t\t\tthrow new Error(\"Error while parsing animation, duration is NaN\");\n\t\t\t}\n\t\t\tskeletonData.animations.push(new spine.Animation(name, timelines, duration));\n\t\t};\n\t\tSkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\n\t\t\tif (!map.hasOwnProperty(\"curve\"))\n\t\t\t\treturn;\n\t\t\tif (map.curve == \"stepped\")\n\t\t\t\ttimeline.setStepped(frameIndex);\n\t\t\telse {\n\t\t\t\tvar curve = map.curve;\n\t\t\t\ttimeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\n\t\t\t}\n\t\t};\n\t\tSkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\n\t\t\treturn map[prop] !== undefined ? map[prop] : defaultValue;\n\t\t};\n\t\tSkeletonJson.blendModeFromString = function (str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str == \"normal\")\n\t\t\t\treturn spine.BlendMode.Normal;\n\t\t\tif (str == \"additive\")\n\t\t\t\treturn spine.BlendMode.Additive;\n\t\t\tif (str == \"multiply\")\n\t\t\t\treturn spine.BlendMode.Multiply;\n\t\t\tif (str == \"screen\")\n\t\t\t\treturn spine.BlendMode.Screen;\n\t\t\tthrow new Error(\"Unknown blend mode: \" + str);\n\t\t};\n\t\tSkeletonJson.positionModeFromString = function (str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str == \"fixed\")\n\t\t\t\treturn spine.PositionMode.Fixed;\n\t\t\tif (str == \"percent\")\n\t\t\t\treturn spine.PositionMode.Percent;\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\n\t\t};\n\t\tSkeletonJson.spacingModeFromString = function (str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str == \"length\")\n\t\t\t\treturn spine.SpacingMode.Length;\n\t\t\tif (str == \"fixed\")\n\t\t\t\treturn spine.SpacingMode.Fixed;\n\t\t\tif (str == \"percent\")\n\t\t\t\treturn spine.SpacingMode.Percent;\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\n\t\t};\n\t\tSkeletonJson.rotateModeFromString = function (str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str == \"tangent\")\n\t\t\t\treturn spine.RotateMode.Tangent;\n\t\t\tif (str == \"chain\")\n\t\t\t\treturn spine.RotateMode.Chain;\n\t\t\tif (str == \"chainscale\")\n\t\t\t\treturn spine.RotateMode.ChainScale;\n\t\t\tthrow new Error(\"Unknown rotate mode: \" + str);\n\t\t};\n\t\tSkeletonJson.transformModeFromString = function (str) {\n\t\t\tstr = str.toLowerCase();\n\t\t\tif (str == \"normal\")\n\t\t\t\treturn spine.TransformMode.Normal;\n\t\t\tif (str == \"onlytranslation\")\n\t\t\t\treturn spine.TransformMode.OnlyTranslation;\n\t\t\tif (str == \"norotationorreflection\")\n\t\t\t\treturn spine.TransformMode.NoRotationOrReflection;\n\t\t\tif (str == \"noscale\")\n\t\t\t\treturn spine.TransformMode.NoScale;\n\t\t\tif (str == \"noscaleorreflection\")\n\t\t\t\treturn spine.TransformMode.NoScaleOrReflection;\n\t\t\tthrow new Error(\"Unknown transform mode: \" + str);\n\t\t};\n\t\treturn SkeletonJson;\n\t}());\n\tspine.SkeletonJson = SkeletonJson;\n\tvar LinkedMesh = (function () {\n\t\tfunction LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.skin = skin;\n\t\t\tthis.slotIndex = slotIndex;\n\t\t\tthis.parent = parent;\n\t\t\tthis.inheritDeform = inheritDeform;\n\t\t}\n\t\treturn LinkedMesh;\n\t}());\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SkinEntry = (function () {\n\t\tfunction SkinEntry(slotIndex, name, attachment) {\n\t\t\tthis.slotIndex = slotIndex;\n\t\t\tthis.name = name;\n\t\t\tthis.attachment = attachment;\n\t\t}\n\t\treturn SkinEntry;\n\t}());\n\tspine.SkinEntry = SkinEntry;\n\tvar Skin = (function () {\n\t\tfunction Skin(name) {\n\t\t\tthis.attachments = new Array();\n\t\t\tthis.bones = Array();\n\t\t\tthis.constraints = new Array();\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"name cannot be null.\");\n\t\t\tthis.name = name;\n\t\t}\n\t\tSkin.prototype.setAttachment = function (slotIndex, name, attachment) {\n\t\t\tif (attachment == null)\n\t\t\t\tthrow new Error(\"attachment cannot be null.\");\n\t\t\tvar attachments = this.attachments;\n\t\t\tif (slotIndex >= attachments.length)\n\t\t\t\tattachments.length = slotIndex + 1;\n\t\t\tif (!attachments[slotIndex])\n\t\t\t\tattachments[slotIndex] = {};\n\t\t\tattachments[slotIndex][name] = attachment;\n\t\t};\n\t\tSkin.prototype.addSkin = function (skin) {\n\t\t\tfor (var i = 0; i < skin.bones.length; i++) {\n\t\t\t\tvar bone = skin.bones[i];\n\t\t\t\tvar contained = false;\n\t\t\t\tfor (var j = 0; j < this.bones.length; j++) {\n\t\t\t\t\tif (this.bones[j] == bone) {\n\t\t\t\t\t\tcontained = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!contained)\n\t\t\t\t\tthis.bones.push(bone);\n\t\t\t}\n\t\t\tfor (var i = 0; i < skin.constraints.length; i++) {\n\t\t\t\tvar constraint = skin.constraints[i];\n\t\t\t\tvar contained = false;\n\t\t\t\tfor (var j = 0; j < this.constraints.length; j++) {\n\t\t\t\t\tif (this.constraints[j] == constraint) {\n\t\t\t\t\t\tcontained = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!contained)\n\t\t\t\t\tthis.constraints.push(constraint);\n\t\t\t}\n\t\t\tvar attachments = skin.getAttachments();\n\t\t\tfor (var i = 0; i < attachments.length; i++) {\n\t\t\t\tvar attachment = attachments[i];\n\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t\t}\n\t\t};\n\t\tSkin.prototype.copySkin = function (skin) {\n\t\t\tfor (var i = 0; i < skin.bones.length; i++) {\n\t\t\t\tvar bone = skin.bones[i];\n\t\t\t\tvar contained = false;\n\t\t\t\tfor (var j = 0; j < this.bones.length; j++) {\n\t\t\t\t\tif (this.bones[j] == bone) {\n\t\t\t\t\t\tcontained = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!contained)\n\t\t\t\t\tthis.bones.push(bone);\n\t\t\t}\n\t\t\tfor (var i = 0; i < skin.constraints.length; i++) {\n\t\t\t\tvar constraint = skin.constraints[i];\n\t\t\t\tvar contained = false;\n\t\t\t\tfor (var j = 0; j < this.constraints.length; j++) {\n\t\t\t\t\tif (this.constraints[j] == constraint) {\n\t\t\t\t\t\tcontained = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!contained)\n\t\t\t\t\tthis.constraints.push(constraint);\n\t\t\t}\n\t\t\tvar attachments = skin.getAttachments();\n\t\t\tfor (var i = 0; i < attachments.length; i++) {\n\t\t\t\tvar attachment = attachments[i];\n\t\t\t\tif (attachment.attachment == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (attachment.attachment instanceof spine.MeshAttachment) {\n\t\t\t\t\tattachment.attachment = attachment.attachment.newLinkedMesh();\n\t\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattachment.attachment = attachment.attachment.copy();\n\t\t\t\t\tthis.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSkin.prototype.getAttachment = function (slotIndex, name) {\n\t\t\tvar dictionary = this.attachments[slotIndex];\n\t\t\treturn dictionary ? dictionary[name] : null;\n\t\t};\n\t\tSkin.prototype.removeAttachment = function (slotIndex, name) {\n\t\t\tvar dictionary = this.attachments[slotIndex];\n\t\t\tif (dictionary)\n\t\t\t\tdictionary[name] = null;\n\t\t};\n\t\tSkin.prototype.getAttachments = function () {\n\t\t\tvar entries = new Array();\n\t\t\tfor (var i = 0; i < this.attachments.length; i++) {\n\t\t\t\tvar slotAttachments = this.attachments[i];\n\t\t\t\tif (slotAttachments) {\n\t\t\t\t\tfor (var name_4 in slotAttachments) {\n\t\t\t\t\t\tvar attachment = slotAttachments[name_4];\n\t\t\t\t\t\tif (attachment)\n\t\t\t\t\t\t\tentries.push(new SkinEntry(i, name_4, attachment));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn entries;\n\t\t};\n\t\tSkin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {\n\t\t\tvar slotAttachments = this.attachments[slotIndex];\n\t\t\tif (slotAttachments) {\n\t\t\t\tfor (var name_5 in slotAttachments) {\n\t\t\t\t\tvar attachment = slotAttachments[name_5];\n\t\t\t\t\tif (attachment)\n\t\t\t\t\t\tattachments.push(new SkinEntry(slotIndex, name_5, attachment));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSkin.prototype.clear = function () {\n\t\t\tthis.attachments.length = 0;\n\t\t\tthis.bones.length = 0;\n\t\t\tthis.constraints.length = 0;\n\t\t};\n\t\tSkin.prototype.attachAll = function (skeleton, oldSkin) {\n\t\t\tvar slotIndex = 0;\n\t\t\tfor (var i = 0; i < skeleton.slots.length; i++) {\n\t\t\t\tvar slot = skeleton.slots[i];\n\t\t\t\tvar slotAttachment = slot.getAttachment();\n\t\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\n\t\t\t\t\tvar dictionary = oldSkin.attachments[slotIndex];\n\t\t\t\t\tfor (var key in dictionary) {\n\t\t\t\t\t\tvar skinAttachment = dictionary[key];\n\t\t\t\t\t\tif (slotAttachment == skinAttachment) {\n\t\t\t\t\t\t\tvar attachment = this.getAttachment(slotIndex, key);\n\t\t\t\t\t\t\tif (attachment != null)\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tslotIndex++;\n\t\t\t}\n\t\t};\n\t\treturn Skin;\n\t}());\n\tspine.Skin = Skin;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Slot = (function () {\n\t\tfunction Slot(data, bone) {\n\t\t\tthis.deform = new Array();\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tif (bone == null)\n\t\t\t\tthrow new Error(\"bone cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.bone = bone;\n\t\t\tthis.color = new spine.Color();\n\t\t\tthis.darkColor = data.darkColor == null ? null : new spine.Color();\n\t\t\tthis.setToSetupPose();\n\t\t}\n\t\tSlot.prototype.getSkeleton = function () {\n\t\t\treturn this.bone.skeleton;\n\t\t};\n\t\tSlot.prototype.getAttachment = function () {\n\t\t\treturn this.attachment;\n\t\t};\n\t\tSlot.prototype.setAttachment = function (attachment) {\n\t\t\tif (this.attachment == attachment)\n\t\t\t\treturn;\n\t\t\tthis.attachment = attachment;\n\t\t\tthis.attachmentTime = this.bone.skeleton.time;\n\t\t\tthis.deform.length = 0;\n\t\t};\n\t\tSlot.prototype.setAttachmentTime = function (time) {\n\t\t\tthis.attachmentTime = this.bone.skeleton.time - time;\n\t\t};\n\t\tSlot.prototype.getAttachmentTime = function () {\n\t\t\treturn this.bone.skeleton.time - this.attachmentTime;\n\t\t};\n\t\tSlot.prototype.setToSetupPose = function () {\n\t\t\tthis.color.setFromColor(this.data.color);\n\t\t\tif (this.darkColor != null)\n\t\t\t\tthis.darkColor.setFromColor(this.data.darkColor);\n\t\t\tif (this.data.attachmentName == null)\n\t\t\t\tthis.attachment = null;\n\t\t\telse {\n\t\t\t\tthis.attachment = null;\n\t\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n\t\t\t}\n\t\t};\n\t\treturn Slot;\n\t}());\n\tspine.Slot = Slot;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SlotData = (function () {\n\t\tfunction SlotData(index, name, boneData) {\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\n\t\t\tif (index < 0)\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"name cannot be null.\");\n\t\t\tif (boneData == null)\n\t\t\t\tthrow new Error(\"boneData cannot be null.\");\n\t\t\tthis.index = index;\n\t\t\tthis.name = name;\n\t\t\tthis.boneData = boneData;\n\t\t}\n\t\treturn SlotData;\n\t}());\n\tspine.SlotData = SlotData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Texture = (function () {\n\t\tfunction Texture(image) {\n\t\t\tthis._image = image;\n\t\t}\n\t\tTexture.prototype.getImage = function () {\n\t\t\treturn this._image;\n\t\t};\n\t\tTexture.filterFromString = function (text) {\n\t\t\tswitch (text.toLowerCase()) {\n\t\t\t\tcase \"nearest\": return TextureFilter.Nearest;\n\t\t\t\tcase \"linear\": return TextureFilter.Linear;\n\t\t\t\tcase \"mipmap\": return TextureFilter.MipMap;\n\t\t\t\tcase \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n\t\t\t\tcase \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n\t\t\t\tcase \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n\t\t\t\tcase \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n\t\t\t\tdefault: throw new Error(\"Unknown texture filter \" + text);\n\t\t\t}\n\t\t};\n\t\tTexture.wrapFromString = function (text) {\n\t\t\tswitch (text.toLowerCase()) {\n\t\t\t\tcase \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n\t\t\t\tcase \"clamptoedge\": return TextureWrap.ClampToEdge;\n\t\t\t\tcase \"repeat\": return TextureWrap.Repeat;\n\t\t\t\tdefault: throw new Error(\"Unknown texture wrap \" + text);\n\t\t\t}\n\t\t};\n\t\treturn Texture;\n\t}());\n\tspine.Texture = Texture;\n\tvar TextureFilter;\n\t(function (TextureFilter) {\n\t\tTextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\n\t\tTextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\n\t\tTextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\n\t\tTextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n\t\tTextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n\t\tTextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n\t\tTextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n\t})(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\n\tvar TextureWrap;\n\t(function (TextureWrap) {\n\t\tTextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n\t\tTextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n\t\tTextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\n\t})(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\n\tvar TextureRegion = (function () {\n\t\tfunction TextureRegion() {\n\t\t\tthis.u = 0;\n\t\t\tthis.v = 0;\n\t\t\tthis.u2 = 0;\n\t\t\tthis.v2 = 0;\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t\tthis.rotate = false;\n\t\t\tthis.offsetX = 0;\n\t\t\tthis.offsetY = 0;\n\t\t\tthis.originalWidth = 0;\n\t\t\tthis.originalHeight = 0;\n\t\t}\n\t\treturn TextureRegion;\n\t}());\n\tspine.TextureRegion = TextureRegion;\n\tvar FakeTexture = (function (_super) {\n\t\t__extends(FakeTexture, _super);\n\t\tfunction FakeTexture() {\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\n\t\t}\n\t\tFakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\n\t\tFakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\n\t\tFakeTexture.prototype.dispose = function () { };\n\t\treturn FakeTexture;\n\t}(Texture));\n\tspine.FakeTexture = FakeTexture;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar TextureAtlas = (function () {\n\t\tfunction TextureAtlas(atlasText, textureLoader) {\n\t\t\tthis.pages = new Array();\n\t\t\tthis.regions = new Array();\n\t\t\tthis.load(atlasText, textureLoader);\n\t\t}\n\t\tTextureAtlas.prototype.load = function (atlasText, textureLoader) {\n\t\t\tif (textureLoader == null)\n\t\t\t\tthrow new Error(\"textureLoader cannot be null.\");\n\t\t\tvar reader = new TextureAtlasReader(atlasText);\n\t\t\tvar tuple = new Array(4);\n\t\t\tvar page = null;\n\t\t\twhile (true) {\n\t\t\t\tvar line = reader.readLine();\n\t\t\t\tif (line == null)\n\t\t\t\t\tbreak;\n\t\t\t\tline = line.trim();\n\t\t\t\tif (line.length == 0)\n\t\t\t\t\tpage = null;\n\t\t\t\telse if (!page) {\n\t\t\t\t\tpage = new TextureAtlasPage();\n\t\t\t\t\tpage.name = line;\n\t\t\t\t\tif (reader.readTuple(tuple) == 2) {\n\t\t\t\t\t\tpage.width = parseInt(tuple[0]);\n\t\t\t\t\t\tpage.height = parseInt(tuple[1]);\n\t\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\t}\n\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\tpage.minFilter = spine.Texture.filterFromString(tuple[0]);\n\t\t\t\t\tpage.magFilter = spine.Texture.filterFromString(tuple[1]);\n\t\t\t\t\tvar direction = reader.readValue();\n\t\t\t\t\tpage.uWrap = spine.TextureWrap.ClampToEdge;\n\t\t\t\t\tpage.vWrap = spine.TextureWrap.ClampToEdge;\n\t\t\t\t\tif (direction == \"x\")\n\t\t\t\t\t\tpage.uWrap = spine.TextureWrap.Repeat;\n\t\t\t\t\telse if (direction == \"y\")\n\t\t\t\t\t\tpage.vWrap = spine.TextureWrap.Repeat;\n\t\t\t\t\telse if (direction == \"xy\")\n\t\t\t\t\t\tpage.uWrap = page.vWrap = spine.TextureWrap.Repeat;\n\t\t\t\t\tpage.texture = textureLoader(line);\n\t\t\t\t\tpage.texture.setFilters(page.minFilter, page.magFilter);\n\t\t\t\t\tpage.texture.setWraps(page.uWrap, page.vWrap);\n\t\t\t\t\tpage.width = page.texture.getImage().width;\n\t\t\t\t\tpage.height = page.texture.getImage().height;\n\t\t\t\t\tthis.pages.push(page);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar region = new TextureAtlasRegion();\n\t\t\t\t\tregion.name = line;\n\t\t\t\t\tregion.page = page;\n\t\t\t\t\tvar rotateValue = reader.readValue();\n\t\t\t\t\tif (rotateValue.toLocaleLowerCase() == \"true\") {\n\t\t\t\t\t\tregion.degrees = 90;\n\t\t\t\t\t}\n\t\t\t\t\telse if (rotateValue.toLocaleLowerCase() == \"false\") {\n\t\t\t\t\t\tregion.degrees = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tregion.degrees = parseFloat(rotateValue);\n\t\t\t\t\t}\n\t\t\t\t\tregion.rotate = region.degrees == 90;\n\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\tvar x = parseInt(tuple[0]);\n\t\t\t\t\tvar y = parseInt(tuple[1]);\n\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\tvar width = parseInt(tuple[0]);\n\t\t\t\t\tvar height = parseInt(tuple[1]);\n\t\t\t\t\tregion.u = x / page.width;\n\t\t\t\t\tregion.v = y / page.height;\n\t\t\t\t\tif (region.rotate) {\n\t\t\t\t\t\tregion.u2 = (x + height) / page.width;\n\t\t\t\t\t\tregion.v2 = (y + width) / page.height;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tregion.u2 = (x + width) / page.width;\n\t\t\t\t\t\tregion.v2 = (y + height) / page.height;\n\t\t\t\t\t}\n\t\t\t\t\tregion.x = x;\n\t\t\t\t\tregion.y = y;\n\t\t\t\t\tregion.width = Math.abs(width);\n\t\t\t\t\tregion.height = Math.abs(height);\n\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\n\t\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\n\t\t\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregion.originalWidth = parseInt(tuple[0]);\n\t\t\t\t\tregion.originalHeight = parseInt(tuple[1]);\n\t\t\t\t\treader.readTuple(tuple);\n\t\t\t\t\tregion.offsetX = parseInt(tuple[0]);\n\t\t\t\t\tregion.offsetY = parseInt(tuple[1]);\n\t\t\t\t\tregion.index = parseInt(reader.readValue());\n\t\t\t\t\tregion.texture = page.texture;\n\t\t\t\t\tthis.regions.push(region);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tTextureAtlas.prototype.findRegion = function (name) {\n\t\t\tfor (var i = 0; i < this.regions.length; i++) {\n\t\t\t\tif (this.regions[i].name == name) {\n\t\t\t\t\treturn this.regions[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tTextureAtlas.prototype.dispose = function () {\n\t\t\tfor (var i = 0; i < this.pages.length; i++) {\n\t\t\t\tthis.pages[i].texture.dispose();\n\t\t\t}\n\t\t};\n\t\treturn TextureAtlas;\n\t}());\n\tspine.TextureAtlas = TextureAtlas;\n\tvar TextureAtlasReader = (function () {\n\t\tfunction TextureAtlasReader(text) {\n\t\t\tthis.index = 0;\n\t\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\n\t\t}\n\t\tTextureAtlasReader.prototype.readLine = function () {\n\t\t\tif (this.index >= this.lines.length)\n\t\t\t\treturn null;\n\t\t\treturn this.lines[this.index++];\n\t\t};\n\t\tTextureAtlasReader.prototype.readValue = function () {\n\t\t\tvar line = this.readLine();\n\t\t\tvar colon = line.indexOf(\":\");\n\t\t\tif (colon == -1)\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\n\t\t\treturn line.substring(colon + 1).trim();\n\t\t};\n\t\tTextureAtlasReader.prototype.readTuple = function (tuple) {\n\t\t\tvar line = this.readLine();\n\t\t\tvar colon = line.indexOf(\":\");\n\t\t\tif (colon == -1)\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\n\t\t\tvar i = 0, lastMatch = colon + 1;\n\t\t\tfor (; i < 3; i++) {\n\t\t\t\tvar comma = line.indexOf(\",\", lastMatch);\n\t\t\t\tif (comma == -1)\n\t\t\t\t\tbreak;\n\t\t\t\ttuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n\t\t\t\tlastMatch = comma + 1;\n\t\t\t}\n\t\t\ttuple[i] = line.substring(lastMatch).trim();\n\t\t\treturn i + 1;\n\t\t};\n\t\treturn TextureAtlasReader;\n\t}());\n\tvar TextureAtlasPage = (function () {\n\t\tfunction TextureAtlasPage() {\n\t\t}\n\t\treturn TextureAtlasPage;\n\t}());\n\tspine.TextureAtlasPage = TextureAtlasPage;\n\tvar TextureAtlasRegion = (function (_super) {\n\t\t__extends(TextureAtlasRegion, _super);\n\t\tfunction TextureAtlasRegion() {\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\n\t\t}\n\t\treturn TextureAtlasRegion;\n\t}(spine.TextureRegion));\n\tspine.TextureAtlasRegion = TextureAtlasRegion;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar TransformConstraint = (function () {\n\t\tfunction TransformConstraint(data, skeleton) {\n\t\t\tthis.rotateMix = 0;\n\t\t\tthis.translateMix = 0;\n\t\t\tthis.scaleMix = 0;\n\t\t\tthis.shearMix = 0;\n\t\t\tthis.temp = new spine.Vector2();\n\t\t\tthis.active = false;\n\t\t\tif (data == null)\n\t\t\t\tthrow new Error(\"data cannot be null.\");\n\t\t\tif (skeleton == null)\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\n\t\t\tthis.data = data;\n\t\t\tthis.rotateMix = data.rotateMix;\n\t\t\tthis.translateMix = data.translateMix;\n\t\t\tthis.scaleMix = data.scaleMix;\n\t\t\tthis.shearMix = data.shearMix;\n\t\t\tthis.bones = new Array();\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\n\t\t\tthis.target = skeleton.findBone(data.target.name);\n\t\t}\n\t\tTransformConstraint.prototype.isActive = function () {\n\t\t\treturn this.active;\n\t\t};\n\t\tTransformConstraint.prototype.apply = function () {\n\t\t\tthis.update();\n\t\t};\n\t\tTransformConstraint.prototype.update = function () {\n\t\t\tif (this.data.local) {\n\t\t\t\tif (this.data.relative)\n\t\t\t\t\tthis.applyRelativeLocal();\n\t\t\t\telse\n\t\t\t\t\tthis.applyAbsoluteLocal();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.data.relative)\n\t\t\t\t\tthis.applyRelativeWorld();\n\t\t\t\telse\n\t\t\t\t\tthis.applyAbsoluteWorld();\n\t\t\t}\n\t\t};\n\t\tTransformConstraint.prototype.applyAbsoluteWorld = function () {\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n\t\t\tvar target = this.target;\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect;\n\t\t\tvar offsetShearY = this.data.offsetShearY * degRadReflect;\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tvar modified = false;\n\t\t\t\tif (rotateMix != 0) {\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\t\t\tvar r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\t\t\t\t\tif (r > spine.MathUtils.PI)\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\n\t\t\t\t\tr *= rotateMix;\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\n\t\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (translateMix != 0) {\n\t\t\t\t\tvar temp = this.temp;\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n\t\t\t\t\tbone.worldX += (temp.x - bone.worldX) * translateMix;\n\t\t\t\t\tbone.worldY += (temp.y - bone.worldY) * translateMix;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (scaleMix > 0) {\n\t\t\t\t\tvar s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\n\t\t\t\t\tvar ts = Math.sqrt(ta * ta + tc * tc);\n\t\t\t\t\tif (s > 0.00001)\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n\t\t\t\t\tbone.a *= s;\n\t\t\t\t\tbone.c *= s;\n\t\t\t\t\ts = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\n\t\t\t\t\tts = Math.sqrt(tb * tb + td * td);\n\t\t\t\t\tif (s > 0.00001)\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n\t\t\t\t\tbone.b *= s;\n\t\t\t\t\tbone.d *= s;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (shearMix > 0) {\n\t\t\t\t\tvar b = bone.b, d = bone.d;\n\t\t\t\t\tvar by = Math.atan2(d, b);\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\n\t\t\t\t\tif (r > spine.MathUtils.PI)\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\n\t\t\t\t\tr = by + (r + offsetShearY) * shearMix;\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\n\t\t\t\t\tbone.b = Math.cos(r) * s;\n\t\t\t\t\tbone.d = Math.sin(r) * s;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (modified)\n\t\t\t\t\tbone.appliedValid = false;\n\t\t\t}\n\t\t};\n\t\tTransformConstraint.prototype.applyRelativeWorld = function () {\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n\t\t\tvar target = this.target;\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tvar modified = false;\n\t\t\t\tif (rotateMix != 0) {\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\t\t\tvar r = Math.atan2(tc, ta) + offsetRotation;\n\t\t\t\t\tif (r > spine.MathUtils.PI)\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\n\t\t\t\t\tr *= rotateMix;\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\n\t\t\t\t\tbone.a = cos * a - sin * c;\n\t\t\t\t\tbone.b = cos * b - sin * d;\n\t\t\t\t\tbone.c = sin * a + cos * c;\n\t\t\t\t\tbone.d = sin * b + cos * d;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (translateMix != 0) {\n\t\t\t\t\tvar temp = this.temp;\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n\t\t\t\t\tbone.worldX += temp.x * translateMix;\n\t\t\t\t\tbone.worldY += temp.y * translateMix;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (scaleMix > 0) {\n\t\t\t\t\tvar s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n\t\t\t\t\tbone.a *= s;\n\t\t\t\t\tbone.c *= s;\n\t\t\t\t\ts = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n\t\t\t\t\tbone.b *= s;\n\t\t\t\t\tbone.d *= s;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (shearMix > 0) {\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\t\t\t\t\tif (r > spine.MathUtils.PI)\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\n\t\t\t\t\tvar b = bone.b, d = bone.d;\n\t\t\t\t\tr = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\n\t\t\t\t\tbone.b = Math.cos(r) * s;\n\t\t\t\t\tbone.d = Math.sin(r) * s;\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t\tif (modified)\n\t\t\t\t\tbone.appliedValid = false;\n\t\t\t}\n\t\t};\n\t\tTransformConstraint.prototype.applyAbsoluteLocal = function () {\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n\t\t\tvar target = this.target;\n\t\t\tif (!target.appliedValid)\n\t\t\t\ttarget.updateAppliedTransform();\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tif (!bone.appliedValid)\n\t\t\t\t\tbone.updateAppliedTransform();\n\t\t\t\tvar rotation = bone.arotation;\n\t\t\t\tif (rotateMix != 0) {\n\t\t\t\t\tvar r = target.arotation - rotation + this.data.offsetRotation;\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n\t\t\t\t\trotation += r * rotateMix;\n\t\t\t\t}\n\t\t\t\tvar x = bone.ax, y = bone.ay;\n\t\t\t\tif (translateMix != 0) {\n\t\t\t\t\tx += (target.ax - x + this.data.offsetX) * translateMix;\n\t\t\t\t\ty += (target.ay - y + this.data.offsetY) * translateMix;\n\t\t\t\t}\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n\t\t\t\tif (scaleMix != 0) {\n\t\t\t\t\tif (scaleX > 0.00001)\n\t\t\t\t\t\tscaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n\t\t\t\t\tif (scaleY > 0.00001)\n\t\t\t\t\t\tscaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n\t\t\t\t}\n\t\t\t\tvar shearY = bone.ashearY;\n\t\t\t\tif (shearMix != 0) {\n\t\t\t\t\tvar r = target.ashearY - shearY + this.data.offsetShearY;\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n\t\t\t\t\tbone.shearY += r * shearMix;\n\t\t\t\t}\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n\t\t\t}\n\t\t};\n\t\tTransformConstraint.prototype.applyRelativeLocal = function () {\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n\t\t\tvar target = this.target;\n\t\t\tif (!target.appliedValid)\n\t\t\t\ttarget.updateAppliedTransform();\n\t\t\tvar bones = this.bones;\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\tvar bone = bones[i];\n\t\t\t\tif (!bone.appliedValid)\n\t\t\t\t\tbone.updateAppliedTransform();\n\t\t\t\tvar rotation = bone.arotation;\n\t\t\t\tif (rotateMix != 0)\n\t\t\t\t\trotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\t\t\t\tvar x = bone.ax, y = bone.ay;\n\t\t\t\tif (translateMix != 0) {\n\t\t\t\t\tx += (target.ax + this.data.offsetX) * translateMix;\n\t\t\t\t\ty += (target.ay + this.data.offsetY) * translateMix;\n\t\t\t\t}\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n\t\t\t\tif (scaleMix != 0) {\n\t\t\t\t\tif (scaleX > 0.00001)\n\t\t\t\t\t\tscaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\n\t\t\t\t\tif (scaleY > 0.00001)\n\t\t\t\t\t\tscaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\n\t\t\t\t}\n\t\t\t\tvar shearY = bone.ashearY;\n\t\t\t\tif (shearMix != 0)\n\t\t\t\t\tshearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n\t\t\t}\n\t\t};\n\t\treturn TransformConstraint;\n\t}());\n\tspine.TransformConstraint = TransformConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar TransformConstraintData = (function (_super) {\n\t\t__extends(TransformConstraintData, _super);\n\t\tfunction TransformConstraintData(name) {\n\t\t\tvar _this = _super.call(this, name, 0, false) || this;\n\t\t\t_this.bones = new Array();\n\t\t\t_this.rotateMix = 0;\n\t\t\t_this.translateMix = 0;\n\t\t\t_this.scaleMix = 0;\n\t\t\t_this.shearMix = 0;\n\t\t\t_this.offsetRotation = 0;\n\t\t\t_this.offsetX = 0;\n\t\t\t_this.offsetY = 0;\n\t\t\t_this.offsetScaleX = 0;\n\t\t\t_this.offsetScaleY = 0;\n\t\t\t_this.offsetShearY = 0;\n\t\t\t_this.relative = false;\n\t\t\t_this.local = false;\n\t\t\treturn _this;\n\t\t}\n\t\treturn TransformConstraintData;\n\t}(spine.ConstraintData));\n\tspine.TransformConstraintData = TransformConstraintData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar Triangulator = (function () {\n\t\tfunction Triangulator() {\n\t\t\tthis.convexPolygons = new Array();\n\t\t\tthis.convexPolygonsIndices = new Array();\n\t\t\tthis.indicesArray = new Array();\n\t\t\tthis.isConcaveArray = new Array();\n\t\t\tthis.triangles = new Array();\n\t\t\tthis.polygonPool = new spine.Pool(function () {\n\t\t\t\treturn new Array();\n\t\t\t});\n\t\t\tthis.polygonIndicesPool = new spine.Pool(function () {\n\t\t\t\treturn new Array();\n\t\t\t});\n\t\t}\n\t\tTriangulator.prototype.triangulate = function (verticesArray) {\n\t\t\tvar vertices = verticesArray;\n\t\t\tvar vertexCount = verticesArray.length >> 1;\n\t\t\tvar indices = this.indicesArray;\n\t\t\tindices.length = 0;\n\t\t\tfor (var i = 0; i < vertexCount; i++)\n\t\t\t\tindices[i] = i;\n\t\t\tvar isConcave = this.isConcaveArray;\n\t\t\tisConcave.length = 0;\n\t\t\tfor (var i = 0, n = vertexCount; i < n; ++i)\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\t\t\tvar triangles = this.triangles;\n\t\t\ttriangles.length = 0;\n\t\t\twhile (vertexCount > 3) {\n\t\t\t\tvar previous = vertexCount - 1, i = 0, next = 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\touter: if (!isConcave[i]) {\n\t\t\t\t\t\tvar p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n\t\t\t\t\t\tvar p1x = vertices[p1], p1y = vertices[p1 + 1];\n\t\t\t\t\t\tvar p2x = vertices[p2], p2y = vertices[p2 + 1];\n\t\t\t\t\t\tvar p3x = vertices[p3], p3y = vertices[p3 + 1];\n\t\t\t\t\t\tfor (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n\t\t\t\t\t\t\tif (!isConcave[ii])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tvar v = indices[ii] << 1;\n\t\t\t\t\t\t\tvar vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\n\t\t\t\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (next == 0) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (!isConcave[i])\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t} while (i > 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprevious = i;\n\t\t\t\t\ti = next;\n\t\t\t\t\tnext = (next + 1) % vertexCount;\n\t\t\t\t}\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n\t\t\t\ttriangles.push(indices[i]);\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\n\t\t\t\tindices.splice(i, 1);\n\t\t\t\tisConcave.splice(i, 1);\n\t\t\t\tvertexCount--;\n\t\t\t\tvar previousIndex = (vertexCount + i - 1) % vertexCount;\n\t\t\t\tvar nextIndex = i == vertexCount ? 0 : i;\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n\t\t\t}\n\t\t\tif (vertexCount == 3) {\n\t\t\t\ttriangles.push(indices[2]);\n\t\t\t\ttriangles.push(indices[0]);\n\t\t\t\ttriangles.push(indices[1]);\n\t\t\t}\n\t\t\treturn triangles;\n\t\t};\n\t\tTriangulator.prototype.decompose = function (verticesArray, triangles) {\n\t\t\tvar vertices = verticesArray;\n\t\t\tvar convexPolygons = this.convexPolygons;\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\n\t\t\tconvexPolygons.length = 0;\n\t\t\tvar convexPolygonsIndices = this.convexPolygonsIndices;\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\n\t\t\tconvexPolygonsIndices.length = 0;\n\t\t\tvar polygonIndices = this.polygonIndicesPool.obtain();\n\t\t\tpolygonIndices.length = 0;\n\t\t\tvar polygon = this.polygonPool.obtain();\n\t\t\tpolygon.length = 0;\n\t\t\tvar fanBaseIndex = -1, lastWinding = 0;\n\t\t\tfor (var i = 0, n = triangles.length; i < n; i += 3) {\n\t\t\t\tvar t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n\t\t\t\tvar x1 = vertices[t1], y1 = vertices[t1 + 1];\n\t\t\t\tvar x2 = vertices[t2], y2 = vertices[t2 + 1];\n\t\t\t\tvar x3 = vertices[t3], y3 = vertices[t3 + 1];\n\t\t\t\tvar merged = false;\n\t\t\t\tif (fanBaseIndex == t1) {\n\t\t\t\t\tvar o = polygon.length - 4;\n\t\t\t\t\tvar winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\t\tmerged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!merged) {\n\t\t\t\t\tif (polygon.length > 0) {\n\t\t\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t\t}\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\n\t\t\t\t\tpolygon.length = 0;\n\t\t\t\t\tpolygon.push(x1);\n\t\t\t\t\tpolygon.push(y1);\n\t\t\t\t\tpolygon.push(x2);\n\t\t\t\t\tpolygon.push(y2);\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\n\t\t\t\t\tpolygonIndices.length = 0;\n\t\t\t\t\tpolygonIndices.push(t1);\n\t\t\t\t\tpolygonIndices.push(t2);\n\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n\t\t\t\t\tfanBaseIndex = t1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (polygon.length > 0) {\n\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t}\n\t\t\tfor (var i = 0, n = convexPolygons.length; i < n; i++) {\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\t\tif (polygonIndices.length == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstIndex = polygonIndices[0];\n\t\t\t\tvar lastIndex = polygonIndices[polygonIndices.length - 1];\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tvar o = polygon.length - 4;\n\t\t\t\tvar prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n\t\t\t\tvar prevX = polygon[o + 2], prevY = polygon[o + 3];\n\t\t\t\tvar firstX = polygon[0], firstY = polygon[1];\n\t\t\t\tvar secondX = polygon[2], secondY = polygon[3];\n\t\t\t\tvar winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\t\t\t\tfor (var ii = 0; ii < n; ii++) {\n\t\t\t\t\tif (ii == i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar otherIndices = convexPolygonsIndices[ii];\n\t\t\t\t\tif (otherIndices.length != 3)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar otherFirstIndex = otherIndices[0];\n\t\t\t\t\tvar otherSecondIndex = otherIndices[1];\n\t\t\t\t\tvar otherLastIndex = otherIndices[2];\n\t\t\t\t\tvar otherPoly = convexPolygons[ii];\n\t\t\t\t\tvar x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\n\t\t\t\t\t\totherPoly.length = 0;\n\t\t\t\t\t\totherIndices.length = 0;\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\n\t\t\t\t\t\tprevPrevX = prevX;\n\t\t\t\t\t\tprevPrevY = prevY;\n\t\t\t\t\t\tprevX = x3;\n\t\t\t\t\t\tprevY = y3;\n\t\t\t\t\t\tii = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = convexPolygons.length - 1; i >= 0; i--) {\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tif (polygon.length == 0) {\n\t\t\t\t\tconvexPolygons.splice(i, 1);\n\t\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1);\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn convexPolygons;\n\t\t};\n\t\tTriangulator.isConcave = function (index, vertexCount, vertices, indices) {\n\t\t\tvar previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n\t\t\tvar current = indices[index] << 1;\n\t\t\tvar next = indices[(index + 1) % vertexCount] << 1;\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\n\t\t};\n\t\tTriangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n\t\t};\n\t\tTriangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n\t\t\tvar px = p2x - p1x, py = p2y - p1y;\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n\t\t};\n\t\treturn Triangulator;\n\t}());\n\tspine.Triangulator = Triangulator;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar IntSet = (function () {\n\t\tfunction IntSet() {\n\t\t\tthis.array = new Array();\n\t\t}\n\t\tIntSet.prototype.add = function (value) {\n\t\t\tvar contains = this.contains(value);\n\t\t\tthis.array[value | 0] = value | 0;\n\t\t\treturn !contains;\n\t\t};\n\t\tIntSet.prototype.contains = function (value) {\n\t\t\treturn this.array[value | 0] != undefined;\n\t\t};\n\t\tIntSet.prototype.remove = function (value) {\n\t\t\tthis.array[value | 0] = undefined;\n\t\t};\n\t\tIntSet.prototype.clear = function () {\n\t\t\tthis.array.length = 0;\n\t\t};\n\t\treturn IntSet;\n\t}());\n\tspine.IntSet = IntSet;\n\tvar Color = (function () {\n\t\tfunction Color(r, g, b, a) {\n\t\t\tif (r === void 0) { r = 0; }\n\t\t\tif (g === void 0) { g = 0; }\n\t\t\tif (b === void 0) { b = 0; }\n\t\t\tif (a === void 0) { a = 0; }\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\tthis.a = a;\n\t\t}\n\t\tColor.prototype.set = function (r, g, b, a) {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\tthis.a = a;\n\t\t\tthis.clamp();\n\t\t\treturn this;\n\t\t};\n\t\tColor.prototype.setFromColor = function (c) {\n\t\t\tthis.r = c.r;\n\t\t\tthis.g = c.g;\n\t\t\tthis.b = c.b;\n\t\t\tthis.a = c.a;\n\t\t\treturn this;\n\t\t};\n\t\tColor.prototype.setFromString = function (hex) {\n\t\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n\t\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n\t\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n\t\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n\t\t\tthis.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n\t\t\treturn this;\n\t\t};\n\t\tColor.prototype.add = function (r, g, b, a) {\n\t\t\tthis.r += r;\n\t\t\tthis.g += g;\n\t\t\tthis.b += b;\n\t\t\tthis.a += a;\n\t\t\tthis.clamp();\n\t\t\treturn this;\n\t\t};\n\t\tColor.prototype.clamp = function () {\n\t\t\tif (this.r < 0)\n\t\t\t\tthis.r = 0;\n\t\t\telse if (this.r > 1)\n\t\t\t\tthis.r = 1;\n\t\t\tif (this.g < 0)\n\t\t\t\tthis.g = 0;\n\t\t\telse if (this.g > 1)\n\t\t\t\tthis.g = 1;\n\t\t\tif (this.b < 0)\n\t\t\t\tthis.b = 0;\n\t\t\telse if (this.b > 1)\n\t\t\t\tthis.b = 1;\n\t\t\tif (this.a < 0)\n\t\t\t\tthis.a = 0;\n\t\t\telse if (this.a > 1)\n\t\t\t\tthis.a = 1;\n\t\t\treturn this;\n\t\t};\n\t\tColor.rgba8888ToColor = function (color, value) {\n\t\t\tcolor.r = ((value & 0xff000000) >>> 24) / 255;\n\t\t\tcolor.g = ((value & 0x00ff0000) >>> 16) / 255;\n\t\t\tcolor.b = ((value & 0x0000ff00) >>> 8) / 255;\n\t\t\tcolor.a = ((value & 0x000000ff)) / 255;\n\t\t};\n\t\tColor.rgb888ToColor = function (color, value) {\n\t\t\tcolor.r = ((value & 0x00ff0000) >>> 16) / 255;\n\t\t\tcolor.g = ((value & 0x0000ff00) >>> 8) / 255;\n\t\t\tcolor.b = ((value & 0x000000ff)) / 255;\n\t\t};\n\t\tColor.WHITE = new Color(1, 1, 1, 1);\n\t\tColor.RED = new Color(1, 0, 0, 1);\n\t\tColor.GREEN = new Color(0, 1, 0, 1);\n\t\tColor.BLUE = new Color(0, 0, 1, 1);\n\t\tColor.MAGENTA = new Color(1, 0, 1, 1);\n\t\treturn Color;\n\t}());\n\tspine.Color = Color;\n\tvar MathUtils = (function () {\n\t\tfunction MathUtils() {\n\t\t}\n\t\tMathUtils.clamp = function (value, min, max) {\n\t\t\tif (value < min)\n\t\t\t\treturn min;\n\t\t\tif (value > max)\n\t\t\t\treturn max;\n\t\t\treturn value;\n\t\t};\n\t\tMathUtils.cosDeg = function (degrees) {\n\t\t\treturn Math.cos(degrees * MathUtils.degRad);\n\t\t};\n\t\tMathUtils.sinDeg = function (degrees) {\n\t\t\treturn Math.sin(degrees * MathUtils.degRad);\n\t\t};\n\t\tMathUtils.signum = function (value) {\n\t\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\n\t\t};\n\t\tMathUtils.toInt = function (x) {\n\t\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\n\t\t};\n\t\tMathUtils.cbrt = function (x) {\n\t\t\tvar y = Math.pow(Math.abs(x), 1 / 3);\n\t\t\treturn x < 0 ? -y : y;\n\t\t};\n\t\tMathUtils.randomTriangular = function (min, max) {\n\t\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n\t\t};\n\t\tMathUtils.randomTriangularWith = function (min, max, mode) {\n\t\t\tvar u = Math.random();\n\t\t\tvar d = max - min;\n\t\t\tif (u <= (mode - min) / d)\n\t\t\t\treturn min + Math.sqrt(u * d * (mode - min));\n\t\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\n\t\t};\n\t\tMathUtils.PI = 3.1415927;\n\t\tMathUtils.PI2 = MathUtils.PI * 2;\n\t\tMathUtils.radiansToDegrees = 180 / MathUtils.PI;\n\t\tMathUtils.radDeg = MathUtils.radiansToDegrees;\n\t\tMathUtils.degreesToRadians = MathUtils.PI / 180;\n\t\tMathUtils.degRad = MathUtils.degreesToRadians;\n\t\treturn MathUtils;\n\t}());\n\tspine.MathUtils = MathUtils;\n\tvar Interpolation = (function () {\n\t\tfunction Interpolation() {\n\t\t}\n\t\tInterpolation.prototype.apply = function (start, end, a) {\n\t\t\treturn start + (end - start) * this.applyInternal(a);\n\t\t};\n\t\treturn Interpolation;\n\t}());\n\tspine.Interpolation = Interpolation;\n\tvar Pow = (function (_super) {\n\t\t__extends(Pow, _super);\n\t\tfunction Pow(power) {\n\t\t\tvar _this = _super.call(this) || this;\n\t\t\t_this.power = 2;\n\t\t\t_this.power = power;\n\t\t\treturn _this;\n\t\t}\n\t\tPow.prototype.applyInternal = function (a) {\n\t\t\tif (a <= 0.5)\n\t\t\t\treturn Math.pow(a * 2, this.power) / 2;\n\t\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n\t\t};\n\t\treturn Pow;\n\t}(Interpolation));\n\tspine.Pow = Pow;\n\tvar PowOut = (function (_super) {\n\t\t__extends(PowOut, _super);\n\t\tfunction PowOut(power) {\n\t\t\treturn _super.call(this, power) || this;\n\t\t}\n\t\tPowOut.prototype.applyInternal = function (a) {\n\t\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n\t\t};\n\t\treturn PowOut;\n\t}(Pow));\n\tspine.PowOut = PowOut;\n\tvar Utils = (function () {\n\t\tfunction Utils() {\n\t\t}\n\t\tUtils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\n\t\t\tfor (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n\t\t\t\tdest[j] = source[i];\n\t\t\t}\n\t\t};\n\t\tUtils.setArraySize = function (array, size, value) {\n\t\t\tif (value === void 0) { value = 0; }\n\t\t\tvar oldSize = array.length;\n\t\t\tif (oldSize == size)\n\t\t\t\treturn array;\n\t\t\tarray.length = size;\n\t\t\tif (oldSize < size) {\n\t\t\t\tfor (var i = oldSize; i < size; i++)\n\t\t\t\t\tarray[i] = value;\n\t\t\t}\n\t\t\treturn array;\n\t\t};\n\t\tUtils.ensureArrayCapacity = function (array, size, value) {\n\t\t\tif (value === void 0) { value = 0; }\n\t\t\tif (array.length >= size)\n\t\t\t\treturn array;\n\t\t\treturn Utils.setArraySize(array, size, value);\n\t\t};\n\t\tUtils.newArray = function (size, defaultValue) {\n\t\t\tvar array = new Array(size);\n\t\t\tfor (var i = 0; i < size; i++)\n\t\t\t\tarray[i] = defaultValue;\n\t\t\treturn array;\n\t\t};\n\t\tUtils.newFloatArray = function (size) {\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\n\t\t\t\treturn new Float32Array(size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar array = new Array(size);\n\t\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t\t\tarray[i] = 0;\n\t\t\t\treturn array;\n\t\t\t}\n\t\t};\n\t\tUtils.newShortArray = function (size) {\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\n\t\t\t\treturn new Int16Array(size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar array = new Array(size);\n\t\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t\t\tarray[i] = 0;\n\t\t\t\treturn array;\n\t\t\t}\n\t\t};\n\t\tUtils.toFloatArray = function (array) {\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n\t\t};\n\t\tUtils.toSinglePrecision = function (value) {\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n\t\t};\n\t\tUtils.webkit602BugfixHelper = function (alpha, blend) {\n\t\t};\n\t\tUtils.contains = function (array, element, identity) {\n\t\t\tif (identity === void 0) { identity = true; }\n\t\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\t\tif (array[i] == element)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tUtils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\n\t\treturn Utils;\n\t}());\n\tspine.Utils = Utils;\n\tvar DebugUtils = (function () {\n\t\tfunction DebugUtils() {\n\t\t}\n\t\tDebugUtils.logBones = function (skeleton) {\n\t\t\tfor (var i = 0; i < skeleton.bones.length; i++) {\n\t\t\t\tvar bone = skeleton.bones[i];\n\t\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\n\t\t\t}\n\t\t};\n\t\treturn DebugUtils;\n\t}());\n\tspine.DebugUtils = DebugUtils;\n\tvar Pool = (function () {\n\t\tfunction Pool(instantiator) {\n\t\t\tthis.items = new Array();\n\t\t\tthis.instantiator = instantiator;\n\t\t}\n\t\tPool.prototype.obtain = function () {\n\t\t\treturn this.items.length > 0 ? this.items.pop() : this.instantiator();\n\t\t};\n\t\tPool.prototype.free = function (item) {\n\t\t\tif (item.reset)\n\t\t\t\titem.reset();\n\t\t\tthis.items.push(item);\n\t\t};\n\t\tPool.prototype.freeAll = function (items) {\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tthis.free(items[i]);\n\t\t\t}\n\t\t};\n\t\tPool.prototype.clear = function () {\n\t\t\tthis.items.length = 0;\n\t\t};\n\t\treturn Pool;\n\t}());\n\tspine.Pool = Pool;\n\tvar Vector2 = (function () {\n\t\tfunction Vector2(x, y) {\n\t\t\tif (x === void 0) { x = 0; }\n\t\t\tif (y === void 0) { y = 0; }\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tVector2.prototype.set = function (x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t};\n\t\tVector2.prototype.length = function () {\n\t\t\tvar x = this.x;\n\t\t\tvar y = this.y;\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t};\n\t\tVector2.prototype.normalize = function () {\n\t\t\tvar len = this.length();\n\t\t\tif (len != 0) {\n\t\t\t\tthis.x /= len;\n\t\t\t\tthis.y /= len;\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t\treturn Vector2;\n\t}());\n\tspine.Vector2 = Vector2;\n\tvar TimeKeeper = (function () {\n\t\tfunction TimeKeeper() {\n\t\t\tthis.maxDelta = 0.064;\n\t\t\tthis.framesPerSecond = 0;\n\t\t\tthis.delta = 0;\n\t\t\tthis.totalTime = 0;\n\t\t\tthis.lastTime = Date.now() / 1000;\n\t\t\tthis.frameCount = 0;\n\t\t\tthis.frameTime = 0;\n\t\t}\n\t\tTimeKeeper.prototype.update = function () {\n\t\t\tvar now = Date.now() / 1000;\n\t\t\tthis.delta = now - this.lastTime;\n\t\t\tthis.frameTime += this.delta;\n\t\t\tthis.totalTime += this.delta;\n\t\t\tif (this.delta > this.maxDelta)\n\t\t\t\tthis.delta = this.maxDelta;\n\t\t\tthis.lastTime = now;\n\t\t\tthis.frameCount++;\n\t\t\tif (this.frameTime > 1) {\n\t\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\n\t\t\t\tthis.frameTime = 0;\n\t\t\t\tthis.frameCount = 0;\n\t\t\t}\n\t\t};\n\t\treturn TimeKeeper;\n\t}());\n\tspine.TimeKeeper = TimeKeeper;\n\tvar WindowedMean = (function () {\n\t\tfunction WindowedMean(windowSize) {\n\t\t\tif (windowSize === void 0) { windowSize = 32; }\n\t\t\tthis.addedValues = 0;\n\t\t\tthis.lastValue = 0;\n\t\t\tthis.mean = 0;\n\t\t\tthis.dirty = true;\n\t\t\tthis.values = new Array(windowSize);\n\t\t}\n\t\tWindowedMean.prototype.hasEnoughData = function () {\n\t\t\treturn this.addedValues >= this.values.length;\n\t\t};\n\t\tWindowedMean.prototype.addValue = function (value) {\n\t\t\tif (this.addedValues < this.values.length)\n\t\t\t\tthis.addedValues++;\n\t\t\tthis.values[this.lastValue++] = value;\n\t\t\tif (this.lastValue > this.values.length - 1)\n\t\t\t\tthis.lastValue = 0;\n\t\t\tthis.dirty = true;\n\t\t};\n\t\tWindowedMean.prototype.getMean = function () {\n\t\t\tif (this.hasEnoughData()) {\n\t\t\t\tif (this.dirty) {\n\t\t\t\t\tvar mean = 0;\n\t\t\t\t\tfor (var i = 0; i < this.values.length; i++) {\n\t\t\t\t\t\tmean += this.values[i];\n\t\t\t\t\t}\n\t\t\t\t\tthis.mean = mean / this.values.length;\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t}\n\t\t\t\treturn this.mean;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t};\n\t\treturn WindowedMean;\n\t}());\n\tspine.WindowedMean = WindowedMean;\n})(spine || (spine = {}));\n(function () {\n\tif (!Math.fround) {\n\t\tMath.fround = (function (array) {\n\t\t\treturn function (x) {\n\t\t\t\treturn array[0] = x, array[0];\n\t\t\t};\n\t\t})(new Float32Array(1));\n\t}\n})();\nvar spine;\n(function (spine) {\n\tvar Attachment = (function () {\n\t\tfunction Attachment(name) {\n\t\t\tif (name == null)\n\t\t\t\tthrow new Error(\"name cannot be null.\");\n\t\t\tthis.name = name;\n\t\t}\n\t\treturn Attachment;\n\t}());\n\tspine.Attachment = Attachment;\n\tvar VertexAttachment = (function (_super) {\n\t\t__extends(VertexAttachment, _super);\n\t\tfunction VertexAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.id = (VertexAttachment.nextID++ & 65535) << 11;\n\t\t\t_this.worldVerticesLength = 0;\n\t\t\t_this.deformAttachment = _this;\n\t\t\treturn _this;\n\t\t}\n\t\tVertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\n\t\t\tcount = offset + (count >> 1) * stride;\n\t\t\tvar skeleton = slot.bone.skeleton;\n\t\t\tvar deformArray = slot.deform;\n\t\t\tvar vertices = this.vertices;\n\t\t\tvar bones = this.bones;\n\t\t\tif (bones == null) {\n\t\t\t\tif (deformArray.length > 0)\n\t\t\t\t\tvertices = deformArray;\n\t\t\t\tvar bone = slot.bone;\n\t\t\t\tvar x = bone.worldX;\n\t\t\t\tvar y = bone.worldY;\n\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\t\tfor (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\n\t\t\t\t\tvar vx = vertices[v_1], vy = vertices[v_1 + 1];\n\t\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\n\t\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar v = 0, skip = 0;\n\t\t\tfor (var i = 0; i < start; i += 2) {\n\t\t\t\tvar n = bones[v];\n\t\t\t\tv += n + 1;\n\t\t\t\tskip += n;\n\t\t\t}\n\t\t\tvar skeletonBones = skeleton.bones;\n\t\t\tif (deformArray.length == 0) {\n\t\t\t\tfor (var w = offset, b = skip * 3; w < count; w += stride) {\n\t\t\t\t\tvar wx = 0, wy = 0;\n\t\t\t\t\tvar n = bones[v++];\n\t\t\t\t\tn += v;\n\t\t\t\t\tfor (; v < n; v++, b += 3) {\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\n\t\t\t\t\t\tvar vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n\t\t\t\t\t}\n\t\t\t\t\tworldVertices[w] = wx;\n\t\t\t\t\tworldVertices[w + 1] = wy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar deform = deformArray;\n\t\t\t\tfor (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n\t\t\t\t\tvar wx = 0, wy = 0;\n\t\t\t\t\tvar n = bones[v++];\n\t\t\t\t\tn += v;\n\t\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\n\t\t\t\t\t\tvar vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n\t\t\t\t\t}\n\t\t\t\t\tworldVertices[w] = wx;\n\t\t\t\t\tworldVertices[w + 1] = wy;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tVertexAttachment.prototype.copyTo = function (attachment) {\n\t\t\tif (this.bones != null) {\n\t\t\t\tattachment.bones = new Array(this.bones.length);\n\t\t\t\tspine.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n\t\t\t}\n\t\t\telse\n\t\t\t\tattachment.bones = null;\n\t\t\tif (this.vertices != null) {\n\t\t\t\tattachment.vertices = spine.Utils.newFloatArray(this.vertices.length);\n\t\t\t\tspine.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n\t\t\t}\n\t\t\telse\n\t\t\t\tattachment.vertices = null;\n\t\t\tattachment.worldVerticesLength = this.worldVerticesLength;\n\t\t\tattachment.deformAttachment = this.deformAttachment;\n\t\t};\n\t\tVertexAttachment.nextID = 0;\n\t\treturn VertexAttachment;\n\t}(Attachment));\n\tspine.VertexAttachment = VertexAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar AttachmentType;\n\t(function (AttachmentType) {\n\t\tAttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\n\t\tAttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\n\t\tAttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\n\t\tAttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n\t\tAttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\n\t\tAttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\n\t\tAttachmentType[AttachmentType[\"Clipping\"] = 6] = \"Clipping\";\n\t})(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar BoundingBoxAttachment = (function (_super) {\n\t\t__extends(BoundingBoxAttachment, _super);\n\t\tfunction BoundingBoxAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\n\t\t\treturn _this;\n\t\t}\n\t\tBoundingBoxAttachment.prototype.copy = function () {\n\t\t\tvar copy = new BoundingBoxAttachment(this.name);\n\t\t\tthis.copyTo(copy);\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\treturn copy;\n\t\t};\n\t\treturn BoundingBoxAttachment;\n\t}(spine.VertexAttachment));\n\tspine.BoundingBoxAttachment = BoundingBoxAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar ClippingAttachment = (function (_super) {\n\t\t__extends(ClippingAttachment, _super);\n\t\tfunction ClippingAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\n\t\t\treturn _this;\n\t\t}\n\t\tClippingAttachment.prototype.copy = function () {\n\t\t\tvar copy = new ClippingAttachment(this.name);\n\t\t\tthis.copyTo(copy);\n\t\t\tcopy.endSlot = this.endSlot;\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\treturn copy;\n\t\t};\n\t\treturn ClippingAttachment;\n\t}(spine.VertexAttachment));\n\tspine.ClippingAttachment = ClippingAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar MeshAttachment = (function (_super) {\n\t\t__extends(MeshAttachment, _super);\n\t\tfunction MeshAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\n\t\t\t_this.tempColor = new spine.Color(0, 0, 0, 0);\n\t\t\treturn _this;\n\t\t}\n\t\tMeshAttachment.prototype.updateUVs = function () {\n\t\t\tvar regionUVs = this.regionUVs;\n\t\t\tif (this.uvs == null || this.uvs.length != regionUVs.length)\n\t\t\t\tthis.uvs = spine.Utils.newFloatArray(regionUVs.length);\n\t\t\tvar uvs = this.uvs;\n\t\t\tvar n = this.uvs.length;\n\t\t\tvar u = this.region.u, v = this.region.v, width = 0, height = 0;\n\t\t\tif (this.region instanceof spine.TextureAtlasRegion) {\n\t\t\t\tvar region = this.region;\n\t\t\t\tvar textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;\n\t\t\t\tswitch (region.degrees) {\n\t\t\t\t\tcase 90:\n\t\t\t\t\t\tu -= (region.originalHeight - region.offsetY - region.height) / textureWidth;\n\t\t\t\t\t\tv -= (region.originalWidth - region.offsetX - region.width) / textureHeight;\n\t\t\t\t\t\twidth = region.originalHeight / textureWidth;\n\t\t\t\t\t\theight = region.originalWidth / textureHeight;\n\t\t\t\t\t\tfor (var i = 0; i < n; i += 2) {\n\t\t\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\n\t\t\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i]) * height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 180:\n\t\t\t\t\t\tu -= (region.originalWidth - region.offsetX - region.width) / textureWidth;\n\t\t\t\t\t\tv -= region.offsetY / textureHeight;\n\t\t\t\t\t\twidth = region.originalWidth / textureWidth;\n\t\t\t\t\t\theight = region.originalHeight / textureHeight;\n\t\t\t\t\t\tfor (var i = 0; i < n; i += 2) {\n\t\t\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i]) * width;\n\t\t\t\t\t\t\tuvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 270:\n\t\t\t\t\t\tu -= region.offsetY / textureWidth;\n\t\t\t\t\t\tv -= region.offsetX / textureHeight;\n\t\t\t\t\t\twidth = region.originalHeight / textureWidth;\n\t\t\t\t\t\theight = region.originalWidth / textureHeight;\n\t\t\t\t\t\tfor (var i = 0; i < n; i += 2) {\n\t\t\t\t\t\t\tuvs[i] = u + (1 - regionUVs[i + 1]) * width;\n\t\t\t\t\t\t\tuvs[i + 1] = v + regionUVs[i] * height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tu -= region.offsetX / textureWidth;\n\t\t\t\tv -= (region.originalHeight - region.offsetY - region.height) / textureHeight;\n\t\t\t\twidth = region.originalWidth / textureWidth;\n\t\t\t\theight = region.originalHeight / textureHeight;\n\t\t\t}\n\t\t\telse if (this.region == null) {\n\t\t\t\tu = v = 0;\n\t\t\t\twidth = height = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twidth = this.region.u2 - u;\n\t\t\t\theight = this.region.v2 - v;\n\t\t\t}\n\t\t\tfor (var i = 0; i < n; i += 2) {\n\t\t\t\tuvs[i] = u + regionUVs[i] * width;\n\t\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\n\t\t\t}\n\t\t};\n\t\tMeshAttachment.prototype.getParentMesh = function () {\n\t\t\treturn this.parentMesh;\n\t\t};\n\t\tMeshAttachment.prototype.setParentMesh = function (parentMesh) {\n\t\t\tthis.parentMesh = parentMesh;\n\t\t\tif (parentMesh != null) {\n\t\t\t\tthis.bones = parentMesh.bones;\n\t\t\t\tthis.vertices = parentMesh.vertices;\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\n\t\t\t\tthis.regionUVs = parentMesh.regionUVs;\n\t\t\t\tthis.triangles = parentMesh.triangles;\n\t\t\t\tthis.hullLength = parentMesh.hullLength;\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\n\t\t\t}\n\t\t};\n\t\tMeshAttachment.prototype.copy = function () {\n\t\t\tif (this.parentMesh != null)\n\t\t\t\treturn this.newLinkedMesh();\n\t\t\tvar copy = new MeshAttachment(this.name);\n\t\t\tcopy.region = this.region;\n\t\t\tcopy.path = this.path;\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\tthis.copyTo(copy);\n\t\t\tcopy.regionUVs = new Array(this.regionUVs.length);\n\t\t\tspine.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n\t\t\tcopy.uvs = new Array(this.uvs.length);\n\t\t\tspine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\n\t\t\tcopy.triangles = new Array(this.triangles.length);\n\t\t\tspine.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n\t\t\tcopy.hullLength = this.hullLength;\n\t\t\tif (this.edges != null) {\n\t\t\t\tcopy.edges = new Array(this.edges.length);\n\t\t\t\tspine.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n\t\t\t}\n\t\t\tcopy.width = this.width;\n\t\t\tcopy.height = this.height;\n\t\t\treturn copy;\n\t\t};\n\t\tMeshAttachment.prototype.newLinkedMesh = function () {\n\t\t\tvar copy = new MeshAttachment(this.name);\n\t\t\tcopy.region = this.region;\n\t\t\tcopy.path = this.path;\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\tcopy.deformAttachment = this.deformAttachment;\n\t\t\tcopy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\n\t\t\tcopy.updateUVs();\n\t\t\treturn copy;\n\t\t};\n\t\treturn MeshAttachment;\n\t}(spine.VertexAttachment));\n\tspine.MeshAttachment = MeshAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar PathAttachment = (function (_super) {\n\t\t__extends(PathAttachment, _super);\n\t\tfunction PathAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.closed = false;\n\t\t\t_this.constantSpeed = false;\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\n\t\t\treturn _this;\n\t\t}\n\t\tPathAttachment.prototype.copy = function () {\n\t\t\tvar copy = new PathAttachment(this.name);\n\t\t\tthis.copyTo(copy);\n\t\t\tcopy.lengths = new Array(this.lengths.length);\n\t\t\tspine.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n\t\t\tcopy.closed = closed;\n\t\t\tcopy.constantSpeed = this.constantSpeed;\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\treturn copy;\n\t\t};\n\t\treturn PathAttachment;\n\t}(spine.VertexAttachment));\n\tspine.PathAttachment = PathAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar PointAttachment = (function (_super) {\n\t\t__extends(PointAttachment, _super);\n\t\tfunction PointAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.color = new spine.Color(0.38, 0.94, 0, 1);\n\t\t\treturn _this;\n\t\t}\n\t\tPointAttachment.prototype.computeWorldPosition = function (bone, point) {\n\t\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\n\t\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\n\t\t\treturn point;\n\t\t};\n\t\tPointAttachment.prototype.computeWorldRotation = function (bone) {\n\t\t\tvar cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\n\t\t\tvar x = cos * bone.a + sin * bone.b;\n\t\t\tvar y = cos * bone.c + sin * bone.d;\n\t\t\treturn Math.atan2(y, x) * spine.MathUtils.radDeg;\n\t\t};\n\t\tPointAttachment.prototype.copy = function () {\n\t\t\tvar copy = new PointAttachment(this.name);\n\t\t\tcopy.x = this.x;\n\t\t\tcopy.y = this.y;\n\t\t\tcopy.rotation = this.rotation;\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\treturn copy;\n\t\t};\n\t\treturn PointAttachment;\n\t}(spine.VertexAttachment));\n\tspine.PointAttachment = PointAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar RegionAttachment = (function (_super) {\n\t\t__extends(RegionAttachment, _super);\n\t\tfunction RegionAttachment(name) {\n\t\t\tvar _this = _super.call(this, name) || this;\n\t\t\t_this.x = 0;\n\t\t\t_this.y = 0;\n\t\t\t_this.scaleX = 1;\n\t\t\t_this.scaleY = 1;\n\t\t\t_this.rotation = 0;\n\t\t\t_this.width = 0;\n\t\t\t_this.height = 0;\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\n\t\t\t_this.offset = spine.Utils.newFloatArray(8);\n\t\t\t_this.uvs = spine.Utils.newFloatArray(8);\n\t\t\t_this.tempColor = new spine.Color(1, 1, 1, 1);\n\t\t\treturn _this;\n\t\t}\n\t\tRegionAttachment.prototype.updateOffset = function () {\n\t\t\tvar regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n\t\t\tvar regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n\t\t\tvar localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n\t\t\tvar localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n\t\t\tvar localX2 = localX + this.region.width * regionScaleX;\n\t\t\tvar localY2 = localY + this.region.height * regionScaleY;\n\t\t\tvar radians = this.rotation * Math.PI / 180;\n\t\t\tvar cos = Math.cos(radians);\n\t\t\tvar sin = Math.sin(radians);\n\t\t\tvar localXCos = localX * cos + this.x;\n\t\t\tvar localXSin = localX * sin;\n\t\t\tvar localYCos = localY * cos + this.y;\n\t\t\tvar localYSin = localY * sin;\n\t\t\tvar localX2Cos = localX2 * cos + this.x;\n\t\t\tvar localX2Sin = localX2 * sin;\n\t\t\tvar localY2Cos = localY2 * cos + this.y;\n\t\t\tvar localY2Sin = localY2 * sin;\n\t\t\tvar offset = this.offset;\n\t\t\toffset[RegionAttachment.OX1] = localXCos - localYSin;\n\t\t\toffset[RegionAttachment.OY1] = localYCos + localXSin;\n\t\t\toffset[RegionAttachment.OX2] = localXCos - localY2Sin;\n\t\t\toffset[RegionAttachment.OY2] = localY2Cos + localXSin;\n\t\t\toffset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n\t\t\toffset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n\t\t\toffset[RegionAttachment.OX4] = localX2Cos - localYSin;\n\t\t\toffset[RegionAttachment.OY4] = localYCos + localX2Sin;\n\t\t};\n\t\tRegionAttachment.prototype.setRegion = function (region) {\n\t\t\tthis.region = region;\n\t\t\tvar uvs = this.uvs;\n\t\t\tif (region.rotate) {\n\t\t\t\tuvs[2] = region.u;\n\t\t\t\tuvs[3] = region.v2;\n\t\t\t\tuvs[4] = region.u;\n\t\t\t\tuvs[5] = region.v;\n\t\t\t\tuvs[6] = region.u2;\n\t\t\t\tuvs[7] = region.v;\n\t\t\t\tuvs[0] = region.u2;\n\t\t\t\tuvs[1] = region.v2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuvs[0] = region.u;\n\t\t\t\tuvs[1] = region.v2;\n\t\t\t\tuvs[2] = region.u;\n\t\t\t\tuvs[3] = region.v;\n\t\t\t\tuvs[4] = region.u2;\n\t\t\t\tuvs[5] = region.v;\n\t\t\t\tuvs[6] = region.u2;\n\t\t\t\tuvs[7] = region.v2;\n\t\t\t}\n\t\t};\n\t\tRegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\n\t\t\tvar vertexOffset = this.offset;\n\t\t\tvar x = bone.worldX, y = bone.worldY;\n\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n\t\t\tvar offsetX = 0, offsetY = 0;\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX1];\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY1];\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\t\toffset += stride;\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX2];\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY2];\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\t\toffset += stride;\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX3];\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY3];\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\t\toffset += stride;\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX4];\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY4];\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n\t\t};\n\t\tRegionAttachment.prototype.copy = function () {\n\t\t\tvar copy = new RegionAttachment(this.name);\n\t\t\tcopy.region = this.region;\n\t\t\tcopy.rendererObject = this.rendererObject;\n\t\t\tcopy.path = this.path;\n\t\t\tcopy.x = this.x;\n\t\t\tcopy.y = this.y;\n\t\t\tcopy.scaleX = this.scaleX;\n\t\t\tcopy.scaleY = this.scaleY;\n\t\t\tcopy.rotation = this.rotation;\n\t\t\tcopy.width = this.width;\n\t\t\tcopy.height = this.height;\n\t\t\tspine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n\t\t\tspine.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n\t\t\tcopy.color.setFromColor(this.color);\n\t\t\treturn copy;\n\t\t};\n\t\tRegionAttachment.OX1 = 0;\n\t\tRegionAttachment.OY1 = 1;\n\t\tRegionAttachment.OX2 = 2;\n\t\tRegionAttachment.OY2 = 3;\n\t\tRegionAttachment.OX3 = 4;\n\t\tRegionAttachment.OY3 = 5;\n\t\tRegionAttachment.OX4 = 6;\n\t\tRegionAttachment.OY4 = 7;\n\t\tRegionAttachment.X1 = 0;\n\t\tRegionAttachment.Y1 = 1;\n\t\tRegionAttachment.C1R = 2;\n\t\tRegionAttachment.C1G = 3;\n\t\tRegionAttachment.C1B = 4;\n\t\tRegionAttachment.C1A = 5;\n\t\tRegionAttachment.U1 = 6;\n\t\tRegionAttachment.V1 = 7;\n\t\tRegionAttachment.X2 = 8;\n\t\tRegionAttachment.Y2 = 9;\n\t\tRegionAttachment.C2R = 10;\n\t\tRegionAttachment.C2G = 11;\n\t\tRegionAttachment.C2B = 12;\n\t\tRegionAttachment.C2A = 13;\n\t\tRegionAttachment.U2 = 14;\n\t\tRegionAttachment.V2 = 15;\n\t\tRegionAttachment.X3 = 16;\n\t\tRegionAttachment.Y3 = 17;\n\t\tRegionAttachment.C3R = 18;\n\t\tRegionAttachment.C3G = 19;\n\t\tRegionAttachment.C3B = 20;\n\t\tRegionAttachment.C3A = 21;\n\t\tRegionAttachment.U3 = 22;\n\t\tRegionAttachment.V3 = 23;\n\t\tRegionAttachment.X4 = 24;\n\t\tRegionAttachment.Y4 = 25;\n\t\tRegionAttachment.C4R = 26;\n\t\tRegionAttachment.C4G = 27;\n\t\tRegionAttachment.C4B = 28;\n\t\tRegionAttachment.C4A = 29;\n\t\tRegionAttachment.U4 = 30;\n\t\tRegionAttachment.V4 = 31;\n\t\treturn RegionAttachment;\n\t}(spine.Attachment));\n\tspine.RegionAttachment = RegionAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar JitterEffect = (function () {\n\t\tfunction JitterEffect(jitterX, jitterY) {\n\t\t\tthis.jitterX = 0;\n\t\t\tthis.jitterY = 0;\n\t\t\tthis.jitterX = jitterX;\n\t\t\tthis.jitterY = jitterY;\n\t\t}\n\t\tJitterEffect.prototype.begin = function (skeleton) {\n\t\t};\n\t\tJitterEffect.prototype.transform = function (position, uv, light, dark) {\n\t\t\tposition.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t\tposition.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t};\n\t\tJitterEffect.prototype.end = function () {\n\t\t};\n\t\treturn JitterEffect;\n\t}());\n\tspine.JitterEffect = JitterEffect;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar SwirlEffect = (function () {\n\t\tfunction SwirlEffect(radius) {\n\t\t\tthis.centerX = 0;\n\t\t\tthis.centerY = 0;\n\t\t\tthis.radius = 0;\n\t\t\tthis.angle = 0;\n\t\t\tthis.worldX = 0;\n\t\t\tthis.worldY = 0;\n\t\t\tthis.radius = radius;\n\t\t}\n\t\tSwirlEffect.prototype.begin = function (skeleton) {\n\t\t\tthis.worldX = skeleton.x + this.centerX;\n\t\t\tthis.worldY = skeleton.y + this.centerY;\n\t\t};\n\t\tSwirlEffect.prototype.transform = function (position, uv, light, dark) {\n\t\t\tvar radAngle = this.angle * spine.MathUtils.degreesToRadians;\n\t\t\tvar x = position.x - this.worldX;\n\t\t\tvar y = position.y - this.worldY;\n\t\t\tvar dist = Math.sqrt(x * x + y * y);\n\t\t\tif (dist < this.radius) {\n\t\t\t\tvar theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n\t\t\t\tvar cos = Math.cos(theta);\n\t\t\t\tvar sin = Math.sin(theta);\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\n\t\t\t}\n\t\t};\n\t\tSwirlEffect.prototype.end = function () {\n\t\t};\n\t\tSwirlEffect.interpolation = new spine.PowOut(2);\n\t\treturn SwirlEffect;\n\t}());\n\tspine.SwirlEffect = SwirlEffect;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar AssetManager = (function (_super) {\n\t\t\t__extends(AssetManager, _super);\n\t\t\tfunction AssetManager(context, pathPrefix) {\n\t\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\n\t\t\t\treturn _super.call(this, function (image) {\n\t\t\t\t\treturn new spine.webgl.GLTexture(context, image);\n\t\t\t\t}, pathPrefix) || this;\n\t\t\t}\n\t\t\treturn AssetManager;\n\t\t}(spine.AssetManager));\n\t\twebgl.AssetManager = AssetManager;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar OrthoCamera = (function () {\n\t\t\tfunction OrthoCamera(viewportWidth, viewportHeight) {\n\t\t\t\tthis.position = new webgl.Vector3(0, 0, 0);\n\t\t\t\tthis.direction = new webgl.Vector3(0, 0, -1);\n\t\t\t\tthis.up = new webgl.Vector3(0, 1, 0);\n\t\t\t\tthis.near = 0;\n\t\t\t\tthis.far = 100;\n\t\t\t\tthis.zoom = 1;\n\t\t\t\tthis.viewportWidth = 0;\n\t\t\t\tthis.viewportHeight = 0;\n\t\t\t\tthis.projectionView = new webgl.Matrix4();\n\t\t\t\tthis.inverseProjectionView = new webgl.Matrix4();\n\t\t\t\tthis.projection = new webgl.Matrix4();\n\t\t\t\tthis.view = new webgl.Matrix4();\n\t\t\t\tthis.tmp = new webgl.Vector3();\n\t\t\t\tthis.viewportWidth = viewportWidth;\n\t\t\t\tthis.viewportHeight = viewportHeight;\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t\tOrthoCamera.prototype.update = function () {\n\t\t\t\tvar projection = this.projection;\n\t\t\t\tvar view = this.view;\n\t\t\t\tvar projectionView = this.projectionView;\n\t\t\t\tvar inverseProjectionView = this.inverseProjectionView;\n\t\t\t\tvar zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;\n\t\t\t\tprojection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);\n\t\t\t\tview.lookAt(this.position, this.direction, this.up);\n\t\t\t\tprojectionView.set(projection.values);\n\t\t\t\tprojectionView.multiply(view);\n\t\t\t\tinverseProjectionView.set(projectionView.values).invert();\n\t\t\t};\n\t\t\tOrthoCamera.prototype.screenToWorld = function (screenCoords, screenWidth, screenHeight) {\n\t\t\t\tvar x = screenCoords.x, y = screenHeight - screenCoords.y - 1;\n\t\t\t\tvar tmp = this.tmp;\n\t\t\t\ttmp.x = (2 * x) / screenWidth - 1;\n\t\t\t\ttmp.y = (2 * y) / screenHeight - 1;\n\t\t\t\ttmp.z = (2 * screenCoords.z) - 1;\n\t\t\t\ttmp.project(this.inverseProjectionView);\n\t\t\t\tscreenCoords.set(tmp.x, tmp.y, tmp.z);\n\t\t\t\treturn screenCoords;\n\t\t\t};\n\t\t\tOrthoCamera.prototype.setViewport = function (viewportWidth, viewportHeight) {\n\t\t\t\tthis.viewportWidth = viewportWidth;\n\t\t\t\tthis.viewportHeight = viewportHeight;\n\t\t\t};\n\t\t\treturn OrthoCamera;\n\t\t}());\n\t\twebgl.OrthoCamera = OrthoCamera;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar GLTexture = (function (_super) {\n\t\t\t__extends(GLTexture, _super);\n\t\t\tfunction GLTexture(context, image, useMipMaps) {\n\t\t\t\tif (useMipMaps === void 0) { useMipMaps = false; }\n\t\t\t\tvar _this = _super.call(this, image) || this;\n\t\t\t\t_this.texture = null;\n\t\t\t\t_this.boundUnit = 0;\n\t\t\t\t_this.useMipMaps = false;\n\t\t\t\t_this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\t_this.useMipMaps = useMipMaps;\n\t\t\t\t_this.restore();\n\t\t\t\t_this.context.addRestorable(_this);\n\t\t\t\treturn _this;\n\t\t\t}\n\t\t\tGLTexture.prototype.setFilters = function (minFilter, magFilter) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.bind();\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, GLTexture.validateMagFilter(magFilter));\n\t\t\t};\n\t\t\tGLTexture.validateMagFilter = function (magFilter) {\n\t\t\t\tswitch (magFilter) {\n\t\t\t\t\tcase spine.TextureFilter.MipMap:\n\t\t\t\t\tcase spine.TextureFilter.MipMapLinearLinear:\n\t\t\t\t\tcase spine.TextureFilter.MipMapLinearNearest:\n\t\t\t\t\tcase spine.TextureFilter.MipMapNearestLinear:\n\t\t\t\t\tcase spine.TextureFilter.MipMapNearestNearest:\n\t\t\t\t\t\treturn spine.TextureFilter.Linear;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn magFilter;\n\t\t\t\t}\n\t\t\t};\n\t\t\tGLTexture.prototype.setWraps = function (uWrap, vWrap) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.bind();\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);\n\t\t\t};\n\t\t\tGLTexture.prototype.update = function (useMipMaps) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (!this.texture) {\n\t\t\t\t\tthis.texture = this.context.gl.createTexture();\n\t\t\t\t}\n\t\t\t\tthis.bind();\n\t\t\t\tif (GLTexture.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL)\n\t\t\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\tif (useMipMaps)\n\t\t\t\t\tgl.generateMipmap(gl.TEXTURE_2D);\n\t\t\t};\n\t\t\tGLTexture.prototype.restore = function () {\n\t\t\t\tthis.texture = null;\n\t\t\t\tthis.update(this.useMipMaps);\n\t\t\t};\n\t\t\tGLTexture.prototype.bind = function (unit) {\n\t\t\t\tif (unit === void 0) { unit = 0; }\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.boundUnit = unit;\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + unit);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\t\t};\n\t\t\tGLTexture.prototype.unbind = function () {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + this.boundUnit);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\t\t};\n\t\t\tGLTexture.prototype.dispose = function () {\n\t\t\t\tthis.context.removeRestorable(this);\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tgl.deleteTexture(this.texture);\n\t\t\t};\n\t\t\tGLTexture.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = false;\n\t\t\treturn GLTexture;\n\t\t}(spine.Texture));\n\t\twebgl.GLTexture = GLTexture;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar Input = (function () {\n\t\t\tfunction Input(element) {\n\t\t\t\tthis.lastX = 0;\n\t\t\t\tthis.lastY = 0;\n\t\t\t\tthis.buttonDown = false;\n\t\t\t\tthis.currTouch = null;\n\t\t\t\tthis.touchesPool = new spine.Pool(function () {\n\t\t\t\t\treturn new spine.webgl.Touch(0, 0, 0);\n\t\t\t\t});\n\t\t\t\tthis.listeners = new Array();\n\t\t\t\tthis.element = element;\n\t\t\t\tthis.setupCallbacks(element);\n\t\t\t}\n\t\t\tInput.prototype.setupCallbacks = function (element) {\n\t\t\t\tvar _this = this;\n\t\t\t\tvar mouseDown = function (ev) {\n\t\t\t\t\tif (ev instanceof MouseEvent) {\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\n\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\t\t\t\t\tif (listeners[i].down)\n\t\t\t\t\t\t\t\tlisteners[i].down(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_this.lastX = x;\n\t\t\t\t\t\t_this.lastY = y;\n\t\t\t\t\t\t_this.buttonDown = true;\n\t\t\t\t\t\tdocument.addEventListener(\"mousemove\", mouseMove);\n\t\t\t\t\t\tdocument.addEventListener(\"mouseup\", mouseUp);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar mouseMove = function (ev) {\n\t\t\t\t\tif (ev instanceof MouseEvent) {\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\n\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\t\t\t\t\tif (_this.buttonDown) {\n\t\t\t\t\t\t\t\tif (listeners[i].dragged)\n\t\t\t\t\t\t\t\t\tlisteners[i].dragged(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (listeners[i].moved)\n\t\t\t\t\t\t\t\t\tlisteners[i].moved(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_this.lastX = x;\n\t\t\t\t\t\t_this.lastY = y;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar mouseUp = function (ev) {\n\t\t\t\t\tif (ev instanceof MouseEvent) {\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\tvar x = ev.clientX - rect.left;\n\t\t\t\t\t\tvar y = ev.clientY - rect.top;\n\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\t\t\t\t\tif (listeners[i].up)\n\t\t\t\t\t\t\t\tlisteners[i].up(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_this.lastX = x;\n\t\t\t\t\t\t_this.lastY = y;\n\t\t\t\t\t\t_this.buttonDown = false;\n\t\t\t\t\t\tdocument.removeEventListener(\"mousemove\", mouseMove);\n\t\t\t\t\t\tdocument.removeEventListener(\"mouseup\", mouseUp);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\telement.addEventListener(\"mousedown\", mouseDown, true);\n\t\t\t\telement.addEventListener(\"mousemove\", mouseMove, true);\n\t\t\t\telement.addEventListener(\"mouseup\", mouseUp, true);\n\t\t\t\telement.addEventListener(\"touchstart\", function (ev) {\n\t\t\t\t\tif (_this.currTouch != null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tvar touches = ev.changedTouches;\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\t\tvar touch = touches[i];\n\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\tvar x = touch.clientX - rect.left;\n\t\t\t\t\t\tvar y = touch.clientY - rect.top;\n\t\t\t\t\t\t_this.currTouch = _this.touchesPool.obtain();\n\t\t\t\t\t\t_this.currTouch.identifier = touch.identifier;\n\t\t\t\t\t\t_this.currTouch.x = x;\n\t\t\t\t\t\t_this.currTouch.y = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\tfor (var i_17 = 0; i_17 < listeners.length; i_17++) {\n\t\t\t\t\t\tif (listeners[i_17].down)\n\t\t\t\t\t\t\tlisteners[i_17].down(_this.currTouch.x, _this.currTouch.y);\n\t\t\t\t\t}\n\t\t\t\t\t_this.lastX = _this.currTouch.x;\n\t\t\t\t\t_this.lastY = _this.currTouch.y;\n\t\t\t\t\t_this.buttonDown = true;\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}, false);\n\t\t\t\telement.addEventListener(\"touchend\", function (ev) {\n\t\t\t\t\tvar touches = ev.changedTouches;\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\t\tvar touch = touches[i];\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\t\tvar x = _this.currTouch.x = touch.clientX - rect.left;\n\t\t\t\t\t\t\tvar y = _this.currTouch.y = touch.clientY - rect.top;\n\t\t\t\t\t\t\t_this.touchesPool.free(_this.currTouch);\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\t\tfor (var i_18 = 0; i_18 < listeners.length; i_18++) {\n\t\t\t\t\t\t\t\tif (listeners[i_18].up)\n\t\t\t\t\t\t\t\t\tlisteners[i_18].up(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_this.lastX = x;\n\t\t\t\t\t\t\t_this.lastY = y;\n\t\t\t\t\t\t\t_this.buttonDown = false;\n\t\t\t\t\t\t\t_this.currTouch = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}, false);\n\t\t\t\telement.addEventListener(\"touchcancel\", function (ev) {\n\t\t\t\t\tvar touches = ev.changedTouches;\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\t\tvar touch = touches[i];\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\t\tvar x = _this.currTouch.x = touch.clientX - rect.left;\n\t\t\t\t\t\t\tvar y = _this.currTouch.y = touch.clientY - rect.top;\n\t\t\t\t\t\t\t_this.touchesPool.free(_this.currTouch);\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\t\tfor (var i_19 = 0; i_19 < listeners.length; i_19++) {\n\t\t\t\t\t\t\t\tif (listeners[i_19].up)\n\t\t\t\t\t\t\t\t\tlisteners[i_19].up(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_this.lastX = x;\n\t\t\t\t\t\t\t_this.lastY = y;\n\t\t\t\t\t\t\t_this.buttonDown = false;\n\t\t\t\t\t\t\t_this.currTouch = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}, false);\n\t\t\t\telement.addEventListener(\"touchmove\", function (ev) {\n\t\t\t\t\tif (_this.currTouch == null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tvar touches = ev.changedTouches;\n\t\t\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\t\t\tvar touch = touches[i];\n\t\t\t\t\t\tif (_this.currTouch.identifier === touch.identifier) {\n\t\t\t\t\t\t\tvar rect = element.getBoundingClientRect();\n\t\t\t\t\t\t\tvar x = touch.clientX - rect.left;\n\t\t\t\t\t\t\tvar y = touch.clientY - rect.top;\n\t\t\t\t\t\t\tvar listeners = _this.listeners;\n\t\t\t\t\t\t\tfor (var i_20 = 0; i_20 < listeners.length; i_20++) {\n\t\t\t\t\t\t\t\tif (listeners[i_20].dragged)\n\t\t\t\t\t\t\t\t\tlisteners[i_20].dragged(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_this.lastX = _this.currTouch.x = x;\n\t\t\t\t\t\t\t_this.lastY = _this.currTouch.y = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t}, false);\n\t\t\t};\n\t\t\tInput.prototype.addListener = function (listener) {\n\t\t\t\tthis.listeners.push(listener);\n\t\t\t};\n\t\t\tInput.prototype.removeListener = function (listener) {\n\t\t\t\tvar idx = this.listeners.indexOf(listener);\n\t\t\t\tif (idx > -1) {\n\t\t\t\t\tthis.listeners.splice(idx, 1);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn Input;\n\t\t}());\n\t\twebgl.Input = Input;\n\t\tvar Touch = (function () {\n\t\t\tfunction Touch(identifier, x, y) {\n\t\t\t\tthis.identifier = identifier;\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t}\n\t\t\treturn Touch;\n\t\t}());\n\t\twebgl.Touch = Touch;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar LoadingScreen = (function () {\n\t\t\tfunction LoadingScreen(renderer) {\n\t\t\t\tthis.logo = null;\n\t\t\t\tthis.spinner = null;\n\t\t\t\tthis.angle = 0;\n\t\t\t\tthis.fadeOut = 0;\n\t\t\t\tthis.timeKeeper = new spine.TimeKeeper();\n\t\t\t\tthis.backgroundColor = new spine.Color(0.135, 0.135, 0.135, 1);\n\t\t\t\tthis.tempColor = new spine.Color();\n\t\t\t\tthis.firstDraw = 0;\n\t\t\t\tthis.renderer = renderer;\n\t\t\t\tthis.timeKeeper.maxDelta = 9;\n\t\t\t\tif (LoadingScreen.logoImg === null) {\n\t\t\t\t\tvar isSafari = navigator.userAgent.indexOf(\"Safari\") > -1;\n\t\t\t\t\tLoadingScreen.logoImg = new Image();\n\t\t\t\t\tLoadingScreen.logoImg.src = LoadingScreen.SPINE_LOGO_DATA;\n\t\t\t\t\tif (!isSafari)\n\t\t\t\t\t\tLoadingScreen.logoImg.crossOrigin = \"anonymous\";\n\t\t\t\t\tLoadingScreen.logoImg.onload = function (ev) {\n\t\t\t\t\t\tLoadingScreen.loaded++;\n\t\t\t\t\t};\n\t\t\t\t\tLoadingScreen.spinnerImg = new Image();\n\t\t\t\t\tLoadingScreen.spinnerImg.src = LoadingScreen.SPINNER_DATA;\n\t\t\t\t\tif (!isSafari)\n\t\t\t\t\t\tLoadingScreen.spinnerImg.crossOrigin = \"anonymous\";\n\t\t\t\t\tLoadingScreen.spinnerImg.onload = function (ev) {\n\t\t\t\t\t\tLoadingScreen.loaded++;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tLoadingScreen.prototype.draw = function (complete) {\n\t\t\t\tif (complete === void 0) { complete = false; }\n\t\t\t\tif (complete && this.fadeOut > LoadingScreen.FADE_SECONDS)\n\t\t\t\t\treturn;\n\t\t\t\tthis.timeKeeper.update();\n\t\t\t\tvar a = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.75));\n\t\t\t\tthis.angle -= this.timeKeeper.delta / 1.4 * 360 * (1 + 1.5 * Math.pow(a, 5));\n\t\t\t\tvar renderer = this.renderer;\n\t\t\t\tvar canvas = renderer.canvas;\n\t\t\t\tvar gl = renderer.context.gl;\n\t\t\t\trenderer.resize(webgl.ResizeMode.Stretch);\n\t\t\t\tvar oldX = renderer.camera.position.x, oldY = renderer.camera.position.y;\n\t\t\t\trenderer.camera.position.set(canvas.width / 2, canvas.height / 2, 0);\n\t\t\t\trenderer.camera.viewportWidth = canvas.width;\n\t\t\t\trenderer.camera.viewportHeight = canvas.height;\n\t\t\t\tif (!complete) {\n\t\t\t\t\tgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);\n\t\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t\t\t\tthis.tempColor.a = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1);\n\t\t\t\t\tif (this.fadeOut > LoadingScreen.FADE_SECONDS) {\n\t\t\t\t\t\trenderer.camera.position.set(oldX, oldY, 0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ta = 1 - this.fadeOut / LoadingScreen.FADE_SECONDS;\n\t\t\t\t\tthis.tempColor.setFromColor(this.backgroundColor);\n\t\t\t\t\tthis.tempColor.a = 1 - (a - 1) * (a - 1);\n\t\t\t\t\trenderer.begin();\n\t\t\t\t\trenderer.quad(true, 0, 0, canvas.width, 0, canvas.width, canvas.height, 0, canvas.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor);\n\t\t\t\t\trenderer.end();\n\t\t\t\t}\n\t\t\t\tthis.tempColor.set(1, 1, 1, this.tempColor.a);\n\t\t\t\tif (LoadingScreen.loaded != 2)\n\t\t\t\t\treturn;\n\t\t\t\tif (this.logo === null) {\n\t\t\t\t\tthis.logo = new webgl.GLTexture(renderer.context, LoadingScreen.logoImg);\n\t\t\t\t\tthis.spinner = new webgl.GLTexture(renderer.context, LoadingScreen.spinnerImg);\n\t\t\t\t}\n\t\t\t\tthis.logo.update(false);\n\t\t\t\tthis.spinner.update(false);\n\t\t\t\tvar logoWidth = this.logo.getImage().width;\n\t\t\t\tvar logoHeight = this.logo.getImage().height;\n\t\t\t\tvar spinnerWidth = this.spinner.getImage().width;\n\t\t\t\tvar spinnerHeight = this.spinner.getImage().height;\n\t\t\t\trenderer.batcher.setBlendMode(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\trenderer.begin();\n\t\t\t\trenderer.drawTexture(this.logo, (canvas.width - logoWidth) / 2, (canvas.height - logoHeight) / 2, logoWidth, logoHeight, this.tempColor);\n\t\t\t\trenderer.drawTextureRotated(this.spinner, (canvas.width - spinnerWidth) / 2, (canvas.height - spinnerHeight) / 2, spinnerWidth, spinnerHeight, spinnerWidth / 2, spinnerHeight / 2, this.angle, this.tempColor);\n\t\t\t\trenderer.end();\n\t\t\t\trenderer.camera.position.set(oldX, oldY, 0);\n\t\t\t};\n\t\t\tLoadingScreen.FADE_SECONDS = 1;\n\t\t\tLoadingScreen.loaded = 0;\n\t\t\tLoadingScreen.spinnerImg = null;\n\t\t\tLoadingScreen.logoImg = null;\n\t\t\tLoadingScreen.SPINNER_DATA = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKMAAACjCAYAAADmbK6AAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmZDhlNTljMC02NGJjLTIxNGQtODAyZi1jZDlhODJjM2ZjMGMiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpmYmNmZWJlYS03MjY2LWE0NGQtOTI4NS0wOTJmNGNhYzk4ZWEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ3YzYzYzIwLWJkYjgtYzM0YS1hYzMyLWQ5MDdjOWEyOTA0MCIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmQ4ZTU5YzAtNjRiYy0yMTRkLTgwMmYtY2Q5YTgyYzNmYzBjIiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0N2M2M2MyMC1iZGI4LWMzNGEtYWMzMi1kOTA3YzlhMjkwNDAiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFu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\";\n\t\t\tLoadingScreen.SPINE_LOGO_DATA = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAABsCAYAAAALzHKmAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMTdhZGQ3Ni04OTZlLThlNGUtYmM5MS00ZjEyNjI1YjA3MjgiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplMTViNGE2ZS1hMDg3LWEzNDktODdhOS1mNDYzYjE2MzQ0Y2MiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjJlNjJiMWM2LWIxYzQtNDk0MC04MDMxLWU4ZDkyNTBmODJjNSIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDE3YWRkNzYtODk2ZS04ZTRlLWJjOTEtNGYxMjYyNWIwNzI4IiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyZTYyYjFjNi1iMWM0LTQ5NDAtODAzMS1lOGQ5MjUwZjgyYzUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFu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\";\n\t\t\treturn LoadingScreen;\n\t\t}());\n\t\twebgl.LoadingScreen = LoadingScreen;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\twebgl.M00 = 0;\n\t\twebgl.M01 = 4;\n\t\twebgl.M02 = 8;\n\t\twebgl.M03 = 12;\n\t\twebgl.M10 = 1;\n\t\twebgl.M11 = 5;\n\t\twebgl.M12 = 9;\n\t\twebgl.M13 = 13;\n\t\twebgl.M20 = 2;\n\t\twebgl.M21 = 6;\n\t\twebgl.M22 = 10;\n\t\twebgl.M23 = 14;\n\t\twebgl.M30 = 3;\n\t\twebgl.M31 = 7;\n\t\twebgl.M32 = 11;\n\t\twebgl.M33 = 15;\n\t\tvar Matrix4 = (function () {\n\t\t\tfunction Matrix4() {\n\t\t\t\tthis.temp = new Float32Array(16);\n\t\t\t\tthis.values = new Float32Array(16);\n\t\t\t\tvar v = this.values;\n\t\t\t\tv[webgl.M00] = 1;\n\t\t\t\tv[webgl.M11] = 1;\n\t\t\t\tv[webgl.M22] = 1;\n\t\t\t\tv[webgl.M33] = 1;\n\t\t\t}\n\t\t\tMatrix4.prototype.set = function (values) {\n\t\t\t\tthis.values.set(values);\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.transpose = function () {\n\t\t\t\tvar t = this.temp;\n\t\t\t\tvar v = this.values;\n\t\t\t\tt[webgl.M00] = v[webgl.M00];\n\t\t\t\tt[webgl.M01] = v[webgl.M10];\n\t\t\t\tt[webgl.M02] = v[webgl.M20];\n\t\t\t\tt[webgl.M03] = v[webgl.M30];\n\t\t\t\tt[webgl.M10] = v[webgl.M01];\n\t\t\t\tt[webgl.M11] = v[webgl.M11];\n\t\t\t\tt[webgl.M12] = v[webgl.M21];\n\t\t\t\tt[webgl.M13] = v[webgl.M31];\n\t\t\t\tt[webgl.M20] = v[webgl.M02];\n\t\t\t\tt[webgl.M21] = v[webgl.M12];\n\t\t\t\tt[webgl.M22] = v[webgl.M22];\n\t\t\t\tt[webgl.M23] = v[webgl.M32];\n\t\t\t\tt[webgl.M30] = v[webgl.M03];\n\t\t\t\tt[webgl.M31] = v[webgl.M13];\n\t\t\t\tt[webgl.M32] = v[webgl.M23];\n\t\t\t\tt[webgl.M33] = v[webgl.M33];\n\t\t\t\treturn this.set(t);\n\t\t\t};\n\t\t\tMatrix4.prototype.identity = function () {\n\t\t\t\tvar v = this.values;\n\t\t\t\tv[webgl.M00] = 1;\n\t\t\t\tv[webgl.M01] = 0;\n\t\t\t\tv[webgl.M02] = 0;\n\t\t\t\tv[webgl.M03] = 0;\n\t\t\t\tv[webgl.M10] = 0;\n\t\t\t\tv[webgl.M11] = 1;\n\t\t\t\tv[webgl.M12] = 0;\n\t\t\t\tv[webgl.M13] = 0;\n\t\t\t\tv[webgl.M20] = 0;\n\t\t\t\tv[webgl.M21] = 0;\n\t\t\t\tv[webgl.M22] = 1;\n\t\t\t\tv[webgl.M23] = 0;\n\t\t\t\tv[webgl.M30] = 0;\n\t\t\t\tv[webgl.M31] = 0;\n\t\t\t\tv[webgl.M32] = 0;\n\t\t\t\tv[webgl.M33] = 1;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.invert = function () {\n\t\t\t\tvar v = this.values;\n\t\t\t\tvar t = this.temp;\n\t\t\t\tvar l_det = v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\n\t\t\t\t\t- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\n\t\t\t\t\t+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\n\t\t\t\t\t- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n\t\t\t\tif (l_det == 0)\n\t\t\t\t\tthrow new Error(\"non-invertible matrix\");\n\t\t\t\tvar inv_det = 1.0 / l_det;\n\t\t\t\tt[webgl.M00] = v[webgl.M12] * v[webgl.M23] * v[webgl.M31] - v[webgl.M13] * v[webgl.M22] * v[webgl.M31] + v[webgl.M13] * v[webgl.M21] * v[webgl.M32]\n\t\t\t\t\t- v[webgl.M11] * v[webgl.M23] * v[webgl.M32] - v[webgl.M12] * v[webgl.M21] * v[webgl.M33] + v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n\t\t\t\tt[webgl.M01] = v[webgl.M03] * v[webgl.M22] * v[webgl.M31] - v[webgl.M02] * v[webgl.M23] * v[webgl.M31] - v[webgl.M03] * v[webgl.M21] * v[webgl.M32]\n\t\t\t\t\t+ v[webgl.M01] * v[webgl.M23] * v[webgl.M32] + v[webgl.M02] * v[webgl.M21] * v[webgl.M33] - v[webgl.M01] * v[webgl.M22] * v[webgl.M33];\n\t\t\t\tt[webgl.M02] = v[webgl.M02] * v[webgl.M13] * v[webgl.M31] - v[webgl.M03] * v[webgl.M12] * v[webgl.M31] + v[webgl.M03] * v[webgl.M11] * v[webgl.M32]\n\t\t\t\t\t- v[webgl.M01] * v[webgl.M13] * v[webgl.M32] - v[webgl.M02] * v[webgl.M11] * v[webgl.M33] + v[webgl.M01] * v[webgl.M12] * v[webgl.M33];\n\t\t\t\tt[webgl.M03] = v[webgl.M03] * v[webgl.M12] * v[webgl.M21] - v[webgl.M02] * v[webgl.M13] * v[webgl.M21] - v[webgl.M03] * v[webgl.M11] * v[webgl.M22]\n\t\t\t\t\t+ v[webgl.M01] * v[webgl.M13] * v[webgl.M22] + v[webgl.M02] * v[webgl.M11] * v[webgl.M23] - v[webgl.M01] * v[webgl.M12] * v[webgl.M23];\n\t\t\t\tt[webgl.M10] = v[webgl.M13] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M20] * v[webgl.M32]\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M23] * v[webgl.M32] + v[webgl.M12] * v[webgl.M20] * v[webgl.M33] - v[webgl.M10] * v[webgl.M22] * v[webgl.M33];\n\t\t\t\tt[webgl.M11] = v[webgl.M02] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M22] * v[webgl.M30] + v[webgl.M03] * v[webgl.M20] * v[webgl.M32]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M23] * v[webgl.M32] - v[webgl.M02] * v[webgl.M20] * v[webgl.M33] + v[webgl.M00] * v[webgl.M22] * v[webgl.M33];\n\t\t\t\tt[webgl.M12] = v[webgl.M03] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M10] * v[webgl.M32]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M13] * v[webgl.M32] + v[webgl.M02] * v[webgl.M10] * v[webgl.M33] - v[webgl.M00] * v[webgl.M12] * v[webgl.M33];\n\t\t\t\tt[webgl.M13] = v[webgl.M02] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M12] * v[webgl.M20] + v[webgl.M03] * v[webgl.M10] * v[webgl.M22]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M13] * v[webgl.M22] - v[webgl.M02] * v[webgl.M10] * v[webgl.M23] + v[webgl.M00] * v[webgl.M12] * v[webgl.M23];\n\t\t\t\tt[webgl.M20] = v[webgl.M11] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M21] * v[webgl.M30] + v[webgl.M13] * v[webgl.M20] * v[webgl.M31]\n\t\t\t\t\t- v[webgl.M10] * v[webgl.M23] * v[webgl.M31] - v[webgl.M11] * v[webgl.M20] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M33];\n\t\t\t\tt[webgl.M21] = v[webgl.M03] * v[webgl.M21] * v[webgl.M30] - v[webgl.M01] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M20] * v[webgl.M31]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M23] * v[webgl.M31] + v[webgl.M01] * v[webgl.M20] * v[webgl.M33] - v[webgl.M00] * v[webgl.M21] * v[webgl.M33];\n\t\t\t\tt[webgl.M22] = v[webgl.M01] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M11] * v[webgl.M30] + v[webgl.M03] * v[webgl.M10] * v[webgl.M31]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M13] * v[webgl.M31] - v[webgl.M01] * v[webgl.M10] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M33];\n\t\t\t\tt[webgl.M23] = v[webgl.M03] * v[webgl.M11] * v[webgl.M20] - v[webgl.M01] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M10] * v[webgl.M21]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M13] * v[webgl.M21] + v[webgl.M01] * v[webgl.M10] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M23];\n\t\t\t\tt[webgl.M30] = v[webgl.M12] * v[webgl.M21] * v[webgl.M30] - v[webgl.M11] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M20] * v[webgl.M31]\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M22] * v[webgl.M31] + v[webgl.M11] * v[webgl.M20] * v[webgl.M32] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32];\n\t\t\t\tt[webgl.M31] = v[webgl.M01] * v[webgl.M22] * v[webgl.M30] - v[webgl.M02] * v[webgl.M21] * v[webgl.M30] + v[webgl.M02] * v[webgl.M20] * v[webgl.M31]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M22] * v[webgl.M31] - v[webgl.M01] * v[webgl.M20] * v[webgl.M32] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32];\n\t\t\t\tt[webgl.M32] = v[webgl.M02] * v[webgl.M11] * v[webgl.M30] - v[webgl.M01] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M10] * v[webgl.M31]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M12] * v[webgl.M31] + v[webgl.M01] * v[webgl.M10] * v[webgl.M32] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32];\n\t\t\t\tt[webgl.M33] = v[webgl.M01] * v[webgl.M12] * v[webgl.M20] - v[webgl.M02] * v[webgl.M11] * v[webgl.M20] + v[webgl.M02] * v[webgl.M10] * v[webgl.M21]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M12] * v[webgl.M21] - v[webgl.M01] * v[webgl.M10] * v[webgl.M22] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22];\n\t\t\t\tv[webgl.M00] = t[webgl.M00] * inv_det;\n\t\t\t\tv[webgl.M01] = t[webgl.M01] * inv_det;\n\t\t\t\tv[webgl.M02] = t[webgl.M02] * inv_det;\n\t\t\t\tv[webgl.M03] = t[webgl.M03] * inv_det;\n\t\t\t\tv[webgl.M10] = t[webgl.M10] * inv_det;\n\t\t\t\tv[webgl.M11] = t[webgl.M11] * inv_det;\n\t\t\t\tv[webgl.M12] = t[webgl.M12] * inv_det;\n\t\t\t\tv[webgl.M13] = t[webgl.M13] * inv_det;\n\t\t\t\tv[webgl.M20] = t[webgl.M20] * inv_det;\n\t\t\t\tv[webgl.M21] = t[webgl.M21] * inv_det;\n\t\t\t\tv[webgl.M22] = t[webgl.M22] * inv_det;\n\t\t\t\tv[webgl.M23] = t[webgl.M23] * inv_det;\n\t\t\t\tv[webgl.M30] = t[webgl.M30] * inv_det;\n\t\t\t\tv[webgl.M31] = t[webgl.M31] * inv_det;\n\t\t\t\tv[webgl.M32] = t[webgl.M32] * inv_det;\n\t\t\t\tv[webgl.M33] = t[webgl.M33] * inv_det;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.determinant = function () {\n\t\t\t\tvar v = this.values;\n\t\t\t\treturn v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\n\t\t\t\t\t+ v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\n\t\t\t\t\t- v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\n\t\t\t\t\t+ v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\n\t\t\t\t\t+ v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\n\t\t\t\t\t- v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\n\t\t\t\t\t- v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n\t\t\t};\n\t\t\tMatrix4.prototype.translate = function (x, y, z) {\n\t\t\t\tvar v = this.values;\n\t\t\t\tv[webgl.M03] += x;\n\t\t\t\tv[webgl.M13] += y;\n\t\t\t\tv[webgl.M23] += z;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.copy = function () {\n\t\t\t\treturn new Matrix4().set(this.values);\n\t\t\t};\n\t\t\tMatrix4.prototype.projection = function (near, far, fovy, aspectRatio) {\n\t\t\t\tthis.identity();\n\t\t\t\tvar l_fd = (1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));\n\t\t\t\tvar l_a1 = (far + near) / (near - far);\n\t\t\t\tvar l_a2 = (2 * far * near) / (near - far);\n\t\t\t\tvar v = this.values;\n\t\t\t\tv[webgl.M00] = l_fd / aspectRatio;\n\t\t\t\tv[webgl.M10] = 0;\n\t\t\t\tv[webgl.M20] = 0;\n\t\t\t\tv[webgl.M30] = 0;\n\t\t\t\tv[webgl.M01] = 0;\n\t\t\t\tv[webgl.M11] = l_fd;\n\t\t\t\tv[webgl.M21] = 0;\n\t\t\t\tv[webgl.M31] = 0;\n\t\t\t\tv[webgl.M02] = 0;\n\t\t\t\tv[webgl.M12] = 0;\n\t\t\t\tv[webgl.M22] = l_a1;\n\t\t\t\tv[webgl.M32] = -1;\n\t\t\t\tv[webgl.M03] = 0;\n\t\t\t\tv[webgl.M13] = 0;\n\t\t\t\tv[webgl.M23] = l_a2;\n\t\t\t\tv[webgl.M33] = 0;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.ortho2d = function (x, y, width, height) {\n\t\t\t\treturn this.ortho(x, x + width, y, y + height, 0, 1);\n\t\t\t};\n\t\t\tMatrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\n\t\t\t\tthis.identity();\n\t\t\t\tvar x_orth = 2 / (right - left);\n\t\t\t\tvar y_orth = 2 / (top - bottom);\n\t\t\t\tvar z_orth = -2 / (far - near);\n\t\t\t\tvar tx = -(right + left) / (right - left);\n\t\t\t\tvar ty = -(top + bottom) / (top - bottom);\n\t\t\t\tvar tz = -(far + near) / (far - near);\n\t\t\t\tvar v = this.values;\n\t\t\t\tv[webgl.M00] = x_orth;\n\t\t\t\tv[webgl.M10] = 0;\n\t\t\t\tv[webgl.M20] = 0;\n\t\t\t\tv[webgl.M30] = 0;\n\t\t\t\tv[webgl.M01] = 0;\n\t\t\t\tv[webgl.M11] = y_orth;\n\t\t\t\tv[webgl.M21] = 0;\n\t\t\t\tv[webgl.M31] = 0;\n\t\t\t\tv[webgl.M02] = 0;\n\t\t\t\tv[webgl.M12] = 0;\n\t\t\t\tv[webgl.M22] = z_orth;\n\t\t\t\tv[webgl.M32] = 0;\n\t\t\t\tv[webgl.M03] = tx;\n\t\t\t\tv[webgl.M13] = ty;\n\t\t\t\tv[webgl.M23] = tz;\n\t\t\t\tv[webgl.M33] = 1;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.prototype.multiply = function (matrix) {\n\t\t\t\tvar t = this.temp;\n\t\t\t\tvar v = this.values;\n\t\t\t\tvar m = matrix.values;\n\t\t\t\tt[webgl.M00] = v[webgl.M00] * m[webgl.M00] + v[webgl.M01] * m[webgl.M10] + v[webgl.M02] * m[webgl.M20] + v[webgl.M03] * m[webgl.M30];\n\t\t\t\tt[webgl.M01] = v[webgl.M00] * m[webgl.M01] + v[webgl.M01] * m[webgl.M11] + v[webgl.M02] * m[webgl.M21] + v[webgl.M03] * m[webgl.M31];\n\t\t\t\tt[webgl.M02] = v[webgl.M00] * m[webgl.M02] + v[webgl.M01] * m[webgl.M12] + v[webgl.M02] * m[webgl.M22] + v[webgl.M03] * m[webgl.M32];\n\t\t\t\tt[webgl.M03] = v[webgl.M00] * m[webgl.M03] + v[webgl.M01] * m[webgl.M13] + v[webgl.M02] * m[webgl.M23] + v[webgl.M03] * m[webgl.M33];\n\t\t\t\tt[webgl.M10] = v[webgl.M10] * m[webgl.M00] + v[webgl.M11] * m[webgl.M10] + v[webgl.M12] * m[webgl.M20] + v[webgl.M13] * m[webgl.M30];\n\t\t\t\tt[webgl.M11] = v[webgl.M10] * m[webgl.M01] + v[webgl.M11] * m[webgl.M11] + v[webgl.M12] * m[webgl.M21] + v[webgl.M13] * m[webgl.M31];\n\t\t\t\tt[webgl.M12] = v[webgl.M10] * m[webgl.M02] + v[webgl.M11] * m[webgl.M12] + v[webgl.M12] * m[webgl.M22] + v[webgl.M13] * m[webgl.M32];\n\t\t\t\tt[webgl.M13] = v[webgl.M10] * m[webgl.M03] + v[webgl.M11] * m[webgl.M13] + v[webgl.M12] * m[webgl.M23] + v[webgl.M13] * m[webgl.M33];\n\t\t\t\tt[webgl.M20] = v[webgl.M20] * m[webgl.M00] + v[webgl.M21] * m[webgl.M10] + v[webgl.M22] * m[webgl.M20] + v[webgl.M23] * m[webgl.M30];\n\t\t\t\tt[webgl.M21] = v[webgl.M20] * m[webgl.M01] + v[webgl.M21] * m[webgl.M11] + v[webgl.M22] * m[webgl.M21] + v[webgl.M23] * m[webgl.M31];\n\t\t\t\tt[webgl.M22] = v[webgl.M20] * m[webgl.M02] + v[webgl.M21] * m[webgl.M12] + v[webgl.M22] * m[webgl.M22] + v[webgl.M23] * m[webgl.M32];\n\t\t\t\tt[webgl.M23] = v[webgl.M20] * m[webgl.M03] + v[webgl.M21] * m[webgl.M13] + v[webgl.M22] * m[webgl.M23] + v[webgl.M23] * m[webgl.M33];\n\t\t\t\tt[webgl.M30] = v[webgl.M30] * m[webgl.M00] + v[webgl.M31] * m[webgl.M10] + v[webgl.M32] * m[webgl.M20] + v[webgl.M33] * m[webgl.M30];\n\t\t\t\tt[webgl.M31] = v[webgl.M30] * m[webgl.M01] + v[webgl.M31] * m[webgl.M11] + v[webgl.M32] * m[webgl.M21] + v[webgl.M33] * m[webgl.M31];\n\t\t\t\tt[webgl.M32] = v[webgl.M30] * m[webgl.M02] + v[webgl.M31] * m[webgl.M12] + v[webgl.M32] * m[webgl.M22] + v[webgl.M33] * m[webgl.M32];\n\t\t\t\tt[webgl.M33] = v[webgl.M30] * m[webgl.M03] + v[webgl.M31] * m[webgl.M13] + v[webgl.M32] * m[webgl.M23] + v[webgl.M33] * m[webgl.M33];\n\t\t\t\treturn this.set(this.temp);\n\t\t\t};\n\t\t\tMatrix4.prototype.multiplyLeft = function (matrix) {\n\t\t\t\tvar t = this.temp;\n\t\t\t\tvar v = this.values;\n\t\t\t\tvar m = matrix.values;\n\t\t\t\tt[webgl.M00] = m[webgl.M00] * v[webgl.M00] + m[webgl.M01] * v[webgl.M10] + m[webgl.M02] * v[webgl.M20] + m[webgl.M03] * v[webgl.M30];\n\t\t\t\tt[webgl.M01] = m[webgl.M00] * v[webgl.M01] + m[webgl.M01] * v[webgl.M11] + m[webgl.M02] * v[webgl.M21] + m[webgl.M03] * v[webgl.M31];\n\t\t\t\tt[webgl.M02] = m[webgl.M00] * v[webgl.M02] + m[webgl.M01] * v[webgl.M12] + m[webgl.M02] * v[webgl.M22] + m[webgl.M03] * v[webgl.M32];\n\t\t\t\tt[webgl.M03] = m[webgl.M00] * v[webgl.M03] + m[webgl.M01] * v[webgl.M13] + m[webgl.M02] * v[webgl.M23] + m[webgl.M03] * v[webgl.M33];\n\t\t\t\tt[webgl.M10] = m[webgl.M10] * v[webgl.M00] + m[webgl.M11] * v[webgl.M10] + m[webgl.M12] * v[webgl.M20] + m[webgl.M13] * v[webgl.M30];\n\t\t\t\tt[webgl.M11] = m[webgl.M10] * v[webgl.M01] + m[webgl.M11] * v[webgl.M11] + m[webgl.M12] * v[webgl.M21] + m[webgl.M13] * v[webgl.M31];\n\t\t\t\tt[webgl.M12] = m[webgl.M10] * v[webgl.M02] + m[webgl.M11] * v[webgl.M12] + m[webgl.M12] * v[webgl.M22] + m[webgl.M13] * v[webgl.M32];\n\t\t\t\tt[webgl.M13] = m[webgl.M10] * v[webgl.M03] + m[webgl.M11] * v[webgl.M13] + m[webgl.M12] * v[webgl.M23] + m[webgl.M13] * v[webgl.M33];\n\t\t\t\tt[webgl.M20] = m[webgl.M20] * v[webgl.M00] + m[webgl.M21] * v[webgl.M10] + m[webgl.M22] * v[webgl.M20] + m[webgl.M23] * v[webgl.M30];\n\t\t\t\tt[webgl.M21] = m[webgl.M20] * v[webgl.M01] + m[webgl.M21] * v[webgl.M11] + m[webgl.M22] * v[webgl.M21] + m[webgl.M23] * v[webgl.M31];\n\t\t\t\tt[webgl.M22] = m[webgl.M20] * v[webgl.M02] + m[webgl.M21] * v[webgl.M12] + m[webgl.M22] * v[webgl.M22] + m[webgl.M23] * v[webgl.M32];\n\t\t\t\tt[webgl.M23] = m[webgl.M20] * v[webgl.M03] + m[webgl.M21] * v[webgl.M13] + m[webgl.M22] * v[webgl.M23] + m[webgl.M23] * v[webgl.M33];\n\t\t\t\tt[webgl.M30] = m[webgl.M30] * v[webgl.M00] + m[webgl.M31] * v[webgl.M10] + m[webgl.M32] * v[webgl.M20] + m[webgl.M33] * v[webgl.M30];\n\t\t\t\tt[webgl.M31] = m[webgl.M30] * v[webgl.M01] + m[webgl.M31] * v[webgl.M11] + m[webgl.M32] * v[webgl.M21] + m[webgl.M33] * v[webgl.M31];\n\t\t\t\tt[webgl.M32] = m[webgl.M30] * v[webgl.M02] + m[webgl.M31] * v[webgl.M12] + m[webgl.M32] * v[webgl.M22] + m[webgl.M33] * v[webgl.M32];\n\t\t\t\tt[webgl.M33] = m[webgl.M30] * v[webgl.M03] + m[webgl.M31] * v[webgl.M13] + m[webgl.M32] * v[webgl.M23] + m[webgl.M33] * v[webgl.M33];\n\t\t\t\treturn this.set(this.temp);\n\t\t\t};\n\t\t\tMatrix4.prototype.lookAt = function (position, direction, up) {\n\t\t\t\tMatrix4.initTemps();\n\t\t\t\tvar xAxis = Matrix4.xAxis, yAxis = Matrix4.yAxis, zAxis = Matrix4.zAxis;\n\t\t\t\tzAxis.setFrom(direction).normalize();\n\t\t\t\txAxis.setFrom(direction).normalize();\n\t\t\t\txAxis.cross(up).normalize();\n\t\t\t\tyAxis.setFrom(xAxis).cross(zAxis).normalize();\n\t\t\t\tthis.identity();\n\t\t\t\tvar val = this.values;\n\t\t\t\tval[webgl.M00] = xAxis.x;\n\t\t\t\tval[webgl.M01] = xAxis.y;\n\t\t\t\tval[webgl.M02] = xAxis.z;\n\t\t\t\tval[webgl.M10] = yAxis.x;\n\t\t\t\tval[webgl.M11] = yAxis.y;\n\t\t\t\tval[webgl.M12] = yAxis.z;\n\t\t\t\tval[webgl.M20] = -zAxis.x;\n\t\t\t\tval[webgl.M21] = -zAxis.y;\n\t\t\t\tval[webgl.M22] = -zAxis.z;\n\t\t\t\tMatrix4.tmpMatrix.identity();\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M03] = -position.x;\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M13] = -position.y;\n\t\t\t\tMatrix4.tmpMatrix.values[webgl.M23] = -position.z;\n\t\t\t\tthis.multiply(Matrix4.tmpMatrix);\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tMatrix4.initTemps = function () {\n\t\t\t\tif (Matrix4.xAxis === null)\n\t\t\t\t\tMatrix4.xAxis = new webgl.Vector3();\n\t\t\t\tif (Matrix4.yAxis === null)\n\t\t\t\t\tMatrix4.yAxis = new webgl.Vector3();\n\t\t\t\tif (Matrix4.zAxis === null)\n\t\t\t\t\tMatrix4.zAxis = new webgl.Vector3();\n\t\t\t};\n\t\t\tMatrix4.xAxis = null;\n\t\t\tMatrix4.yAxis = null;\n\t\t\tMatrix4.zAxis = null;\n\t\t\tMatrix4.tmpMatrix = new Matrix4();\n\t\t\treturn Matrix4;\n\t\t}());\n\t\twebgl.Matrix4 = Matrix4;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar Mesh = (function () {\n\t\t\tfunction Mesh(context, attributes, maxVertices, maxIndices) {\n\t\t\t\tthis.attributes = attributes;\n\t\t\t\tthis.verticesLength = 0;\n\t\t\t\tthis.dirtyVertices = false;\n\t\t\t\tthis.indicesLength = 0;\n\t\t\t\tthis.dirtyIndices = false;\n\t\t\t\tthis.elementsPerVertex = 0;\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\tthis.elementsPerVertex = 0;\n\t\t\t\tfor (var i = 0; i < attributes.length; i++) {\n\t\t\t\t\tthis.elementsPerVertex += attributes[i].numElements;\n\t\t\t\t}\n\t\t\t\tthis.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\n\t\t\t\tthis.indices = new Uint16Array(maxIndices);\n\t\t\t\tthis.context.addRestorable(this);\n\t\t\t}\n\t\t\tMesh.prototype.getAttributes = function () { return this.attributes; };\n\t\t\tMesh.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex; };\n\t\t\tMesh.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex; };\n\t\t\tMesh.prototype.setVerticesLength = function (length) {\n\t\t\t\tthis.dirtyVertices = true;\n\t\t\t\tthis.verticesLength = length;\n\t\t\t};\n\t\t\tMesh.prototype.getVertices = function () { return this.vertices; };\n\t\t\tMesh.prototype.maxIndices = function () { return this.indices.length; };\n\t\t\tMesh.prototype.numIndices = function () { return this.indicesLength; };\n\t\t\tMesh.prototype.setIndicesLength = function (length) {\n\t\t\t\tthis.dirtyIndices = true;\n\t\t\t\tthis.indicesLength = length;\n\t\t\t};\n\t\t\tMesh.prototype.getIndices = function () { return this.indices; };\n\t\t\t;\n\t\t\tMesh.prototype.getVertexSizeInFloats = function () {\n\t\t\t\tvar size = 0;\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\n\t\t\t\t\tvar attribute = this.attributes[i];\n\t\t\t\t\tsize += attribute.numElements;\n\t\t\t\t}\n\t\t\t\treturn size;\n\t\t\t};\n\t\t\tMesh.prototype.setVertices = function (vertices) {\n\t\t\t\tthis.dirtyVertices = true;\n\t\t\t\tif (vertices.length > this.vertices.length)\n\t\t\t\t\tthrow Error(\"Mesh can't store more than \" + this.maxVertices() + \" vertices\");\n\t\t\t\tthis.vertices.set(vertices, 0);\n\t\t\t\tthis.verticesLength = vertices.length;\n\t\t\t};\n\t\t\tMesh.prototype.setIndices = function (indices) {\n\t\t\t\tthis.dirtyIndices = true;\n\t\t\t\tif (indices.length > this.indices.length)\n\t\t\t\t\tthrow Error(\"Mesh can't store more than \" + this.maxIndices() + \" indices\");\n\t\t\t\tthis.indices.set(indices, 0);\n\t\t\t\tthis.indicesLength = indices.length;\n\t\t\t};\n\t\t\tMesh.prototype.draw = function (shader, primitiveType) {\n\t\t\t\tthis.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\n\t\t\t};\n\t\t\tMesh.prototype.drawWithOffset = function (shader, primitiveType, offset, count) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (this.dirtyVertices || this.dirtyIndices)\n\t\t\t\t\tthis.update();\n\t\t\t\tthis.bind(shader);\n\t\t\t\tif (this.indicesLength > 0) {\n\t\t\t\t\tgl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgl.drawArrays(primitiveType, offset, count);\n\t\t\t\t}\n\t\t\t\tthis.unbind(shader);\n\t\t\t};\n\t\t\tMesh.prototype.bind = function (shader) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n\t\t\t\tvar offset = 0;\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\n\t\t\t\t\tvar attrib = this.attributes[i];\n\t\t\t\t\tvar location_1 = shader.getAttributeLocation(attrib.name);\n\t\t\t\t\tgl.enableVertexAttribArray(location_1);\n\t\t\t\t\tgl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\n\t\t\t\t\toffset += attrib.numElements;\n\t\t\t\t}\n\t\t\t\tif (this.indicesLength > 0)\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n\t\t\t};\n\t\t\tMesh.prototype.unbind = function (shader) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\n\t\t\t\t\tvar attrib = this.attributes[i];\n\t\t\t\t\tvar location_2 = shader.getAttributeLocation(attrib.name);\n\t\t\t\t\tgl.disableVertexAttribArray(location_2);\n\t\t\t\t}\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t\t\t\tif (this.indicesLength > 0)\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\t\t\t};\n\t\t\tMesh.prototype.update = function () {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (this.dirtyVertices) {\n\t\t\t\t\tif (!this.verticesBuffer) {\n\t\t\t\t\t\tthis.verticesBuffer = gl.createBuffer();\n\t\t\t\t\t}\n\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n\t\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\n\t\t\t\t\tthis.dirtyVertices = false;\n\t\t\t\t}\n\t\t\t\tif (this.dirtyIndices) {\n\t\t\t\t\tif (!this.indicesBuffer) {\n\t\t\t\t\t\tthis.indicesBuffer = gl.createBuffer();\n\t\t\t\t\t}\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n\t\t\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\n\t\t\t\t\tthis.dirtyIndices = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\tMesh.prototype.restore = function () {\n\t\t\t\tthis.verticesBuffer = null;\n\t\t\t\tthis.indicesBuffer = null;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t\tMesh.prototype.dispose = function () {\n\t\t\t\tthis.context.removeRestorable(this);\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tgl.deleteBuffer(this.verticesBuffer);\n\t\t\t\tgl.deleteBuffer(this.indicesBuffer);\n\t\t\t};\n\t\t\treturn Mesh;\n\t\t}());\n\t\twebgl.Mesh = Mesh;\n\t\tvar VertexAttribute = (function () {\n\t\t\tfunction VertexAttribute(name, type, numElements) {\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.type = type;\n\t\t\t\tthis.numElements = numElements;\n\t\t\t}\n\t\t\treturn VertexAttribute;\n\t\t}());\n\t\twebgl.VertexAttribute = VertexAttribute;\n\t\tvar Position2Attribute = (function (_super) {\n\t\t\t__extends(Position2Attribute, _super);\n\t\t\tfunction Position2Attribute() {\n\t\t\t\treturn _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 2) || this;\n\t\t\t}\n\t\t\treturn Position2Attribute;\n\t\t}(VertexAttribute));\n\t\twebgl.Position2Attribute = Position2Attribute;\n\t\tvar Position3Attribute = (function (_super) {\n\t\t\t__extends(Position3Attribute, _super);\n\t\t\tfunction Position3Attribute() {\n\t\t\t\treturn _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 3) || this;\n\t\t\t}\n\t\t\treturn Position3Attribute;\n\t\t}(VertexAttribute));\n\t\twebgl.Position3Attribute = Position3Attribute;\n\t\tvar TexCoordAttribute = (function (_super) {\n\t\t\t__extends(TexCoordAttribute, _super);\n\t\t\tfunction TexCoordAttribute(unit) {\n\t\t\t\tif (unit === void 0) { unit = 0; }\n\t\t\t\treturn _super.call(this, webgl.Shader.TEXCOORDS + (unit == 0 ? \"\" : unit), VertexAttributeType.Float, 2) || this;\n\t\t\t}\n\t\t\treturn TexCoordAttribute;\n\t\t}(VertexAttribute));\n\t\twebgl.TexCoordAttribute = TexCoordAttribute;\n\t\tvar ColorAttribute = (function (_super) {\n\t\t\t__extends(ColorAttribute, _super);\n\t\t\tfunction ColorAttribute() {\n\t\t\t\treturn _super.call(this, webgl.Shader.COLOR, VertexAttributeType.Float, 4) || this;\n\t\t\t}\n\t\t\treturn ColorAttribute;\n\t\t}(VertexAttribute));\n\t\twebgl.ColorAttribute = ColorAttribute;\n\t\tvar Color2Attribute = (function (_super) {\n\t\t\t__extends(Color2Attribute, _super);\n\t\t\tfunction Color2Attribute() {\n\t\t\t\treturn _super.call(this, webgl.Shader.COLOR2, VertexAttributeType.Float, 4) || this;\n\t\t\t}\n\t\t\treturn Color2Attribute;\n\t\t}(VertexAttribute));\n\t\twebgl.Color2Attribute = Color2Attribute;\n\t\tvar VertexAttributeType;\n\t\t(function (VertexAttributeType) {\n\t\t\tVertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\n\t\t})(VertexAttributeType = webgl.VertexAttributeType || (webgl.VertexAttributeType = {}));\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar PolygonBatcher = (function () {\n\t\t\tfunction PolygonBatcher(context, twoColorTint, maxVertices) {\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\n\t\t\t\tif (maxVertices === void 0) { maxVertices = 10920; }\n\t\t\t\tthis.isDrawing = false;\n\t\t\t\tthis.shader = null;\n\t\t\t\tthis.lastTexture = null;\n\t\t\t\tthis.verticesLength = 0;\n\t\t\t\tthis.indicesLength = 0;\n\t\t\t\tif (maxVertices > 10920)\n\t\t\t\t\tthrow new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\tvar attributes = twoColorTint ?\n\t\t\t\t\t[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute(), new webgl.Color2Attribute()] :\n\t\t\t\t\t[new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute()];\n\t\t\t\tthis.mesh = new webgl.Mesh(context, attributes, maxVertices, maxVertices * 3);\n\t\t\t\tthis.srcBlend = this.context.gl.SRC_ALPHA;\n\t\t\t\tthis.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t}\n\t\t\tPolygonBatcher.prototype.begin = function (shader) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (this.isDrawing)\n\t\t\t\t\tthrow new Error(\"PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()\");\n\t\t\t\tthis.drawCalls = 0;\n\t\t\t\tthis.shader = shader;\n\t\t\t\tthis.lastTexture = null;\n\t\t\t\tthis.isDrawing = true;\n\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\n\t\t\t};\n\t\t\tPolygonBatcher.prototype.setBlendMode = function (srcBlend, dstBlend) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.srcBlend = srcBlend;\n\t\t\t\tthis.dstBlend = dstBlend;\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\tthis.flush();\n\t\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\n\t\t\t\t}\n\t\t\t};\n\t\t\tPolygonBatcher.prototype.draw = function (texture, vertices, indices) {\n\t\t\t\tif (texture != this.lastTexture) {\n\t\t\t\t\tthis.flush();\n\t\t\t\t\tthis.lastTexture = texture;\n\t\t\t\t}\n\t\t\t\telse if (this.verticesLength + vertices.length > this.mesh.getVertices().length ||\n\t\t\t\t\tthis.indicesLength + indices.length > this.mesh.getIndices().length) {\n\t\t\t\t\tthis.flush();\n\t\t\t\t}\n\t\t\t\tvar indexStart = this.mesh.numVertices();\n\t\t\t\tthis.mesh.getVertices().set(vertices, this.verticesLength);\n\t\t\t\tthis.verticesLength += vertices.length;\n\t\t\t\tthis.mesh.setVerticesLength(this.verticesLength);\n\t\t\t\tvar indicesArray = this.mesh.getIndices();\n\t\t\t\tfor (var i = this.indicesLength, j = 0; j < indices.length; i++, j++)\n\t\t\t\t\tindicesArray[i] = indices[j] + indexStart;\n\t\t\t\tthis.indicesLength += indices.length;\n\t\t\t\tthis.mesh.setIndicesLength(this.indicesLength);\n\t\t\t};\n\t\t\tPolygonBatcher.prototype.flush = function () {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (this.verticesLength == 0)\n\t\t\t\t\treturn;\n\t\t\t\tthis.lastTexture.bind();\n\t\t\t\tthis.mesh.draw(this.shader, gl.TRIANGLES);\n\t\t\t\tthis.verticesLength = 0;\n\t\t\t\tthis.indicesLength = 0;\n\t\t\t\tthis.mesh.setVerticesLength(0);\n\t\t\t\tthis.mesh.setIndicesLength(0);\n\t\t\t\tthis.drawCalls++;\n\t\t\t};\n\t\t\tPolygonBatcher.prototype.end = function () {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (!this.isDrawing)\n\t\t\t\t\tthrow new Error(\"PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()\");\n\t\t\t\tif (this.verticesLength > 0 || this.indicesLength > 0)\n\t\t\t\t\tthis.flush();\n\t\t\t\tthis.shader = null;\n\t\t\t\tthis.lastTexture = null;\n\t\t\t\tthis.isDrawing = false;\n\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t};\n\t\t\tPolygonBatcher.prototype.getDrawCalls = function () { return this.drawCalls; };\n\t\t\tPolygonBatcher.prototype.dispose = function () {\n\t\t\t\tthis.mesh.dispose();\n\t\t\t};\n\t\t\treturn PolygonBatcher;\n\t\t}());\n\t\twebgl.PolygonBatcher = PolygonBatcher;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar SceneRenderer = (function () {\n\t\t\tfunction SceneRenderer(canvas, context, twoColorTint) {\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\n\t\t\t\tthis.twoColorTint = false;\n\t\t\t\tthis.activeRenderer = null;\n\t\t\t\tthis.QUAD = [\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 1, 1, 1, 0, 0,\n\t\t\t\t];\n\t\t\t\tthis.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n\t\t\t\tthis.WHITE = new spine.Color(1, 1, 1, 1);\n\t\t\t\tthis.canvas = canvas;\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\tthis.twoColorTint = twoColorTint;\n\t\t\t\tthis.camera = new webgl.OrthoCamera(canvas.width, canvas.height);\n\t\t\t\tthis.batcherShader = twoColorTint ? webgl.Shader.newTwoColoredTextured(this.context) : webgl.Shader.newColoredTextured(this.context);\n\t\t\t\tthis.batcher = new webgl.PolygonBatcher(this.context, twoColorTint);\n\t\t\t\tthis.shapesShader = webgl.Shader.newColored(this.context);\n\t\t\t\tthis.shapes = new webgl.ShapeRenderer(this.context);\n\t\t\t\tthis.skeletonRenderer = new webgl.SkeletonRenderer(this.context, twoColorTint);\n\t\t\t\tthis.skeletonDebugRenderer = new webgl.SkeletonDebugRenderer(this.context);\n\t\t\t}\n\t\t\tSceneRenderer.prototype.begin = function () {\n\t\t\t\tthis.camera.update();\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawSkeleton = function (skeleton, premultipliedAlpha, slotRangeStart, slotRangeEnd) {\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n\t\t\t\tif (slotRangeStart === void 0) { slotRangeStart = -1; }\n\t\t\t\tif (slotRangeEnd === void 0) { slotRangeEnd = -1; }\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t\tthis.skeletonRenderer.premultipliedAlpha = premultipliedAlpha;\n\t\t\t\tthis.skeletonRenderer.draw(this.batcher, skeleton, slotRangeStart, slotRangeEnd);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawSkeletonDebug = function (skeleton, premultipliedAlpha, ignoredBones) {\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n\t\t\t\tif (ignoredBones === void 0) { ignoredBones = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha;\n\t\t\t\tthis.skeletonDebugRenderer.draw(this.shapes, skeleton, ignoredBones);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawTexture = function (texture, x, y, width, height, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.WHITE;\n\t\t\t\tvar quad = this.QUAD;\n\t\t\t\tvar i = 0;\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawTextureUV = function (texture, x, y, width, height, u, v, u2, v2, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.WHITE;\n\t\t\t\tvar quad = this.QUAD;\n\t\t\t\tvar i = 0;\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = u;\n\t\t\t\tquad[i++] = v;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = u2;\n\t\t\t\tquad[i++] = v;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = u2;\n\t\t\t\tquad[i++] = v2;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = u;\n\t\t\t\tquad[i++] = v2;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawTextureRotated = function (texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.WHITE;\n\t\t\t\tvar quad = this.QUAD;\n\t\t\t\tvar worldOriginX = x + pivotX;\n\t\t\t\tvar worldOriginY = y + pivotY;\n\t\t\t\tvar fx = -pivotX;\n\t\t\t\tvar fy = -pivotY;\n\t\t\t\tvar fx2 = width - pivotX;\n\t\t\t\tvar fy2 = height - pivotY;\n\t\t\t\tvar p1x = fx;\n\t\t\t\tvar p1y = fy;\n\t\t\t\tvar p2x = fx;\n\t\t\t\tvar p2y = fy2;\n\t\t\t\tvar p3x = fx2;\n\t\t\t\tvar p3y = fy2;\n\t\t\t\tvar p4x = fx2;\n\t\t\t\tvar p4y = fy;\n\t\t\t\tvar x1 = 0;\n\t\t\t\tvar y1 = 0;\n\t\t\t\tvar x2 = 0;\n\t\t\t\tvar y2 = 0;\n\t\t\t\tvar x3 = 0;\n\t\t\t\tvar y3 = 0;\n\t\t\t\tvar x4 = 0;\n\t\t\t\tvar y4 = 0;\n\t\t\t\tif (angle != 0) {\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(angle);\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(angle);\n\t\t\t\t\tx1 = cos * p1x - sin * p1y;\n\t\t\t\t\ty1 = sin * p1x + cos * p1y;\n\t\t\t\t\tx4 = cos * p2x - sin * p2y;\n\t\t\t\t\ty4 = sin * p2x + cos * p2y;\n\t\t\t\t\tx3 = cos * p3x - sin * p3y;\n\t\t\t\t\ty3 = sin * p3x + cos * p3y;\n\t\t\t\t\tx2 = x3 + (x1 - x4);\n\t\t\t\t\ty2 = y3 + (y1 - y4);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx1 = p1x;\n\t\t\t\t\ty1 = p1y;\n\t\t\t\t\tx4 = p2x;\n\t\t\t\t\ty4 = p2y;\n\t\t\t\t\tx3 = p3x;\n\t\t\t\t\ty3 = p3y;\n\t\t\t\t\tx2 = p4x;\n\t\t\t\t\ty2 = p4y;\n\t\t\t\t}\n\t\t\t\tx1 += worldOriginX;\n\t\t\t\ty1 += worldOriginY;\n\t\t\t\tx2 += worldOriginX;\n\t\t\t\ty2 += worldOriginY;\n\t\t\t\tx3 += worldOriginX;\n\t\t\t\ty3 += worldOriginY;\n\t\t\t\tx4 += worldOriginX;\n\t\t\t\ty4 += worldOriginY;\n\t\t\t\tvar i = 0;\n\t\t\t\tquad[i++] = x1;\n\t\t\t\tquad[i++] = y1;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x2;\n\t\t\t\tquad[i++] = y2;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x3;\n\t\t\t\tquad[i++] = y3;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 1;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x4;\n\t\t\t\tquad[i++] = y4;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tquad[i++] = 0;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tthis.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.drawRegion = function (region, x, y, width, height, color, premultipliedAlpha) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n\t\t\t\tthis.enableRenderer(this.batcher);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.WHITE;\n\t\t\t\tvar quad = this.QUAD;\n\t\t\t\tvar i = 0;\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = region.u;\n\t\t\t\tquad[i++] = region.v2;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = region.u2;\n\t\t\t\tquad[i++] = region.v2;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x + width;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = region.u2;\n\t\t\t\tquad[i++] = region.v;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tquad[i++] = x;\n\t\t\t\tquad[i++] = y + height;\n\t\t\t\tquad[i++] = color.r;\n\t\t\t\tquad[i++] = color.g;\n\t\t\t\tquad[i++] = color.b;\n\t\t\t\tquad[i++] = color.a;\n\t\t\t\tquad[i++] = region.u;\n\t\t\t\tquad[i++] = region.v;\n\t\t\t\tif (this.twoColorTint) {\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t\tquad[i++] = 0;\n\t\t\t\t}\n\t\t\t\tthis.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.line = function (x, y, x2, y2, color, color2) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (color2 === void 0) { color2 = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.line(x, y, x2, y2, color);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (color2 === void 0) { color2 = null; }\n\t\t\t\tif (color3 === void 0) { color3 = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (color2 === void 0) { color2 = null; }\n\t\t\t\tif (color3 === void 0) { color3 = null; }\n\t\t\t\tif (color4 === void 0) { color4 = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.rect = function (filled, x, y, width, height, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.rect(filled, x, y, width, height, color);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.rectLine(filled, x1, y1, x2, y2, width, color);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.polygon(polygonVertices, offset, count, color);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (segments === void 0) { segments = 0; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.circle(filled, x, y, radius, color, segments);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.enableRenderer(this.shapes);\n\t\t\t\tthis.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);\n\t\t\t};\n\t\t\tSceneRenderer.prototype.end = function () {\n\t\t\t\tif (this.activeRenderer === this.batcher)\n\t\t\t\t\tthis.batcher.end();\n\t\t\t\telse if (this.activeRenderer === this.shapes)\n\t\t\t\t\tthis.shapes.end();\n\t\t\t\tthis.activeRenderer = null;\n\t\t\t};\n\t\t\tSceneRenderer.prototype.resize = function (resizeMode) {\n\t\t\t\tvar canvas = this.canvas;\n\t\t\t\tvar w = canvas.clientWidth;\n\t\t\t\tvar h = canvas.clientHeight;\n\t\t\t\tif (canvas.width != w || canvas.height != h) {\n\t\t\t\t\tcanvas.width = w;\n\t\t\t\t\tcanvas.height = h;\n\t\t\t\t}\n\t\t\t\tthis.context.gl.viewport(0, 0, canvas.width, canvas.height);\n\t\t\t\tif (resizeMode === ResizeMode.Stretch) {\n\t\t\t\t}\n\t\t\t\telse if (resizeMode === ResizeMode.Expand) {\n\t\t\t\t\tthis.camera.setViewport(w, h);\n\t\t\t\t}\n\t\t\t\telse if (resizeMode === ResizeMode.Fit) {\n\t\t\t\t\tvar sourceWidth = canvas.width, sourceHeight = canvas.height;\n\t\t\t\t\tvar targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight;\n\t\t\t\t\tvar targetRatio = targetHeight / targetWidth;\n\t\t\t\t\tvar sourceRatio = sourceHeight / sourceWidth;\n\t\t\t\t\tvar scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;\n\t\t\t\t\tthis.camera.viewportWidth = sourceWidth * scale;\n\t\t\t\t\tthis.camera.viewportHeight = sourceHeight * scale;\n\t\t\t\t}\n\t\t\t\tthis.camera.update();\n\t\t\t};\n\t\t\tSceneRenderer.prototype.enableRenderer = function (renderer) {\n\t\t\t\tif (this.activeRenderer === renderer)\n\t\t\t\t\treturn;\n\t\t\t\tthis.end();\n\t\t\t\tif (renderer instanceof webgl.PolygonBatcher) {\n\t\t\t\t\tthis.batcherShader.bind();\n\t\t\t\t\tthis.batcherShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\n\t\t\t\t\tthis.batcherShader.setUniformi(\"u_texture\", 0);\n\t\t\t\t\tthis.batcher.begin(this.batcherShader);\n\t\t\t\t\tthis.activeRenderer = this.batcher;\n\t\t\t\t}\n\t\t\t\telse if (renderer instanceof webgl.ShapeRenderer) {\n\t\t\t\t\tthis.shapesShader.bind();\n\t\t\t\t\tthis.shapesShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\n\t\t\t\t\tthis.shapes.begin(this.shapesShader);\n\t\t\t\t\tthis.activeRenderer = this.shapes;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.activeRenderer = this.skeletonDebugRenderer;\n\t\t\t\t}\n\t\t\t};\n\t\t\tSceneRenderer.prototype.dispose = function () {\n\t\t\t\tthis.batcher.dispose();\n\t\t\t\tthis.batcherShader.dispose();\n\t\t\t\tthis.shapes.dispose();\n\t\t\t\tthis.shapesShader.dispose();\n\t\t\t\tthis.skeletonDebugRenderer.dispose();\n\t\t\t};\n\t\t\treturn SceneRenderer;\n\t\t}());\n\t\twebgl.SceneRenderer = SceneRenderer;\n\t\tvar ResizeMode;\n\t\t(function (ResizeMode) {\n\t\t\tResizeMode[ResizeMode[\"Stretch\"] = 0] = \"Stretch\";\n\t\t\tResizeMode[ResizeMode[\"Expand\"] = 1] = \"Expand\";\n\t\t\tResizeMode[ResizeMode[\"Fit\"] = 2] = \"Fit\";\n\t\t})(ResizeMode = webgl.ResizeMode || (webgl.ResizeMode = {}));\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar Shader = (function () {\n\t\t\tfunction Shader(context, vertexShader, fragmentShader) {\n\t\t\t\tthis.vertexShader = vertexShader;\n\t\t\t\tthis.fragmentShader = fragmentShader;\n\t\t\t\tthis.vs = null;\n\t\t\t\tthis.fs = null;\n\t\t\t\tthis.program = null;\n\t\t\t\tthis.tmp2x2 = new Float32Array(2 * 2);\n\t\t\t\tthis.tmp3x3 = new Float32Array(3 * 3);\n\t\t\t\tthis.tmp4x4 = new Float32Array(4 * 4);\n\t\t\t\tthis.vsSource = vertexShader;\n\t\t\t\tthis.fsSource = fragmentShader;\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\tthis.context.addRestorable(this);\n\t\t\t\tthis.compile();\n\t\t\t}\n\t\t\tShader.prototype.getProgram = function () { return this.program; };\n\t\t\tShader.prototype.getVertexShader = function () { return this.vertexShader; };\n\t\t\tShader.prototype.getFragmentShader = function () { return this.fragmentShader; };\n\t\t\tShader.prototype.getVertexShaderSource = function () { return this.vsSource; };\n\t\t\tShader.prototype.getFragmentSource = function () { return this.fsSource; };\n\t\t\tShader.prototype.compile = function () {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\ttry {\n\t\t\t\t\tthis.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\n\t\t\t\t\tthis.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\n\t\t\t\t\tthis.program = this.compileProgram(this.vs, this.fs);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tthis.dispose();\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t};\n\t\t\tShader.prototype.compileShader = function (type, source) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tvar shader = gl.createShader(type);\n\t\t\t\tgl.shaderSource(shader, source);\n\t\t\t\tgl.compileShader(shader);\n\t\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\t\t\t\tvar error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\n\t\t\t\t\tgl.deleteShader(shader);\n\t\t\t\t\tif (!gl.isContextLost())\n\t\t\t\t\t\tthrow new Error(error);\n\t\t\t\t}\n\t\t\t\treturn shader;\n\t\t\t};\n\t\t\tShader.prototype.compileProgram = function (vs, fs) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tvar program = gl.createProgram();\n\t\t\t\tgl.attachShader(program, vs);\n\t\t\t\tgl.attachShader(program, fs);\n\t\t\t\tgl.linkProgram(program);\n\t\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\t\t\tvar error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\n\t\t\t\t\tgl.deleteProgram(program);\n\t\t\t\t\tif (!gl.isContextLost())\n\t\t\t\t\t\tthrow new Error(error);\n\t\t\t\t}\n\t\t\t\treturn program;\n\t\t\t};\n\t\t\tShader.prototype.restore = function () {\n\t\t\t\tthis.compile();\n\t\t\t};\n\t\t\tShader.prototype.bind = function () {\n\t\t\t\tthis.context.gl.useProgram(this.program);\n\t\t\t};\n\t\t\tShader.prototype.unbind = function () {\n\t\t\t\tthis.context.gl.useProgram(null);\n\t\t\t};\n\t\t\tShader.prototype.setUniformi = function (uniform, value) {\n\t\t\t\tthis.context.gl.uniform1i(this.getUniformLocation(uniform), value);\n\t\t\t};\n\t\t\tShader.prototype.setUniformf = function (uniform, value) {\n\t\t\t\tthis.context.gl.uniform1f(this.getUniformLocation(uniform), value);\n\t\t\t};\n\t\t\tShader.prototype.setUniform2f = function (uniform, value, value2) {\n\t\t\t\tthis.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);\n\t\t\t};\n\t\t\tShader.prototype.setUniform3f = function (uniform, value, value2, value3) {\n\t\t\t\tthis.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\n\t\t\t};\n\t\t\tShader.prototype.setUniform4f = function (uniform, value, value2, value3, value4) {\n\t\t\t\tthis.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\n\t\t\t};\n\t\t\tShader.prototype.setUniform2x2f = function (uniform, value) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.tmp2x2.set(value);\n\t\t\t\tgl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\n\t\t\t};\n\t\t\tShader.prototype.setUniform3x3f = function (uniform, value) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.tmp3x3.set(value);\n\t\t\t\tgl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\n\t\t\t};\n\t\t\tShader.prototype.setUniform4x4f = function (uniform, value) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.tmp4x4.set(value);\n\t\t\t\tgl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\n\t\t\t};\n\t\t\tShader.prototype.getUniformLocation = function (uniform) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tvar location = gl.getUniformLocation(this.program, uniform);\n\t\t\t\tif (!location && !gl.isContextLost())\n\t\t\t\t\tthrow new Error(\"Couldn't find location for uniform \" + uniform);\n\t\t\t\treturn location;\n\t\t\t};\n\t\t\tShader.prototype.getAttributeLocation = function (attribute) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tvar location = gl.getAttribLocation(this.program, attribute);\n\t\t\t\tif (location == -1 && !gl.isContextLost())\n\t\t\t\t\tthrow new Error(\"Couldn't find location for attribute \" + attribute);\n\t\t\t\treturn location;\n\t\t\t};\n\t\t\tShader.prototype.dispose = function () {\n\t\t\t\tthis.context.removeRestorable(this);\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (this.vs) {\n\t\t\t\t\tgl.deleteShader(this.vs);\n\t\t\t\t\tthis.vs = null;\n\t\t\t\t}\n\t\t\t\tif (this.fs) {\n\t\t\t\t\tgl.deleteShader(this.fs);\n\t\t\t\t\tthis.fs = null;\n\t\t\t\t}\n\t\t\t\tif (this.program) {\n\t\t\t\t\tgl.deleteProgram(this.program);\n\t\t\t\t\tthis.program = null;\n\t\t\t\t}\n\t\t\t};\n\t\t\tShader.newColoredTextured = function (context) {\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\treturn new Shader(context, vs, fs);\n\t\t\t};\n\t\t\tShader.newTwoColoredTextured = function (context) {\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_light;\\n\\t\\t\\t\\tvarying vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_light = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_dark = \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_light;\\n\\t\\t\\t\\tvarying LOWP vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tvec4 texColor = texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t\\tgl_FragColor.a = texColor.a * v_light.a;\\n\\t\\t\\t\\t\\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\treturn new Shader(context, vs, fs);\n\t\t\t};\n\t\t\tShader.newColored = function (context) {\n\t\t\t\tvar vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\tvar fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n\t\t\t\treturn new Shader(context, vs, fs);\n\t\t\t};\n\t\t\tShader.MVP_MATRIX = \"u_projTrans\";\n\t\t\tShader.POSITION = \"a_position\";\n\t\t\tShader.COLOR = \"a_color\";\n\t\t\tShader.COLOR2 = \"a_color2\";\n\t\t\tShader.TEXCOORDS = \"a_texCoords\";\n\t\t\tShader.SAMPLER = \"u_texture\";\n\t\t\treturn Shader;\n\t\t}());\n\t\twebgl.Shader = Shader;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar ShapeRenderer = (function () {\n\t\t\tfunction ShapeRenderer(context, maxVertices) {\n\t\t\t\tif (maxVertices === void 0) { maxVertices = 10920; }\n\t\t\t\tthis.isDrawing = false;\n\t\t\t\tthis.shapeType = ShapeType.Filled;\n\t\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\n\t\t\t\tthis.vertexIndex = 0;\n\t\t\t\tthis.tmp = new spine.Vector2();\n\t\t\t\tif (maxVertices > 10920)\n\t\t\t\t\tthrow new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t\tthis.mesh = new webgl.Mesh(context, [new webgl.Position2Attribute(), new webgl.ColorAttribute()], maxVertices, 0);\n\t\t\t\tthis.srcBlend = this.context.gl.SRC_ALPHA;\n\t\t\t\tthis.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t}\n\t\t\tShapeRenderer.prototype.begin = function (shader) {\n\t\t\t\tif (this.isDrawing)\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has already been called\");\n\t\t\t\tthis.shader = shader;\n\t\t\t\tthis.vertexIndex = 0;\n\t\t\t\tthis.isDrawing = true;\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.setBlendMode = function (srcBlend, dstBlend) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tthis.srcBlend = srcBlend;\n\t\t\t\tthis.dstBlend = dstBlend;\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\tthis.flush();\n\t\t\t\t\tgl.blendFunc(this.srcBlend, this.dstBlend);\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.setColor = function (color) {\n\t\t\t\tthis.color.setFromColor(color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.setColorWith = function (r, g, b, a) {\n\t\t\t\tthis.color.set(r, g, b, a);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.point = function (x, y, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.check(ShapeType.Point, 1);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tthis.vertex(x, y, color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.line = function (x, y, x2, y2, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.check(ShapeType.Line, 2);\n\t\t\t\tvar vertices = this.mesh.getVertices();\n\t\t\t\tvar idx = this.vertexIndex;\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\tthis.vertex(x2, y2, color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (color2 === void 0) { color2 = null; }\n\t\t\t\tif (color3 === void 0) { color3 = null; }\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\n\t\t\t\tvar vertices = this.mesh.getVertices();\n\t\t\t\tvar idx = this.vertexIndex;\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tif (color2 === null)\n\t\t\t\t\tcolor2 = this.color;\n\t\t\t\tif (color3 === null)\n\t\t\t\t\tcolor3 = this.color;\n\t\t\t\tif (filled) {\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\tthis.vertex(x2, y2, color2);\n\t\t\t\t\tthis.vertex(x3, y3, color3);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\tthis.vertex(x2, y2, color2);\n\t\t\t\t\tthis.vertex(x2, y2, color);\n\t\t\t\t\tthis.vertex(x3, y3, color2);\n\t\t\t\t\tthis.vertex(x3, y3, color);\n\t\t\t\t\tthis.vertex(x, y, color2);\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (color2 === void 0) { color2 = null; }\n\t\t\t\tif (color3 === void 0) { color3 = null; }\n\t\t\t\tif (color4 === void 0) { color4 = null; }\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\n\t\t\t\tvar vertices = this.mesh.getVertices();\n\t\t\t\tvar idx = this.vertexIndex;\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tif (color2 === null)\n\t\t\t\t\tcolor2 = this.color;\n\t\t\t\tif (color3 === null)\n\t\t\t\t\tcolor3 = this.color;\n\t\t\t\tif (color4 === null)\n\t\t\t\t\tcolor4 = this.color;\n\t\t\t\tif (filled) {\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\tthis.vertex(x2, y2, color2);\n\t\t\t\t\tthis.vertex(x3, y3, color3);\n\t\t\t\t\tthis.vertex(x3, y3, color3);\n\t\t\t\t\tthis.vertex(x4, y4, color4);\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\tthis.vertex(x2, y2, color2);\n\t\t\t\t\tthis.vertex(x2, y2, color2);\n\t\t\t\t\tthis.vertex(x3, y3, color3);\n\t\t\t\t\tthis.vertex(x3, y3, color3);\n\t\t\t\t\tthis.vertex(x4, y4, color4);\n\t\t\t\t\tthis.vertex(x4, y4, color4);\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.rect = function (filled, x, y, width, height, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.check(filled ? ShapeType.Filled : ShapeType.Line, 8);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tvar t = this.tmp.set(y2 - y1, x1 - x2);\n\t\t\t\tt.normalize();\n\t\t\t\twidth *= 0.5;\n\t\t\t\tvar tx = t.x * width;\n\t\t\t\tvar ty = t.y * width;\n\t\t\t\tif (!filled) {\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.vertex(x1 + tx, y1 + ty, color);\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\n\t\t\t\t\tthis.vertex(x2 - tx, y2 - ty, color);\n\t\t\t\t\tthis.vertex(x2 + tx, y2 + ty, color);\n\t\t\t\t\tthis.vertex(x1 - tx, y1 - ty, color);\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.x = function (x, y, size) {\n\t\t\t\tthis.line(x - size, y - size, x + size, y + size);\n\t\t\t\tthis.line(x - size, y + size, x + size, y - size);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (count < 3)\n\t\t\t\t\tthrow new Error(\"Polygon must contain at least 3 vertices\");\n\t\t\t\tthis.check(ShapeType.Line, count * 2);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tvar vertices = this.mesh.getVertices();\n\t\t\t\tvar idx = this.vertexIndex;\n\t\t\t\toffset <<= 1;\n\t\t\t\tcount <<= 1;\n\t\t\t\tvar firstX = polygonVertices[offset];\n\t\t\t\tvar firstY = polygonVertices[offset + 1];\n\t\t\t\tvar last = offset + count;\n\t\t\t\tfor (var i = offset, n = offset + count - 2; i < n; i += 2) {\n\t\t\t\t\tvar x1 = polygonVertices[i];\n\t\t\t\t\tvar y1 = polygonVertices[i + 1];\n\t\t\t\t\tvar x2 = 0;\n\t\t\t\t\tvar y2 = 0;\n\t\t\t\t\tif (i + 2 >= last) {\n\t\t\t\t\t\tx2 = firstX;\n\t\t\t\t\t\ty2 = firstY;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx2 = polygonVertices[i + 2];\n\t\t\t\t\t\ty2 = polygonVertices[i + 3];\n\t\t\t\t\t}\n\t\t\t\t\tthis.vertex(x1, y1, color);\n\t\t\t\t\tthis.vertex(x2, y2, color);\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tif (segments === void 0) { segments = 0; }\n\t\t\t\tif (segments === 0)\n\t\t\t\t\tsegments = Math.max(1, (6 * spine.MathUtils.cbrt(radius)) | 0);\n\t\t\t\tif (segments <= 0)\n\t\t\t\t\tthrow new Error(\"segments must be > 0.\");\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tvar angle = 2 * spine.MathUtils.PI / segments;\n\t\t\t\tvar cos = Math.cos(angle);\n\t\t\t\tvar sin = Math.sin(angle);\n\t\t\t\tvar cx = radius, cy = 0;\n\t\t\t\tif (!filled) {\n\t\t\t\t\tthis.check(ShapeType.Line, segments * 2 + 2);\n\t\t\t\t\tfor (var i = 0; i < segments; i++) {\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t\t\tvar temp_1 = cx;\n\t\t\t\t\t\tcx = cos * cx - sin * cy;\n\t\t\t\t\t\tcy = sin * temp_1 + cos * cy;\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t\t}\n\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.check(ShapeType.Filled, segments * 3 + 3);\n\t\t\t\t\tsegments--;\n\t\t\t\t\tfor (var i = 0; i < segments; i++) {\n\t\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t\t\tvar temp_2 = cx;\n\t\t\t\t\t\tcx = cos * cx - sin * cy;\n\t\t\t\t\t\tcy = sin * temp_2 + cos * cy;\n\t\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t\t}\n\t\t\t\t\tthis.vertex(x, y, color);\n\t\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t\t}\n\t\t\t\tvar temp = cx;\n\t\t\t\tcx = radius;\n\t\t\t\tcy = 0;\n\t\t\t\tthis.vertex(x + cx, y + cy, color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\n\t\t\t\tif (color === void 0) { color = null; }\n\t\t\t\tthis.check(ShapeType.Line, segments * 2 + 2);\n\t\t\t\tif (color === null)\n\t\t\t\t\tcolor = this.color;\n\t\t\t\tvar subdiv_step = 1 / segments;\n\t\t\t\tvar subdiv_step2 = subdiv_step * subdiv_step;\n\t\t\t\tvar subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\n\t\t\t\tvar pre1 = 3 * subdiv_step;\n\t\t\t\tvar pre2 = 3 * subdiv_step2;\n\t\t\t\tvar pre4 = 6 * subdiv_step2;\n\t\t\t\tvar pre5 = 6 * subdiv_step3;\n\t\t\t\tvar tmp1x = x1 - cx1 * 2 + cx2;\n\t\t\t\tvar tmp1y = y1 - cy1 * 2 + cy2;\n\t\t\t\tvar tmp2x = (cx1 - cx2) * 3 - x1 + x2;\n\t\t\t\tvar tmp2y = (cy1 - cy2) * 3 - y1 + y2;\n\t\t\t\tvar fx = x1;\n\t\t\t\tvar fy = y1;\n\t\t\t\tvar dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\n\t\t\t\tvar dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\n\t\t\t\tvar ddfx = tmp1x * pre4 + tmp2x * pre5;\n\t\t\t\tvar ddfy = tmp1y * pre4 + tmp2y * pre5;\n\t\t\t\tvar dddfx = tmp2x * pre5;\n\t\t\t\tvar dddfy = tmp2y * pre5;\n\t\t\t\twhile (segments-- > 0) {\n\t\t\t\t\tthis.vertex(fx, fy, color);\n\t\t\t\t\tfx += dfx;\n\t\t\t\t\tfy += dfy;\n\t\t\t\t\tdfx += ddfx;\n\t\t\t\t\tdfy += ddfy;\n\t\t\t\t\tddfx += dddfx;\n\t\t\t\t\tddfy += dddfy;\n\t\t\t\t\tthis.vertex(fx, fy, color);\n\t\t\t\t}\n\t\t\t\tthis.vertex(fx, fy, color);\n\t\t\t\tthis.vertex(x2, y2, color);\n\t\t\t};\n\t\t\tShapeRenderer.prototype.vertex = function (x, y, color) {\n\t\t\t\tvar idx = this.vertexIndex;\n\t\t\t\tvar vertices = this.mesh.getVertices();\n\t\t\t\tvertices[idx++] = x;\n\t\t\t\tvertices[idx++] = y;\n\t\t\t\tvertices[idx++] = color.r;\n\t\t\t\tvertices[idx++] = color.g;\n\t\t\t\tvertices[idx++] = color.b;\n\t\t\t\tvertices[idx++] = color.a;\n\t\t\t\tthis.vertexIndex = idx;\n\t\t\t};\n\t\t\tShapeRenderer.prototype.end = function () {\n\t\t\t\tif (!this.isDrawing)\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has not been called\");\n\t\t\t\tthis.flush();\n\t\t\t\tthis.context.gl.disable(this.context.gl.BLEND);\n\t\t\t\tthis.isDrawing = false;\n\t\t\t};\n\t\t\tShapeRenderer.prototype.flush = function () {\n\t\t\t\tif (this.vertexIndex == 0)\n\t\t\t\t\treturn;\n\t\t\t\tthis.mesh.setVerticesLength(this.vertexIndex);\n\t\t\t\tthis.mesh.draw(this.shader, this.shapeType);\n\t\t\t\tthis.vertexIndex = 0;\n\t\t\t};\n\t\t\tShapeRenderer.prototype.check = function (shapeType, numVertices) {\n\t\t\t\tif (!this.isDrawing)\n\t\t\t\t\tthrow new Error(\"ShapeRenderer.begin() has not been called\");\n\t\t\t\tif (this.shapeType == shapeType) {\n\t\t\t\t\tif (this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)\n\t\t\t\t\t\tthis.flush();\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.flush();\n\t\t\t\t\tthis.shapeType = shapeType;\n\t\t\t\t}\n\t\t\t};\n\t\t\tShapeRenderer.prototype.dispose = function () {\n\t\t\t\tthis.mesh.dispose();\n\t\t\t};\n\t\t\treturn ShapeRenderer;\n\t\t}());\n\t\twebgl.ShapeRenderer = ShapeRenderer;\n\t\tvar ShapeType;\n\t\t(function (ShapeType) {\n\t\t\tShapeType[ShapeType[\"Point\"] = 0] = \"Point\";\n\t\t\tShapeType[ShapeType[\"Line\"] = 1] = \"Line\";\n\t\t\tShapeType[ShapeType[\"Filled\"] = 4] = \"Filled\";\n\t\t})(ShapeType = webgl.ShapeType || (webgl.ShapeType = {}));\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar SkeletonDebugRenderer = (function () {\n\t\t\tfunction SkeletonDebugRenderer(context) {\n\t\t\t\tthis.boneLineColor = new spine.Color(1, 0, 0, 1);\n\t\t\t\tthis.boneOriginColor = new spine.Color(0, 1, 0, 1);\n\t\t\t\tthis.attachmentLineColor = new spine.Color(0, 0, 1, 0.5);\n\t\t\t\tthis.triangleLineColor = new spine.Color(1, 0.64, 0, 0.5);\n\t\t\t\tthis.pathColor = new spine.Color().setFromString(\"FF7F00\");\n\t\t\t\tthis.clipColor = new spine.Color(0.8, 0, 0, 2);\n\t\t\t\tthis.aabbColor = new spine.Color(0, 1, 0, 0.5);\n\t\t\t\tthis.drawBones = true;\n\t\t\t\tthis.drawRegionAttachments = true;\n\t\t\t\tthis.drawBoundingBoxes = true;\n\t\t\t\tthis.drawMeshHull = true;\n\t\t\t\tthis.drawMeshTriangles = true;\n\t\t\t\tthis.drawPaths = true;\n\t\t\t\tthis.drawSkeletonXY = false;\n\t\t\t\tthis.drawClipping = true;\n\t\t\t\tthis.premultipliedAlpha = false;\n\t\t\t\tthis.scale = 1;\n\t\t\t\tthis.boneWidth = 2;\n\t\t\t\tthis.bounds = new spine.SkeletonBounds();\n\t\t\t\tthis.temp = new Array();\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(2 * 1024);\n\t\t\t\tthis.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n\t\t\t}\n\t\t\tSkeletonDebugRenderer.prototype.draw = function (shapes, skeleton, ignoredBones) {\n\t\t\t\tif (ignoredBones === void 0) { ignoredBones = null; }\n\t\t\t\tvar skeletonX = skeleton.x;\n\t\t\t\tvar skeletonY = skeleton.y;\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tvar srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;\n\t\t\t\tshapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\tvar bones = skeleton.bones;\n\t\t\t\tif (this.drawBones) {\n\t\t\t\t\tshapes.setColor(this.boneLineColor);\n\t\t\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\t\t\tvar bone = bones[i];\n\t\t\t\t\t\tif (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (bone.parent == null)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar x = skeletonX + bone.data.length * bone.a + bone.worldX;\n\t\t\t\t\t\tvar y = skeletonY + bone.data.length * bone.c + bone.worldY;\n\t\t\t\t\t\tshapes.rectLine(true, skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, this.boneWidth * this.scale);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.drawSkeletonXY)\n\t\t\t\t\t\tshapes.x(skeletonX, skeletonY, 4 * this.scale);\n\t\t\t\t}\n\t\t\t\tif (this.drawRegionAttachments) {\n\t\t\t\t\tshapes.setColor(this.attachmentLineColor);\n\t\t\t\t\tvar slots = skeleton.slots;\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\t\tvar slot = slots[i];\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\n\t\t\t\t\t\t\tvar regionAttachment = attachment;\n\t\t\t\t\t\t\tvar vertices = this.vertices;\n\t\t\t\t\t\t\tregionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n\t\t\t\t\t\t\tshapes.line(vertices[0], vertices[1], vertices[2], vertices[3]);\n\t\t\t\t\t\t\tshapes.line(vertices[2], vertices[3], vertices[4], vertices[5]);\n\t\t\t\t\t\t\tshapes.line(vertices[4], vertices[5], vertices[6], vertices[7]);\n\t\t\t\t\t\t\tshapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.drawMeshHull || this.drawMeshTriangles) {\n\t\t\t\t\tvar slots = skeleton.slots;\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\t\tvar slot = slots[i];\n\t\t\t\t\t\tif (!slot.bone.active)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\t\t\tif (!(attachment instanceof spine.MeshAttachment))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar mesh = attachment;\n\t\t\t\t\t\tvar vertices = this.vertices;\n\t\t\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);\n\t\t\t\t\t\tvar triangles = mesh.triangles;\n\t\t\t\t\t\tvar hullLength = mesh.hullLength;\n\t\t\t\t\t\tif (this.drawMeshTriangles) {\n\t\t\t\t\t\t\tshapes.setColor(this.triangleLineColor);\n\t\t\t\t\t\t\tfor (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {\n\t\t\t\t\t\t\t\tvar v1 = triangles[ii] * 2, v2 = triangles[ii + 1] * 2, v3 = triangles[ii + 2] * 2;\n\t\t\t\t\t\t\t\tshapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.drawMeshHull && hullLength > 0) {\n\t\t\t\t\t\t\tshapes.setColor(this.attachmentLineColor);\n\t\t\t\t\t\t\thullLength = (hullLength >> 1) * 2;\n\t\t\t\t\t\t\tvar lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];\n\t\t\t\t\t\t\tfor (var ii = 0, nn = hullLength; ii < nn; ii += 2) {\n\t\t\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\n\t\t\t\t\t\t\t\tshapes.line(x, y, lastX, lastY);\n\t\t\t\t\t\t\t\tlastX = x;\n\t\t\t\t\t\t\t\tlastY = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.drawBoundingBoxes) {\n\t\t\t\t\tvar bounds = this.bounds;\n\t\t\t\t\tbounds.update(skeleton, true);\n\t\t\t\t\tshapes.setColor(this.aabbColor);\n\t\t\t\t\tshapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n\t\t\t\t\tvar polygons = bounds.polygons;\n\t\t\t\t\tvar boxes = bounds.boundingBoxes;\n\t\t\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\n\t\t\t\t\t\tvar polygon = polygons[i];\n\t\t\t\t\t\tshapes.setColor(boxes[i].color);\n\t\t\t\t\t\tshapes.polygon(polygon, 0, polygon.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.drawPaths) {\n\t\t\t\t\tvar slots = skeleton.slots;\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\t\tvar slot = slots[i];\n\t\t\t\t\t\tif (!slot.bone.active)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\t\t\tif (!(attachment instanceof spine.PathAttachment))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar path = attachment;\n\t\t\t\t\t\tvar nn = path.worldVerticesLength;\n\t\t\t\t\t\tvar world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\n\t\t\t\t\t\tpath.computeWorldVertices(slot, 0, nn, world, 0, 2);\n\t\t\t\t\t\tvar color = this.pathColor;\n\t\t\t\t\t\tvar x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;\n\t\t\t\t\t\tif (path.closed) {\n\t\t\t\t\t\t\tshapes.setColor(color);\n\t\t\t\t\t\t\tvar cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];\n\t\t\t\t\t\t\tx2 = world[nn - 4];\n\t\t\t\t\t\t\ty2 = world[nn - 3];\n\t\t\t\t\t\t\tshapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\n\t\t\t\t\t\t\tshapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\n\t\t\t\t\t\t\tshapes.line(x1, y1, cx1, cy1);\n\t\t\t\t\t\t\tshapes.line(x2, y2, cx2, cy2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnn -= 4;\n\t\t\t\t\t\tfor (var ii = 4; ii < nn; ii += 6) {\n\t\t\t\t\t\t\tvar cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];\n\t\t\t\t\t\t\tx2 = world[ii + 4];\n\t\t\t\t\t\t\ty2 = world[ii + 5];\n\t\t\t\t\t\t\tshapes.setColor(color);\n\t\t\t\t\t\t\tshapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\n\t\t\t\t\t\t\tshapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\n\t\t\t\t\t\t\tshapes.line(x1, y1, cx1, cy1);\n\t\t\t\t\t\t\tshapes.line(x2, y2, cx2, cy2);\n\t\t\t\t\t\t\tx1 = x2;\n\t\t\t\t\t\t\ty1 = y2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.drawBones) {\n\t\t\t\t\tshapes.setColor(this.boneOriginColor);\n\t\t\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\n\t\t\t\t\t\tvar bone = bones[i];\n\t\t\t\t\t\tif (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tshapes.circle(true, skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer.GREEN, 8);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.drawClipping) {\n\t\t\t\t\tvar slots = skeleton.slots;\n\t\t\t\t\tshapes.setColor(this.clipColor);\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\n\t\t\t\t\t\tvar slot = slots[i];\n\t\t\t\t\t\tif (!slot.bone.active)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\t\t\tif (!(attachment instanceof spine.ClippingAttachment))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar clip = attachment;\n\t\t\t\t\t\tvar nn = clip.worldVerticesLength;\n\t\t\t\t\t\tvar world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\n\t\t\t\t\t\tclip.computeWorldVertices(slot, 0, nn, world, 0, 2);\n\t\t\t\t\t\tfor (var i_21 = 0, n_3 = world.length; i_21 < n_3; i_21 += 2) {\n\t\t\t\t\t\t\tvar x = world[i_21];\n\t\t\t\t\t\t\tvar y = world[i_21 + 1];\n\t\t\t\t\t\t\tvar x2 = world[(i_21 + 2) % world.length];\n\t\t\t\t\t\t\tvar y2 = world[(i_21 + 3) % world.length];\n\t\t\t\t\t\t\tshapes.line(x, y, x2, y2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tSkeletonDebugRenderer.prototype.dispose = function () {\n\t\t\t};\n\t\t\tSkeletonDebugRenderer.LIGHT_GRAY = new spine.Color(192 / 255, 192 / 255, 192 / 255, 1);\n\t\t\tSkeletonDebugRenderer.GREEN = new spine.Color(0, 1, 0, 1);\n\t\t\treturn SkeletonDebugRenderer;\n\t\t}());\n\t\twebgl.SkeletonDebugRenderer = SkeletonDebugRenderer;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar Renderable = (function () {\n\t\t\tfunction Renderable(vertices, numVertices, numFloats) {\n\t\t\t\tthis.vertices = vertices;\n\t\t\t\tthis.numVertices = numVertices;\n\t\t\t\tthis.numFloats = numFloats;\n\t\t\t}\n\t\t\treturn Renderable;\n\t\t}());\n\t\t;\n\t\tvar SkeletonRenderer = (function () {\n\t\t\tfunction SkeletonRenderer(context, twoColorTint) {\n\t\t\t\tif (twoColorTint === void 0) { twoColorTint = true; }\n\t\t\t\tthis.premultipliedAlpha = false;\n\t\t\t\tthis.vertexEffect = null;\n\t\t\t\tthis.tempColor = new spine.Color();\n\t\t\t\tthis.tempColor2 = new spine.Color();\n\t\t\t\tthis.vertexSize = 2 + 2 + 4;\n\t\t\t\tthis.twoColorTint = false;\n\t\t\t\tthis.renderable = new Renderable(null, 0, 0);\n\t\t\t\tthis.clipper = new spine.SkeletonClipping();\n\t\t\t\tthis.temp = new spine.Vector2();\n\t\t\t\tthis.temp2 = new spine.Vector2();\n\t\t\t\tthis.temp3 = new spine.Color();\n\t\t\t\tthis.temp4 = new spine.Color();\n\t\t\t\tthis.twoColorTint = twoColorTint;\n\t\t\t\tif (twoColorTint)\n\t\t\t\t\tthis.vertexSize += 4;\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(this.vertexSize * 1024);\n\t\t\t}\n\t\t\tSkeletonRenderer.prototype.draw = function (batcher, skeleton, slotRangeStart, slotRangeEnd) {\n\t\t\t\tif (slotRangeStart === void 0) { slotRangeStart = -1; }\n\t\t\t\tif (slotRangeEnd === void 0) { slotRangeEnd = -1; }\n\t\t\t\tvar clipper = this.clipper;\n\t\t\t\tvar premultipliedAlpha = this.premultipliedAlpha;\n\t\t\t\tvar twoColorTint = this.twoColorTint;\n\t\t\t\tvar blendMode = null;\n\t\t\t\tvar tempPos = this.temp;\n\t\t\t\tvar tempUv = this.temp2;\n\t\t\t\tvar tempLight = this.temp3;\n\t\t\t\tvar tempDark = this.temp4;\n\t\t\t\tvar renderable = this.renderable;\n\t\t\t\tvar uvs = null;\n\t\t\t\tvar triangles = null;\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\n\t\t\t\tvar attachmentColor = null;\n\t\t\t\tvar skeletonColor = skeleton.color;\n\t\t\t\tvar vertexSize = twoColorTint ? 12 : 8;\n\t\t\t\tvar inRange = false;\n\t\t\t\tif (slotRangeStart == -1)\n\t\t\t\t\tinRange = true;\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\n\t\t\t\t\tvar clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\n\t\t\t\t\tvar slot = drawOrder[i];\n\t\t\t\t\tif (!slot.bone.active) {\n\t\t\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\n\t\t\t\t\t\tinRange = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inRange) {\n\t\t\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\n\t\t\t\t\t\tinRange = false;\n\t\t\t\t\t}\n\t\t\t\t\tvar attachment = slot.getAttachment();\n\t\t\t\t\tvar texture = null;\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\n\t\t\t\t\t\tvar region = attachment;\n\t\t\t\t\t\trenderable.vertices = this.vertices;\n\t\t\t\t\t\trenderable.numVertices = 4;\n\t\t\t\t\t\trenderable.numFloats = clippedVertexSize << 2;\n\t\t\t\t\t\tregion.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\n\t\t\t\t\t\ttriangles = SkeletonRenderer.QUAD_TRIANGLES;\n\t\t\t\t\t\tuvs = region.uvs;\n\t\t\t\t\t\ttexture = region.region.renderObject.texture;\n\t\t\t\t\t\tattachmentColor = region.color;\n\t\t\t\t\t}\n\t\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\n\t\t\t\t\t\tvar mesh = attachment;\n\t\t\t\t\t\trenderable.vertices = this.vertices;\n\t\t\t\t\t\trenderable.numVertices = (mesh.worldVerticesLength >> 1);\n\t\t\t\t\t\trenderable.numFloats = renderable.numVertices * clippedVertexSize;\n\t\t\t\t\t\tif (renderable.numFloats > renderable.vertices.length) {\n\t\t\t\t\t\t\trenderable.vertices = this.vertices = spine.Utils.newFloatArray(renderable.numFloats);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\n\t\t\t\t\t\ttriangles = mesh.triangles;\n\t\t\t\t\t\ttexture = mesh.region.renderObject.texture;\n\t\t\t\t\t\tuvs = mesh.uvs;\n\t\t\t\t\t\tattachmentColor = mesh.color;\n\t\t\t\t\t}\n\t\t\t\t\telse if (attachment instanceof spine.ClippingAttachment) {\n\t\t\t\t\t\tvar clip = (attachment);\n\t\t\t\t\t\tclipper.clipStart(slot, clip);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (texture != null) {\n\t\t\t\t\t\tvar slotColor = slot.color;\n\t\t\t\t\t\tvar finalColor = this.tempColor;\n\t\t\t\t\t\tfinalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\n\t\t\t\t\t\tfinalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\n\t\t\t\t\t\tfinalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\n\t\t\t\t\t\tfinalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\n\t\t\t\t\t\tif (premultipliedAlpha) {\n\t\t\t\t\t\t\tfinalColor.r *= finalColor.a;\n\t\t\t\t\t\t\tfinalColor.g *= finalColor.a;\n\t\t\t\t\t\t\tfinalColor.b *= finalColor.a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar darkColor = this.tempColor2;\n\t\t\t\t\t\tif (slot.darkColor == null)\n\t\t\t\t\t\t\tdarkColor.set(0, 0, 0, 1.0);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (premultipliedAlpha) {\n\t\t\t\t\t\t\t\tdarkColor.r = slot.darkColor.r * finalColor.a;\n\t\t\t\t\t\t\t\tdarkColor.g = slot.darkColor.g * finalColor.a;\n\t\t\t\t\t\t\t\tdarkColor.b = slot.darkColor.b * finalColor.a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdarkColor.setFromColor(slot.darkColor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdarkColor.a = premultipliedAlpha ? 1.0 : 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar slotBlendMode = slot.data.blendMode;\n\t\t\t\t\t\tif (slotBlendMode != blendMode) {\n\t\t\t\t\t\t\tblendMode = slotBlendMode;\n\t\t\t\t\t\t\tbatcher.setBlendMode(webgl.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl.WebGLBlendModeConverter.getDestGLBlendMode(blendMode));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (clipper.isClipping()) {\n\t\t\t\t\t\t\tclipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);\n\t\t\t\t\t\t\tvar clippedVertices = new Float32Array(clipper.clippedVertices);\n\t\t\t\t\t\t\tvar clippedTriangles = clipper.clippedTriangles;\n\t\t\t\t\t\t\tif (this.vertexEffect != null) {\n\t\t\t\t\t\t\t\tvar vertexEffect = this.vertexEffect;\n\t\t\t\t\t\t\t\tvar verts = clippedVertices;\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\n\t\t\t\t\t\t\t\t\tfor (var v = 0, n_4 = clippedVertices.length; v < n_4; v += vertexSize) {\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\n\t\t\t\t\t\t\t\t\t\ttempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\n\t\t\t\t\t\t\t\t\t\ttempUv.x = verts[v + 6];\n\t\t\t\t\t\t\t\t\t\ttempUv.y = verts[v + 7];\n\t\t\t\t\t\t\t\t\t\ttempDark.set(0, 0, 0, 0);\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (var v = 0, n_5 = clippedVertices.length; v < n_5; v += vertexSize) {\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\n\t\t\t\t\t\t\t\t\t\ttempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\n\t\t\t\t\t\t\t\t\t\ttempUv.x = verts[v + 6];\n\t\t\t\t\t\t\t\t\t\ttempUv.y = verts[v + 7];\n\t\t\t\t\t\t\t\t\t\ttempDark.set(verts[v + 8], verts[v + 9], verts[v + 10], verts[v + 11]);\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = tempDark.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = tempDark.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 10] = tempDark.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 11] = tempDark.a;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbatcher.draw(texture, clippedVertices, clippedTriangles);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar verts = renderable.vertices;\n\t\t\t\t\t\t\tif (this.vertexEffect != null) {\n\t\t\t\t\t\t\t\tvar vertexEffect = this.vertexEffect;\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\n\t\t\t\t\t\t\t\t\tfor (var v = 0, u = 0, n_6 = renderable.numFloats; v < n_6; v += vertexSize, u += 2) {\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\n\t\t\t\t\t\t\t\t\t\ttempUv.x = uvs[u];\n\t\t\t\t\t\t\t\t\t\ttempUv.y = uvs[u + 1];\n\t\t\t\t\t\t\t\t\t\ttempLight.setFromColor(finalColor);\n\t\t\t\t\t\t\t\t\t\ttempDark.set(0, 0, 0, 0);\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (var v = 0, u = 0, n_7 = renderable.numFloats; v < n_7; v += vertexSize, u += 2) {\n\t\t\t\t\t\t\t\t\t\ttempPos.x = verts[v];\n\t\t\t\t\t\t\t\t\t\ttempPos.y = verts[v + 1];\n\t\t\t\t\t\t\t\t\t\ttempUv.x = uvs[u];\n\t\t\t\t\t\t\t\t\t\ttempUv.y = uvs[u + 1];\n\t\t\t\t\t\t\t\t\t\ttempLight.setFromColor(finalColor);\n\t\t\t\t\t\t\t\t\t\ttempDark.setFromColor(darkColor);\n\t\t\t\t\t\t\t\t\t\tvertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n\t\t\t\t\t\t\t\t\t\tverts[v] = tempPos.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = tempPos.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = tempLight.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = tempLight.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = tempLight.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = tempLight.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = tempUv.x;\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = tempUv.y;\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = tempDark.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = tempDark.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 10] = tempDark.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 11] = tempDark.a;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (!twoColorTint) {\n\t\t\t\t\t\t\t\t\tfor (var v = 2, u = 0, n_8 = renderable.numFloats; v < n_8; v += vertexSize, u += 2) {\n\t\t\t\t\t\t\t\t\t\tverts[v] = finalColor.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = finalColor.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = finalColor.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = finalColor.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = uvs[u];\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = uvs[u + 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (var v = 2, u = 0, n_9 = renderable.numFloats; v < n_9; v += vertexSize, u += 2) {\n\t\t\t\t\t\t\t\t\t\tverts[v] = finalColor.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 1] = finalColor.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 2] = finalColor.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 3] = finalColor.a;\n\t\t\t\t\t\t\t\t\t\tverts[v + 4] = uvs[u];\n\t\t\t\t\t\t\t\t\t\tverts[v + 5] = uvs[u + 1];\n\t\t\t\t\t\t\t\t\t\tverts[v + 6] = darkColor.r;\n\t\t\t\t\t\t\t\t\t\tverts[v + 7] = darkColor.g;\n\t\t\t\t\t\t\t\t\t\tverts[v + 8] = darkColor.b;\n\t\t\t\t\t\t\t\t\t\tverts[v + 9] = darkColor.a;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar view = renderable.vertices.subarray(0, renderable.numFloats);\n\t\t\t\t\t\t\tbatcher.draw(texture, view, triangles);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tclipper.clipEndWithSlot(slot);\n\t\t\t\t}\n\t\t\t\tclipper.clipEnd();\n\t\t\t};\n\t\t\tSkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n\t\t\treturn SkeletonRenderer;\n\t\t}());\n\t\twebgl.SkeletonRenderer = SkeletonRenderer;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar Vector3 = (function () {\n\t\t\tfunction Vector3(x, y, z) {\n\t\t\t\tif (x === void 0) { x = 0; }\n\t\t\t\tif (y === void 0) { y = 0; }\n\t\t\t\tif (z === void 0) { z = 0; }\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t}\n\t\t\tVector3.prototype.setFrom = function (v) {\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.set = function (x, y, z) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.add = function (v) {\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.sub = function (v) {\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.scale = function (s) {\n\t\t\t\tthis.x *= s;\n\t\t\t\tthis.y *= s;\n\t\t\t\tthis.z *= s;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.normalize = function () {\n\t\t\t\tvar len = this.length();\n\t\t\t\tif (len == 0)\n\t\t\t\t\treturn this;\n\t\t\t\tlen = 1 / len;\n\t\t\t\tthis.x *= len;\n\t\t\t\tthis.y *= len;\n\t\t\t\tthis.z *= len;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tVector3.prototype.cross = function (v) {\n\t\t\t\treturn this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\n\t\t\t};\n\t\t\tVector3.prototype.multiply = function (matrix) {\n\t\t\t\tvar l_mat = matrix.values;\n\t\t\t\treturn this.set(this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03], this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13], this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]);\n\t\t\t};\n\t\t\tVector3.prototype.project = function (matrix) {\n\t\t\t\tvar l_mat = matrix.values;\n\t\t\t\tvar l_w = 1 / (this.x * l_mat[webgl.M30] + this.y * l_mat[webgl.M31] + this.z * l_mat[webgl.M32] + l_mat[webgl.M33]);\n\t\t\t\treturn this.set((this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03]) * l_w, (this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13]) * l_w, (this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]) * l_w);\n\t\t\t};\n\t\t\tVector3.prototype.dot = function (v) {\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\t\t};\n\t\t\tVector3.prototype.length = function () {\n\t\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t\t\t};\n\t\t\tVector3.prototype.distance = function (v) {\n\t\t\t\tvar a = v.x - this.x;\n\t\t\t\tvar b = v.y - this.y;\n\t\t\t\tvar c = v.z - this.z;\n\t\t\t\treturn Math.sqrt(a * a + b * b + c * c);\n\t\t\t};\n\t\t\treturn Vector3;\n\t\t}());\n\t\twebgl.Vector3 = Vector3;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n\tvar webgl;\n\t(function (webgl) {\n\t\tvar ManagedWebGLRenderingContext = (function () {\n\t\t\tfunction ManagedWebGLRenderingContext(canvasOrContext, contextConfig) {\n\t\t\t\tif (contextConfig === void 0) { contextConfig = { alpha: \"true\" }; }\n\t\t\t\tthis.restorables = new Array();\n\t\t\t\tif (canvasOrContext instanceof HTMLCanvasElement || canvasOrContext instanceof EventTarget) {\n\t\t\t\t\tthis.setupCanvas(canvasOrContext, contextConfig);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.gl = canvasOrContext;\n\t\t\t\t\tthis.canvas = this.gl.canvas;\n\t\t\t\t}\n\t\t\t}\n\t\t\tManagedWebGLRenderingContext.prototype.setupCanvas = function (canvas, contextConfig) {\n\t\t\t\tvar _this = this;\n\t\t\t\tthis.gl = (canvas.getContext(\"webgl2\", contextConfig) || canvas.getContext(\"webgl\", contextConfig));\n\t\t\t\tthis.canvas = canvas;\n\t\t\t\tcanvas.addEventListener(\"webglcontextlost\", function (e) {\n\t\t\t\t\tvar event = e;\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcanvas.addEventListener(\"webglcontextrestored\", function (e) {\n\t\t\t\t\tfor (var i = 0, n = _this.restorables.length; i < n; i++) {\n\t\t\t\t\t\t_this.restorables[i].restore();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tManagedWebGLRenderingContext.prototype.addRestorable = function (restorable) {\n\t\t\t\tthis.restorables.push(restorable);\n\t\t\t};\n\t\t\tManagedWebGLRenderingContext.prototype.removeRestorable = function (restorable) {\n\t\t\t\tvar index = this.restorables.indexOf(restorable);\n\t\t\t\tif (index > -1)\n\t\t\t\t\tthis.restorables.splice(index, 1);\n\t\t\t};\n\t\t\treturn ManagedWebGLRenderingContext;\n\t\t}());\n\t\twebgl.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;\n\t\tvar WebGLBlendModeConverter = (function () {\n\t\t\tfunction WebGLBlendModeConverter() {\n\t\t\t}\n\t\t\tWebGLBlendModeConverter.getDestGLBlendMode = function (blendMode) {\n\t\t\t\tswitch (blendMode) {\n\t\t\t\t\tcase spine.BlendMode.Normal: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n\t\t\t\t\tcase spine.BlendMode.Additive: return WebGLBlendModeConverter.ONE;\n\t\t\t\t\tcase spine.BlendMode.Multiply: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n\t\t\t\t\tcase spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n\t\t\t\t\tdefault: throw new Error(\"Unknown blend mode: \" + blendMode);\n\t\t\t\t}\n\t\t\t};\n\t\t\tWebGLBlendModeConverter.getSourceGLBlendMode = function (blendMode, premultipliedAlpha) {\n\t\t\t\tif (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n\t\t\t\tswitch (blendMode) {\n\t\t\t\t\tcase spine.BlendMode.Normal: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\n\t\t\t\t\tcase spine.BlendMode.Additive: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\n\t\t\t\t\tcase spine.BlendMode.Multiply: return WebGLBlendModeConverter.DST_COLOR;\n\t\t\t\t\tcase spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE;\n\t\t\t\t\tdefault: throw new Error(\"Unknown blend mode: \" + blendMode);\n\t\t\t\t}\n\t\t\t};\n\t\t\tWebGLBlendModeConverter.ZERO = 0;\n\t\t\tWebGLBlendModeConverter.ONE = 1;\n\t\t\tWebGLBlendModeConverter.SRC_COLOR = 0x0300;\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_SRC_COLOR = 0x0301;\n\t\t\tWebGLBlendModeConverter.SRC_ALPHA = 0x0302;\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA = 0x0303;\n\t\t\tWebGLBlendModeConverter.DST_ALPHA = 0x0304;\n\t\t\tWebGLBlendModeConverter.ONE_MINUS_DST_ALPHA = 0x0305;\n\t\t\tWebGLBlendModeConverter.DST_COLOR = 0x0306;\n\t\t\treturn WebGLBlendModeConverter;\n\t\t}());\n\t\twebgl.WebGLBlendModeConverter = WebGLBlendModeConverter;\n\t})(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\n//# sourceMappingURL=spine-webgl.js.map\nexport { spine };",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import Card from '@material-ui/core/Card';\nimport CardContent from '@material-ui/core/CardContent';\nimport CardHeader from '@material-ui/core/CardHeader';\nimport { red } from '@material-ui/core/colors';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport React from 'react';\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            flexGrow: 1,\n        },\n        media: {\n            height: 0,\n            paddingTop: '56.25%', // 16:9\n        },\n        expand: {\n            transform: 'rotate(0deg)',\n            marginLeft: 'auto',\n            transition: theme.transitions.create('transform', {\n                duration: theme.transitions.duration.shortest,\n            }),\n        },\n        expandOpen: {\n            transform: 'rotate(180deg)',\n        },\n        avatar: {\n            backgroundColor: red[500],\n        },\n    }),\n);\n\ntype Props = {\n    canvasRef: React.MutableRefObject<HTMLCanvasElement>,\n    title: string\n}\n\nexport default function CanvasCard(props: Props) {\n    const classes = useStyles();\n    const [expanded, setExpanded] = React.useState(true);\n\n    const handleExpandClick = () => {\n        setExpanded(!expanded);\n    };\n\n    return (\n        <Card className={classes.root}>\n            <CardHeader\n                title={props.title}\n            />\n            <CardContent>\n                <canvas ref={props.canvasRef} />\n            </CardContent>\n        </Card>\n    );\n}","import { useState } from 'react';\nimport { useRef, useEffect } from 'react'\n\ntype Options = {\n    context: string,\n    width: number,\n    height: number\n}\n\n\n// function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement) {\n\n//     const { width, height } = canvas.getBoundingClientRect()\n\n//     if (canvas.width !== width || canvas.height !== height) {\n//         canvas.width = width\n//         canvas.height = height\n//         return true // here you can return some usefull information like delta width and delta height instead of just true\n//         // this information can be used in the next redraw...\n//     }\n\n//     return false\n// }\n\nconst useCanvas = (\n    draw: (context: RenderingContext) => void,\n    options: Options\n) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    useEffect(() => {\n        const canvas = canvasRef.current\n\n        if (canvas) {\n            canvas.height = options.height\n            canvas.width = options.width\n            // resizeCanvasToDisplaySize(canvas)\n            const context = canvas.getContext(options.context || '2d')\n            if (context) {\n                let animationFrameId = 0\n                const render = () => {\n                    draw(context)\n                    animationFrameId = window.requestAnimationFrame(() => render)\n                }\n                render()\n                return () => {\n                    window.cancelAnimationFrame(animationFrameId)\n                }\n            }\n        }\n    }, [draw])\n    return canvasRef\n}\nexport default useCanvas\n","import React, { useEffect, useRef, useState } from \"react\";\n\nconst useWebcam = (\n    width: number,\n    height: number\n) => {\n    const [stream, setStream] = useState<MediaStream | null>(null)\n    const videoRef = useRef<HTMLVideoElement>(null)\n    useEffect(() => {\n        const initStream = async () => {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                \"audio\": false,\n                \"video\": {\n                    facingMode: 'user',\n                    width: width,\n                    height: height\n                }\n            });\n            setStream(stream);\n        }\n        initStream()\n    }, [])\n    // play webcam, not visible yet\n    useEffect(() => {\n        const video = videoRef.current\n        if (stream && video) {\n            video.srcObject = stream;\n            video.width = width;\n            video.height = height;\n            video.play();\n        }\n    }, [stream])\n    return videoRef\n}\nexport default useWebcam\n","import Grid from \"@material-ui/core/Grid\";\nimport { createStyles, makeStyles, Theme } from \"@material-ui/core/styles\";\nimport { getAdjacentKeyPoints, load as loadPoseNet, Pose, PoseNet } from '@tensorflow-models/posenet';\nimport { Vector2D } from \"@tensorflow-models/posenet/dist/types\";\nimport * as tfjs from '@tensorflow/tfjs';\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { coco_skeleton_indices } from '../../config/skeleton';\nimport { spine } from '../../lib/spine/spine-webgl';\nimport PoseAPI from \"../pose/PoseAPI\";\nimport CanvasCard from \"./CanvasCard\";\nimport useCanvas from \"./useCanvas\";\nimport useWebcam from \"./useWebcam\";\n\n\n\ntype Model2D = {\n    skeleton: spine.Skeleton,\n    state: spine.AnimationState,\n    bounds: { offset: number, size: number },\n    premultipliedAlpha: boolean\n}\n\ntype PoseSkeleton = {\n    root: spine.webgl.Bone,\n    hip: spine.webgl.Bone,\n    neck: spine.webgl.Bone,\n    head: spine.webgl.Bone,\n    leftArm: spine.webgl.Bone,\n    leftForeArm: spine.webgl.Bone,\n    rightArm: spine.webgl.Bone,\n    rightForeArm: spine.webgl.Bone,\n    leftUpLeg: spine.webgl.Bone,\n    leftLeg: spine.webgl.Bone,\n    rightUpLeg: spine.webgl.Bone,\n    rightLeg: spine.webgl.Bone\n}\n\ntype PoseSkeletonKeypointName = {\n    root: string,\n    hip: string,\n    neck: string,\n    head: string,\n    leftArm: string,\n    leftForeArm: string,\n    rightArm: string,\n    rightForeArm: string,\n    leftUpLeg: string,\n    leftLeg: string,\n    rightUpLeg: string,\n    rightLeg: string\n}\n\ntype Model2DInfo = {\n    atlas: string,\n    json: string,\n    skinName: string,\n    initialAnimation: string,\n    poseSkeletonKeypointName: PoseSkeletonKeypointName,\n    scale: number\n}\n\n\nfunction calculateSetupPoseBounds(skeleton) {\n    skeleton.setToSetupPose();\n    skeleton.updateWorldTransform();\n    const offset = new spine.Vector2();\n    const size = new spine.Vector2();\n    skeleton.getBounds(offset, size, []);\n    return { offset: offset, size: size };\n}\n\n\n// result angle is x-axis flipped angle. because esimated coords have y-axis inverted in graphical coord standard\nfunction getAngle(initPt: { x: number; y: number; }, termPt: { x: number; y: number; }) {\n    const x = termPt.x - initPt.x;\n    const y = termPt.y - initPt.y;\n    const l = Math.sqrt(x ** 2 + y ** 2);\n    const co = x / l;\n    let angle: number;\n\n    if (y > 0) { angle = Math.acos(co) * (180 / Math.PI) } else { angle = 360 - Math.acos(co) * (180 / Math.PI) }\n\n    //flip the angle upon x-axis, because coords has y-axis inverted.\n    angle = 360 - angle;\n\n    return angle;\n}\n\nfunction drawPoint(ctx, x, y, r, color) {\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, 2 * Math.PI);\n    ctx.fillStyle = color;\n    ctx.fill();\n}\n\n/**\n * Draw pose keypoints onto a canvas\n */\nfunction drawKeypoints(keypoints, minConfidence, ctx, scale = 1, color) {\n    for (let i = 0; i < keypoints.length; i++) {\n        const keypoint = keypoints[i];\n\n        if (keypoint.score < minConfidence) {\n            continue;\n        }\n\n        const { x, y } = keypoint.position;\n        drawPoint(ctx, x * scale, y * scale, 3, color);\n    }\n}\nfunction toTuple(data: Vector2D): [number, number] {\n    return [data.x, data.y];\n}\n/**\n * Draws a pose skeleton by looking up all adjacent keypoints/joints\n */\nfunction drawSkeleton(keypoints, minConfidence, ctx, scale = 1, color) {\n    const adjacentKeyPoints =\n        getAdjacentKeyPoints(keypoints, minConfidence);\n\n    adjacentKeyPoints.forEach((keypoints) => {\n        drawSegment(\n            toTuple(keypoints[0].position),\n            toTuple(keypoints[1].position),\n            color,\n            scale, ctx);\n    });\n}\n\n/**\n * Draws a line on a canvas, i.e. a joint\n */\nfunction drawSegment([ax, ay]: [number, number], [bx, by]: [number, number], color, scale, ctx) {\n    ctx.beginPath();\n    ctx.moveTo(ax * scale, ay * scale);\n    ctx.lineTo(bx * scale, by * scale);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = color;\n    ctx.stroke();\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n    createStyles({\n        root: {\n            flexGrow: 1,\n        }\n    }),\n);\n\n\nexport function PoseAnimation() {\n    const [net, setNet] = useState<PoseNet>(null)\n    const [assetManager, setAssetManager] = useState<spine.webgl.AssetManager>(null)\n    const [initialized, setInitialized] = useState<boolean>(false)\n    const [managerLoaded, setManagerLoaded] = useState<boolean>(false)\n    const [videoLoadedData, setVideoLoadedData] = useState<boolean>(false)\n    const [model2D, setModel2D] = useState<Model2D>(null);\n    const [bonesToInvisible, setBonesToInvisible] = useState<Array<string>>([])\n    const [skeletonRender, setSkeletonRender] = useState<spine.webgl.SceneRenderer>(null)\n    const [poseSkeleton, setPoseSkeleton] = useState<PoseSkeleton>();\n\n    const skeletonKeypointName = {\n        hip: \"hip\", rightUpLeg: \"front-thigh\", rightLeg: \"front-shin\",\n        leftUpLeg: \"rear-thigh\", leftLeg: \"rear-shin\", neck: \"neck\",\n        head: \"head\", rightArm: \"front-upper-arm\", rightForeArm: \"front-bracer\",\n        leftArm: \"rear-upper-arm\", leftForeArm: \"rear-bracer\", root: \"root\"\n    }\n    const [model2DInfo, setModel2DInfo] = useState<Model2DInfo>(\n        {\n            atlas: \"assets/spineboy.atlas\",\n            json: \"assets/spineboy-ess.json\",\n            skinName: \"default\",\n            initialAnimation: \"idle\",\n            poseSkeletonKeypointName: skeletonKeypointName,\n            scale: 0.5\n        }\n    )\n\n    const [humanPose, setHumanPose] = useState<Pose>(null)\n    const [animationPose, setAnimationPose] = useState<Pose>(null)\n    const [animationPoseRendered, setAnimationPoseRendered] = useState<boolean>(true)\n\n    const humanWidth = 400\n    const humanHeight = 300\n    const animationWidth = 400\n    const animationHeight = 300\n    const webcamRef = useWebcam(humanWidth, humanHeight);\n    const minConfidence = 0.6\n    const faceMaskImageRef = useRef<HTMLImageElement>(null)\n\n    useEffect(() => {\n        const image = faceMaskImageRef.current\n        if (faceMaskImageRef.current) {\n            image.src = 'shasha.jpeg'\n        }\n    }, [faceMaskImageRef.current])\n\n    useEffect(() => {\n        if (webcamRef.current) {\n            webcamRef.current.onloadeddata = (event) => {\n                setVideoLoadedData(true)\n            };\n        }\n    }, [webcamRef.current])\n\n    useEffect(() => {\n        const getPose = async () => {\n            const pose = await net.estimateSinglePose(webcamRef.current, {\n                flipHorizontal: false\n            });\n            // const pose = (await PoseAPI.getPose())[0]\n\n            setAnimationPose(pose)\n            setHumanPose(pose)\n            setAnimationPoseRendered(false)\n        }\n        initialized && animationPoseRendered && getPose()\n    }, [initialized, animationPoseRendered])\n\n    const loadModel2D = (\n        premultipliedAlpha: boolean\n    ): Model2D => {\n        // Load the texture atlas from the AssetManager.\n\n        const atlas = assetManager.get(model2DInfo.atlas);\n\n        // Create a AtlasAttachmentLoader that resolves region, mesh, boundingbox and path attachments\n        const atlasLoader = new spine.AtlasAttachmentLoader(atlas);\n\n        // Create a SkeletonBinary instance for parsing the .skel file.\n        const skeletonJson = new spine.SkeletonJson(atlasLoader);\n\n        // Set the scale to apply during parsing, parse the file, and create a new skeleton.\n        skeletonJson.scale = model2DInfo.scale;\n        const skeletonData = skeletonJson.readSkeletonData(assetManager.get(model2DInfo.json));\n        const skeleton = new spine.Skeleton(skeletonData);\n        skeleton.setSkinByName(model2DInfo.skinName);\n        const bounds = calculateSetupPoseBounds(skeleton);\n\n        // Create an AnimationState, and set the initial animation in looping mode.\n        const animationStateData = new spine.AnimationStateData(skeleton.data);\n        const animationState = new spine.AnimationState(animationStateData);\n        animationState.setAnimation(0, model2DInfo.initialAnimation, true);\n\n        // Pack everything up and return to caller.\n        return { skeleton: skeleton, state: animationState, bounds: bounds, premultipliedAlpha: premultipliedAlpha };\n    }\n\n    const drawHuman = (context: RenderingContext) => {\n        if (initialized && context instanceof CanvasRenderingContext2D && humanPose) {\n            //draw webcam on human canvas\n            context.save();\n            context.drawImage(webcamRef.current, 0, 0, humanWidth, humanHeight);\n            //un-comment line below if you want to hide your face for record n share purpose\n            context.drawImage(faceMaskImageRef.current, humanPose.keypoints[coco_skeleton_indices.nose].position.x - 75, humanPose.keypoints[coco_skeleton_indices.nose].position.y - 63, 150, 126);\n            context.restore();\n            drawKeypoints(humanPose.keypoints, minConfidence, context, 1, \"#00ff00\");\n            drawSkeleton(humanPose.keypoints, minConfidence, context, 1, \"#ffffff\");\n        }\n    }\n\n\n    const drawAnimation = (context: RenderingContext) => {\n        // Get two keypoints, a character bone and minConfidence\n        // Animate bone if minimum confidence condition is met\n        const animateDetectedBone = (chaBone, initKeyPt, termKeyPt, minConfidence, skeleton) => {\n\n            if (model2DInfo.poseSkeletonKeypointName.hip == chaBone.data.name) {\n                chaBone.x = animationWidth / 2\n                chaBone.y = animationHeight / 2\n            }\n            if (initKeyPt.score > minConfidence && termKeyPt.score > minConfidence) {\n                chaBone.rotation = chaBone.worldToLocalRotation(getAngle(initKeyPt.position, termKeyPt.position));\n\n                if ([\n                    model2DInfo.poseSkeletonKeypointName.head,\n                    // model2DInfo.poseSkeletonKeypointName.hip,\n                    model2DInfo.poseSkeletonKeypointName.neck\n                ].includes(chaBone.data.name)) {\n                    if (initKeyPt.position.x < termKeyPt.position.x) {\n                        chaBone.rotation += 90;\n                    }\n                    else {\n                        chaBone.rotation -= 90;\n                    }\n                }\n                // skeleton's all bones should be updated whenever a bone's transform is changed.\n                skeleton.updateWorldTransform();\n            }\n\n        }\n\n        if (initialized && context instanceof WebGLRenderingContext && !animationPoseRendered && animationPose) {\n            const pose = animationPose\n\n            context.clearColor(0.3, 0.3, 0.3, 1);\n            context.clear(context.COLOR_BUFFER_BIT);\n\n            //prepare for skeleton data to animate upon coords of estimated pose\n            const skeleton = model2D.skeleton;\n\n            skeletonRender.begin();\n\n            // manipulate bones manually upon pose detection\n            animateDetectedBone(poseSkeleton.head, pose.keypoints[coco_skeleton_indices.rightEye], pose.keypoints[coco_skeleton_indices.leftEye], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.leftUpLeg, pose.keypoints[coco_skeleton_indices.leftHip], pose.keypoints[coco_skeleton_indices.leftKnee], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.leftLeg, pose.keypoints[coco_skeleton_indices.leftKnee], pose.keypoints[coco_skeleton_indices.leftAnkle], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.rightUpLeg, pose.keypoints[coco_skeleton_indices.rightHip], pose.keypoints[coco_skeleton_indices.rightKnee], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.rightLeg, pose.keypoints[coco_skeleton_indices.rightKnee], pose.keypoints[coco_skeleton_indices.rightAnkle], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.leftArm, pose.keypoints[coco_skeleton_indices.leftShoulder], pose.keypoints[coco_skeleton_indices.leftElbow], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.leftForeArm, pose.keypoints[coco_skeleton_indices.leftElbow], pose.keypoints[coco_skeleton_indices.leftWrist], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.rightArm, pose.keypoints[coco_skeleton_indices.rightShoulder], pose.keypoints[coco_skeleton_indices.rightElbow], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.rightForeArm, pose.keypoints[coco_skeleton_indices.rightElbow], pose.keypoints[coco_skeleton_indices.rightWrist], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.hip, pose.keypoints[coco_skeleton_indices.rightHip], pose.keypoints[coco_skeleton_indices.leftHip], minConfidence, skeleton);\n            animateDetectedBone(poseSkeleton.neck, pose.keypoints[coco_skeleton_indices.rightShoulder], pose.keypoints[coco_skeleton_indices.leftShoulder], minConfidence, skeleton);\n\n            skeleton.updateWorldTransform();\n\n\n\n            //draw on animal canvas\n            skeletonRender.drawSkeleton(skeleton, false);\n\n            skeletonRender.drawSkeletonDebug(skeleton, false, bonesToInvisible);\n\n\n            skeletonRender.end();\n            setAnimationPoseRendered(true)\n        }\n    }\n\n    const initManager = (context: WebGLRenderingContext) => {\n        //create asset manager object\n        const aManager = new spine.webgl.AssetManager(context)\n\n\n        //create rendering object\n        setSkeletonRender(new spine.webgl.SceneRenderer(context.canvas, context));\n\n        aManager.loadTextureAtlas(model2DInfo.atlas);\n        aManager.loadText(model2DInfo.json);\n        setAssetManager(aManager)\n    }\n\n    const loadManager = () => {\n        if (assetManager.isLoadingComplete()) {\n            setManagerLoaded(true)\n        } else {\n            setTimeout(loadManager, 1000)\n        }\n    }\n\n    const initSkeleton = (canvasWidth: number, canvasHeight: number) => {\n        //parachute animation preset is good for motion capture, because it disabled all IK bones and transform constrains.\n        const model2D = loadModel2D(false)\n\n        // Assign every targeted bones. we do this before rendering, else searching for this bone will need searching through 30-long lists each time, each frame.\n        const curPoseSkeleton = {\n            root: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.root),\n            hip: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.hip),\n            neck: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.neck),\n            head: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.head),\n            leftUpLeg: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.leftUpLeg),\n            leftLeg: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.leftLeg),\n            rightUpLeg: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.rightUpLeg),\n            rightLeg: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.rightLeg),\n            leftArm: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.leftArm),\n            leftForeArm: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.leftForeArm),\n            rightArm: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.rightArm),\n            rightForeArm: model2D.skeleton.findBone(model2DInfo.poseSkeletonKeypointName.rightForeArm),\n        }\n        setPoseSkeleton(curPoseSkeleton);\n\n        // initial update\n        model2D.state.update(0.0333);\n        model2D.state.apply(model2D.skeleton);\n\n        //camera(in Spine runtime) position's pivot point is middle point, therefore we devide dimentions by 2 and set the camera position to there so that the bottom left point of viewport camera becomes 0, 0\n        skeletonRender.camera.position.set(canvasWidth / 2, canvasHeight / 2, 0);\n\n        //options of debugging \n        skeletonRender.skeletonDebugRenderer.drawBones = true;\n        skeletonRender.skeletonDebugRenderer.drawRegionAttachments = false;\n        skeletonRender.skeletonDebugRenderer.drawBoundingBoxes = false;\n        skeletonRender.skeletonDebugRenderer.drawMeshHull = false;\n        skeletonRender.skeletonDebugRenderer.drawMeshTriangles = false;\n        skeletonRender.skeletonDebugRenderer.drawPaths = false;\n        skeletonRender.skeletonDebugRenderer.drawSkeletonXY = false;\n        skeletonRender.skeletonDebugRenderer.drawClipping = false;\n        skeletonRender.skeletonDebugRenderer.premultipliedAlpha = true;\n\n        const invisibleBones = []\n        // we make list for bones to hide in debug\n        const validBones = Object.values(model2DInfo.poseSkeletonKeypointName)\n        for (let i = 0, n = model2D.skeleton.bones.length; i < n; i++) {\n            const _bone = model2D.skeleton.bones[i];\n            if (!validBones.includes(_bone.data.name)) {\n                invisibleBones.push(_bone.data.name)\n            }\n        }\n        setBonesToInvisible(invisibleBones)\n        setModel2D(model2D);\n    }\n\n\n    const animationContextType = \"webgl\"\n    const humanContextType = \"2d\"\n    const animationCanvasRef = useCanvas(drawAnimation, { context: animationContextType, width: animationWidth, height: animationHeight })\n    const humanCanvasRef = useCanvas(drawHuman, { context: humanContextType, width: humanWidth, height: humanHeight })\n\n    useEffect(() => {\n        const loadModel = async () => {\n            tfjs.setBackend('webgl')\n            setNet(\n                await loadPoseNet({\n                    architecture: 'MobileNetV1',\n                    outputStride: 16,\n                    inputResolution: 500,\n                    multiplier: 0.75,\n                    quantBytes: 2\n                })\n            )\n        }\n        loadModel()\n    }, []);\n    useEffect(() => {\n        animationCanvasRef.current && initManager(animationCanvasRef.current.getContext(animationContextType))\n    }, [animationCanvasRef.current])\n    useEffect(() => {\n        assetManager && loadManager()\n    }, [assetManager])\n    useEffect(() => {\n        managerLoaded && initSkeleton(animationWidth, animationHeight)\n    }, [managerLoaded])\n    useEffect(() => {\n        managerLoaded && net && videoLoadedData && setInitialized(true)\n    }, [managerLoaded && net && videoLoadedData])\n\n\n    const classes = useStyles();\n\n    return (\n        <div className={classes.root}>\n            {managerLoaded ? <h2>2D模型载入成功！</h2> : <h2>载入2D模型中...</h2>}\n            {net ? <h2>姿态识别模型载入成功！</h2> : <h2>载入姿态识别模型中...</h2>}\n            {videoLoadedData ? <h2>摄像头启动成功！</h2> : <h2>摄像头启动中...</h2>}\n            <img ref={faceMaskImageRef} style={{ display: 'none' }}/>\n            <video ref={webcamRef} playsInline={true} style={{ display: 'none' }} />\n\n            <Grid\n                container\n                spacing={3}\n                direction=\"column\"\n                justify=\"center\"\n                alignItems=\"stretch\"\n            >\n                <Grid item xs={12}>\n                    <CanvasCard canvasRef={humanCanvasRef} title={\"摄像头视频\"} />\n                </Grid>\n                <Grid item xs={12}>\n                    <CanvasCard canvasRef={animationCanvasRef} title={\"动画\"} />\n                </Grid>\n            </Grid>\n            {/* <canvas ref={humanCanvasRef} /> */}\n            {/* <canvas ref={animationCanvasRef} /> */}\n        </div>\n    )\n}\n","import { Container } from '@material-ui/core';\nimport React from 'react';\nimport './App.css';\nimport { PoseAnimation } from './components/animation/PoseAnimation'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Container maxWidth=\"md\">\n        <PoseAnimation />\n      </Container>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}